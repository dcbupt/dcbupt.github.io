<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2022/05/01/blog_article/README/</url>
    <content><![CDATA[<p>空空如也</p>
]]></content>
  </entry>
  <entry>
    <title>ConcurrentModificationException的原因以及解决措施</title>
    <url>/2017/04/21/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/ConcurrentModificationException%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD/</url>
    <content><![CDATA[<h1 id="ConcurrentModificationException异常出现的原因"><a href="#ConcurrentModificationException异常出现的原因" class="headerlink" title="ConcurrentModificationException异常出现的原因"></a>ConcurrentModificationException异常出现的原因</h1><p>先看下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		list.add(2);</span><br><span class="line">		Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			Integer integer = iterator.next();</span><br><span class="line">			if (integer == 2)</span><br><span class="line">				list.remove(integer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常出现在checkForComodification()方法中。<br>我们不忙看checkForComodification()方法的具体实现，我们先根据程序的代码一步一步看ArrayList源码的实现：<br>首先看ArrayList的iterator()方法的具体实现，查看源码发现在ArrayList的源码中并没有iterator()这个方法，那么很显然这个方法应该是其父类或者实现的接口中的方法，我们在其父类AbstractList中找到了iterator()方法的具体实现，下面是其实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出返回的是一个指向Itr类型对象的引用，我们接着看Itr的具体实现，在AbstractList类中找到了Itr类的具体实现，它是AbstractList的一个成员内部类，下面这段代码是Itr类的所有实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int cursor = 0;</span><br><span class="line"></span><br><span class="line">    int lastRet = -1;</span><br><span class="line"></span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line"></span><br><span class="line">           return cursor != size();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E next() &#123;</span><br><span class="line"></span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">        E next = get(cursor);</span><br><span class="line"></span><br><span class="line">        lastRet = cursor++;</span><br><span class="line"></span><br><span class="line">        return next;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line"></span><br><span class="line">        if (lastRet == -1)</span><br><span class="line"></span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">        AbstractList.this.remove(lastRet);</span><br><span class="line"></span><br><span class="line">        if (lastRet &lt; cursor)</span><br><span class="line"></span><br><span class="line">            cursor--;</span><br><span class="line"></span><br><span class="line">        lastRet = -1;</span><br><span class="line"></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line"></span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line"></span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line"></span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们看一下它的几个成员变量：<br>cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出<br>lastRet：表示上一个访问的元素的索引　　<br>expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。<br>modCount是AbstractList类中的一个成员变量<br><code>protected transient int modCount = 0;</code><br><code>该值表示对List的修改次数，查看ArrayList的add()和remove()方法就可以发现，每次调用add()方法或者remove()方法就会对modCount进行加1操作</code></p>
<p>好了，到这里我们再看看上面的程序：<br>当调用list.iterator()返回一个Iterator之后，通过Iterator的hashNext()方法判断是否还有元素未被访问，我们看一下hasNext()方法，hashNext()方法的实现很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return cursor != size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果下一个访问的元素下标不等于ArrayList的大小，就表示有元素需要访问，这个很容易理解，如果下一个访问元素的下标等于ArrayList的大小，则肯定到达末尾了。<br>然后通过Iterator的next()方法获取到下标为0的元素，我们看一下next()方法的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line"></span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line"></span><br><span class="line">    E next = get(cursor);</span><br><span class="line"></span><br><span class="line">    lastRet = cursor++;</span><br><span class="line"></span><br><span class="line">    return next;</span><br><span class="line"></span><br><span class="line"> &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line"></span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是非常关键的地方：首先在next()方法中会调用checkForComodification()方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。<code>注意此时，modCount为0，expectedModCount也为0</code>。</p>
<p>接着往下看，程序中判断当前元素的值是否为2，若为2，则调用list.remove()方法来删除该元素。<br>我们看一下在ArrayList中的remove()方法做了什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line"></span><br><span class="line">    if (o == null) &#123;</span><br><span class="line"></span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line"></span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line"></span><br><span class="line">                fastRemove(index);</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line"></span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line"></span><br><span class="line">                fastRemove(index);</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line"></span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line"></span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line"></span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">    elementData[--size] = null; // Let gc do its work</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>通过remove方法删除元素最终是调用的fastRemove()方法，在fastRemove()方法中，首先对modCount进行加1操作（因为对集合修改了一次）</code>，然后接下来就是删除元素的操作，最后将size进行减1操作，并将引用置为null以方便垃圾收集器进行回收工作。</p>
<p>那么注意此时各个变量的值：对于iterator，其expectedModCount为0，cursor的值为1，lastRet的值为0。<br>对于list，其modCount为1，size为0。</p>
<p>接着看程序代码，执行完删除操作后，继续while循环，调用hasNext方法()判断，由于此时cursor为1，而size为0，那么返回true，所以继续执行while循环，然后继续调用iterator的next()方法：<br>注意，<code>此时要注意next()方法中的第一句：checkForComodification()</code>。<br>在checkForComodification方法中进行的操作是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line"></span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line"></span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果modCount不等于expectedModCount，则抛出ConcurrentModificationException异常。<br>很显然，此时modCount为1，而expectedModCount为0，因此程序就抛出了ConcurrentModificationException异常。<br>到这里，想必大家应该明白为何上述代码会抛出ConcurrentModificationException异常了。<br>关键点就在于：</p>
<blockquote>
<p>调用list.remove()方法导致modCount和expectedModCount的值不一致（list.remove会修改modCount，因为modCount就是标识list修改的次数，而expectedModCount只是标识iterator修改list的次数），所以list.add()也会造成同样的异常。</p>
</blockquote>
<p>注意，像使用for-each进行迭代实际上也会出现这种问题</p>
<h1 id="在单线程环境下的解决办法"><a href="#在单线程环境下的解决办法" class="headerlink" title="在单线程环境下的解决办法"></a>在单线程环境下的解决办法</h1><p>既然知道原因了，那么如何解决呢？<br>其实很简单，细心的朋友可能发现在Itr类中也给出了一个remove()方法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line"></span><br><span class="line">    if (lastRet == -1)</span><br><span class="line"></span><br><span class="line">    throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">       checkForComodification();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">    AbstractList.this.remove(lastRet);</span><br><span class="line"></span><br><span class="line">    if (lastRet &lt; cursor)</span><br><span class="line"></span><br><span class="line">        cursor--;</span><br><span class="line"></span><br><span class="line">    lastRet = -1;</span><br><span class="line"></span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line"></span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作：<br><code>expectedModCount = modCount</code></p>
<blockquote>
<p>尽管iterator的remove操作也是调的list的fastRemove接口，但操作完后expectedModCount会保存modCount，这样就保证了expectedModCount正确反映了iterator修改list的次数</p>
</blockquote>
<h1 id="在多线程环境下的解决方法"><a href="#在多线程环境下的解决方法" class="headerlink" title="在多线程环境下的解决方法"></a>在多线程环境下的解决方法</h1><p>上面的解决办法在单线程环境下适用，但是在多线程下适用吗？看下面一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        list.add(1);</span><br><span class="line"></span><br><span class="line">        list.add(2);</span><br><span class="line"></span><br><span class="line">        list.add(3);</span><br><span class="line"></span><br><span class="line">        list.add(4);</span><br><span class="line"></span><br><span class="line">        list.add(5);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                    Integer integer = iterator.next();</span><br><span class="line"></span><br><span class="line">                    System.out.println(integer);</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line"></span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line"></span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread()&#123;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                    Integer integer = iterator.next();</span><br><span class="line"></span><br><span class="line">                    if(integer==2)</span><br><span class="line"></span><br><span class="line">                        iterator.remove();  </span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然会出现concurrentModificationException的问题！<br>原因很明显，由于iterator()方法每次都new一个Itr()，Itr是一个私有内部类，其内部<br><code>int expectedModCount = modCount;</code><br>modCount是 ArrayList中的，但是expectedModCount是内部变量，所以每个线程的expectedModCount都是不同的变量，虽然一开始值相同，但是<code>modCount是同一个，所以当有一个线程改变了modCount时，只有那个线程的expectedModCount和list的modCount对齐了</code>！另一个线程在调用checkForComodification()时，就会发生异常。</p>
<p>有可能有朋友说ArrayList是非线程安全的容器，换成Vector就没问题了，实际上换成Vector还是会出现这种错误。<br><code>因为原因并不在于是否方法是线程安全的，原因在于每个线程各自都有一个私有的Itr()</code>。</p>
<p>一般有2种解决办法：<br>1）在使用iterator迭代的时候使用synchronized或者Lock进行同步；（一个个迭代就和单线程一样了）<br>2）使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>HBase</title>
    <url>/2017/05/12/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/HBase/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>当数据积累越来越多，他们需要一个简单的方式来扩展整个系统而不是重新构建。</p>
</blockquote>
<p>从19世纪70年代开始，关系型数据库 （RDBMS）几乎统治了数据管理场景。</p>
<blockquote>
<p>但是当业务不断扩大，存储和处理的数据量也不断增长，关系型数据库越来越难以扩展。<br>假如你明白或者认为你要面对海量数据存储需求，有数十亿行及数百万列的情况，你应该考虑HBase。</p>
</blockquote>
<p>这类新数据库设计初衷就是在商业服务器集群中能够完成从基础建设到水平扩展阶段，而不需要垂直扩展设法去买更高级的机器（而且最终还是可能没法买到更好的机器）。</p>
<h2 id="初入HBase"><a href="#初入HBase" class="headerlink" title="初入HBase"></a>初入HBase</h2><p>HBase是一个能够提供实时、随机读写，能够存储数十亿行和数百万列的数据库。它设计是要运行于一个商业服务器的集群之上，当新服务器添加之后能够自动扩展，还能保证同样的性能。<br>有很高的容错性，因为数据是分割至服务器集群中，保存在一个冗余的文件系统比如HDFS。当某些服务器异常时，你的数据仍然是安全的。这些数据会在当前活动的服务器中自动均衡直到替换服务器上线。<br>HBase是高一致性的数据存储。你修改的内容能够马上在其他所有的客户前展示。</p>
<blockquote>
<p>HBase实质是一个带有自动数据版本控制的键值（key-value）存储。</p>
</blockquote>
<p>当在HBase中进行数据扫描时，数据行总是按照行主键（row key）顺序返回。</p>
<blockquote>
<p>每行数据都由一个唯一排序后的<code>行主键</code>（可以认为是关系型数据库的主键）和<code>任意数量的列</code>，每列都属于一个<code>列簇</code>（column family）并且包含<code>一个或多个版本的值</code>。值都是简单的<code>二进制数组</code>，根据应用需要可以转换成需要展示或存储的形式。</p>
</blockquote>
<p>总结</p>
<blockquote>
<p>HBase是非关系型、强一致性、自动数据版本控制的分布式键值数据库。</p>
</blockquote>
<h1 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h1><p>如何通过命令行使用HBase。<br>HBase自带基于JRuby开发的shell工具，能够定义和管理表、对数据执行增删改查操作、扫描表以及执行一些相关的维护。<br>HBase在产品环境中应该部署到服务器集群中，但也可以下载下来然后启动运行一个单机模式，只需要花几分钟时间。第一件要做的事情就是使用HBase的shell。下面的示例中演示了通过shell新建一个博客表、展示HBase中的有效表、添加一个博客实体、查询该实体以及扫描博客表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bin/hbase shell</span><br><span class="line">HBase Shell; enter &#x27;help&lt;RETURN&gt;&#x27; for list of supported commands.</span><br><span class="line">Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase Shell</span><br><span class="line">Version 0.96.0-hadoop2, r1531434, Fri Oct 11 15:28:08 PDT 2013</span><br><span class="line"> </span><br><span class="line">hbase(main):001:0&gt; create &#x27;blog&#x27;, &#x27;info&#x27;, &#x27;content&#x27;</span><br><span class="line">0 row(s) in 6.0670 seconds</span><br><span class="line"> </span><br><span class="line">=&gt; Hbase::Table - blog</span><br><span class="line"> </span><br><span class="line">hbase(main):002:0&gt; list</span><br><span class="line">TABLE</span><br><span class="line">blog</span><br><span class="line">fakenames</span><br><span class="line">my-table</span><br><span class="line">3 row(s) in 0.0300 seconds</span><br><span class="line"> </span><br><span class="line">=&gt; [&quot;blog&quot;, &quot;fakenames&quot;, &quot;my-table&quot;]</span><br><span class="line"> </span><br><span class="line">hbase(main):003:0&gt; put &#x27;blog&#x27;, &#x27;20130320162535&#x27;, &#x27;info:title&#x27;, &#x27;Why use HBase?&#x27;</span><br><span class="line">0 row(s) in 0.0650 seconds</span><br><span class="line"> </span><br><span class="line">hbase(main):004:0&gt; put &#x27;blog&#x27;, &#x27;20130320162535&#x27;, &#x27;info:author&#x27;, &#x27;Jane Doe&#x27;</span><br><span class="line">0 row(s) in 0.0230 seconds</span><br><span class="line"> </span><br><span class="line">hbase(main):005:0&gt; put &#x27;blog&#x27;, &#x27;20130320162535&#x27;, &#x27;info:category&#x27;, &#x27;Persistence&#x27;</span><br><span class="line">0 row(s) in 0.0230 seconds</span><br><span class="line"> </span><br><span class="line">hbase(main):006:0&gt; put &#x27;blog&#x27;, &#x27;20130320162535&#x27;, &#x27;content:&#x27;, &#x27;HBase is a column-oriented...&#x27;</span><br><span class="line">0 row(s) in 0.0220 seconds</span><br><span class="line"> </span><br><span class="line">hbase(main):007:0&gt; get &#x27;blog&#x27;, &#x27;20130320162535&#x27;</span><br><span class="line">COLUMN             CELL</span><br><span class="line"> content:          timestamp=1386556660599, value=HBase is a column-oriented...</span><br><span class="line"> info:author       timestamp=1386556649116, value=Jane Doe</span><br><span class="line"> info:category     timestamp=1386556655032, value=Persistence</span><br><span class="line"> info:title        timestamp=1386556643256, value=Why use HBase?</span><br><span class="line">4 row(s) in 0.0380 seconds</span><br><span class="line"> </span><br><span class="line">hbase(main):008:0&gt; scan &#x27;blog&#x27;, &#123; STARTROW =&gt; &#x27;20130300&#x27;, STOPROW =&gt; &#x27;20130400&#x27; &#125;</span><br><span class="line">ROW                COLUMN+CELL</span><br><span class="line"> 20130320162535    column=content:, timestamp=1386556660599, value=HBase is a column-oriented...</span><br><span class="line"> 20130320162535    column=info:author, timestamp=1386556649116, value=Jane Doe</span><br><span class="line"> 20130320162535    column=info:category, timestamp=1386556655032, value=Persistence</span><br><span class="line"> 20130320162535    column=info:title, timestamp=1386556643256, value=Why use HBase?</span><br><span class="line">1 row(s) in 0.0390 seconds</span><br></pre></td></tr></table></figure>

<p>上面的命令中，我们首先新建了一个包含列簇info 和 content的博客表。列出所有的表并且看到我们新建的博客表以后，我们向表中添加了一些数据。put命令指定了表名，唯一行主键，列簇的主键由列簇名和限定名（qualifier）组成，例如info是列簇名，而title和author就是限定名。所以，info:title就指向在列簇info中值为“Why use HBase?”的列title，info:title同样也被作为列主键。接下来，我们使用命令查询一行单独数据，并且最终在一个限定的行主键范围内扫描了博客表数据。指定了开始行20130300（包含）和结束行20130400 （不包含），和你预想的一样，我们能够查询到在此范围内的所有数据。上面博客的例子中，因为行主键就是发布的时间，所以实际上包含了所有2013三月份的数据。</p>
<p>HBase的一个重要特性就是，你定义了列簇，然后根据列限制名，可以再列簇中添加任意数量的列。<code>HBase优化了磁盘的列存储方式，不存在的列不会占用空间，这样使得存储更有效率。而关系型数据库缺必须保存一个空值（null）数据</code>。数据行是由包含的列组成的，所以如果行中没有任何列理论上它是不存在的。接着上面的列子，下面会从一个数据行中删除一些指定的列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hbase(main):009:0&gt;  delete &#x27;blog&#x27;, &#x27;20130320162535&#x27;, &#x27;info:category&#x27;</span><br><span class="line">0 row(s) in 0.0490 seconds</span><br><span class="line"> </span><br><span class="line">hbase(main):010:0&gt; get &#x27;blog&#x27;, &#x27;20130320162535&#x27;</span><br><span class="line">COLUMN             CELL</span><br><span class="line"> content:          timestamp=1386556660599, value=HBase is a column-oriented...</span><br><span class="line"> info:author       timestamp=1386556649116, value=Jane Doe</span><br><span class="line"> info:title        timestamp=1386556643256, value=Why use HBase?</span><br><span class="line">3 row(s) in 0.0260 seconds</span><br></pre></td></tr></table></figure>

<p>如上所示，你能够从表中删除一个指定列如info:category。你也可以使用deleteall命令删除一行中的所有列，从而删除这行数据。更新数据的话，只需要再次使用put命令即可。<code>HBase默认会保持单列三个版本的数据，所以假如你向 info:title put了一个新值，HBase会同时保留新旧两个值</code>。</p>
<p>上面例子中的命令展示了如何在HBase中增、删、改、查数据。数据查询只有两种方式：使用get命令查询单行数据；通过scan查询多行数据。<code>在HBase中查询数据时，你应当注意只查询你需要的信息</code>。由于HBase是从每个列簇中分别获取数据，如果你只需要一个列簇的数据，就能够指定只获取该部分。下面的例子中，我们只查询博客 title 列，指定行主键范围为2013年3月到4月。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hbase(main):011:0&gt; scan &#x27;blog&#x27;, &#123; STARTROW =&gt; &#x27;20130300&#x27;, STOPROW =&gt; &#x27;20130500&#x27;, COLUMNS =&gt; &#x27;info:title&#x27; &#125;</span><br><span class="line">ROW                COLUMN+CELL</span><br><span class="line"> 20130320162535    column=info:title, timestamp=1386556643256, value=Why use HBase?</span><br><span class="line">1 row(s) in 0.0290 seconds</span><br></pre></td></tr></table></figure>

<p>通过设置行主键范围、限制需要的列名称、需要查询的数据版本，你能够优化HBase的数据访问。当然上面的例子中，全都是通过shell完成的，你也能够使用HBase的API完成相同甚至更多的事情。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>HBase采用Master&#x2F;Slave架构搭建集群，它隶属于Hadoop生态系统，由一下类型节点组成：HMaster节点、HRegionServer节点、ZooKeeper集群，而在底层，它将数据存储于HDFS中，因而涉及到HDFS的NameNode、DataNode等</p>
<h2 id="HRegion"><a href="#HRegion" class="headerlink" title="HRegion"></a>HRegion</h2><p>HBase使用RowKey将表水平切割成多个HRegion，从HMaster的角度，每个HRegion都纪录了它的StartKey和EndKey（第一个HRegion的StartKey为空，最后一个HRegion的EndKey为空），由于RowKey是排序的，因而Client可以通过HMaster快速的定位每个RowKey在哪个HRegion中。</p>
<blockquote>
<p>HMaster对表中的数据按照RowKey分割成几部分，每一部分就是一个HRegion</p>
</blockquote>
<h2 id="HRegionServer"><a href="#HRegionServer" class="headerlink" title="HRegionServer"></a>HRegionServer</h2><p>HRegion由HMaster分配到相应的HRegionServer中，然后由HRegionServer负责HRegion的启动和管理，和Client的通信，负责数据的读(使用HDFS)。每个HRegionServer可以同时管理1000个左右的HRegion<br><img src="/images/HRegionServer.png"></p>
<h2 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h2><p>HMaster没有单点故障问题，可以启动多个HMaster，通过ZooKeeper的Master Election机制保证同时只有一个HMaster出于Active状态，其他的HMaster则处于热备份状态。</p>
<p>一般情况下会启动两个HMaster，非Active的HMaster会定期的和Active HMaster通信以获取其最新状态，从而保证它是实时更新的，如果启动了多个HMaster反而增加了Active HMaster的负担。</p>
<p>HMaster的主要用于HRegion的分配和管理，DDL的实现等，既它主要有两方面的职责：</p>
<ul>
<li>协调HRegionServer</li>
<li>启动时HRegion的分配，以及负载均衡和修复时HRegion的重新分配。</li>
<li>监控集群中所有HRegionServer的状态(通过Heartbeat和监听ZooKeeper中的状态)。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>HMaster相当于主控节点，负责分配HRegion以及管理HRegionMaster<br>HRegionMaster相当于存储节点，与Client打交道读取数据<br>HRegion相当于表中的一块数据区</p>
</blockquote>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>ZooKeeper为HBase集群提供协调服务，它管理着HMaster和HRegionServer的状态(available&#x2F;alive等)，并且会在它们宕机时通知给HMaster，从而HMaster可以实现HMaster之间的failover，或对宕机的HRegionServer中的HRegion集合的修复(将它们分配给其他的HRegionServer)。ZooKeeper集群本身使用一致性协议(PAXOS协议)保证每个节点状态的一致性。<br><img src="/images/HBaseArchitecture-Blog-Fig4.png"></p>
<p>ZooKeeper协调集群所有节点的共享信息，在HMaster和HRegionServer连接到ZooKeeper后创建Ephemeral节点，并使用Heartbeat机制维持这个节点的存活状态</p>
<p>HMaster通过监听ZooKeeper中的Ephemeral节点(默认：&#x2F;hbase&#x2F;rs&#x2F;*)来监控HRegionServer的加入和宕机，如果某个Ephemeral节点实效，则HMaster会收到通知，并做相应的处理。</p>
<p>第一个HMaster连接到ZooKeeper时会创建Ephemeral节点(默认：&#x2F;hbasae&#x2F;master)来表示Active的HMaster，其后加进来的HMaster则监听该Ephemeral节点，如果当前Active的HMaster宕机，则该节点消失，因而其他HMaster得到通知，而将自身转换成Active的HMaster，在变为Active的HMaster之前，它会创建在&#x2F;hbase&#x2F;back-masters&#x2F;下创建自己的Ephemeral节点。</p>
<blockquote>
<p>HMaster的备份节点会监听ACTIVE HMaster的Ephemeral节点，而ACTIVE HMaster会监听HRegionMaster的Ephemeral节点</p>
</blockquote>
<p><img src="/images/HBaseArchitecture-Blog-Fig5.png"></p>
<h1 id="HBase读写"><a href="#HBase读写" class="headerlink" title="HBase读写"></a>HBase读写</h1><h2 id="META-TABLE"><a href="#META-TABLE" class="headerlink" title="META TABLE"></a>META TABLE</h2><p>在HBase 0.96以后去掉了-ROOT- Table，只剩下这个特殊的目录表叫做Meta Table(hbase:meta)，它存储了集群中所有用户HRegion的位置信息，而ZooKeeper的节点中(&#x2F;hbase&#x2F;meta-region-server)存储的则直接是这个Meta Table的位置，并且这个Meta Table如以前的-ROOT- Table一样是不可split的。这样，客户端在第一次访问用户Table的流程就变成了：</p>
<p>1、从ZooKeeper(&#x2F;hbase&#x2F;meta-region-server)中获取hbase:meta的位置（HRegionServer的位置），缓存该位置信息。<br>2、从HRegionServer中查询用户Table对应请求的RowKey所在的HRegionServer，缓存该位置信息。<br>3、从查询到HRegionServer中读取Row。</p>
<blockquote>
<p>通过ZooKeeper找到META TABLE，META TABLE存储了用户TABLE和该TABLE所存储的节点HRegionServer的对应关系<br>通过META TABLE找到存储用户TABLE数据的HRegionServer，通过HRegionServer读写数据</p>
</blockquote>
<p><code>我感觉META TABLE就存在HMaster节点上，因为META TABLE存储的内容其实就是HMaster为用户TABLE记录分配的HRegionInfo</code></p>
<p><img src="/images/HBaseArchitecture-Blog-Fig7.png"></p>
<p>从这个过程中，我们发现客户会缓存这些位置信息，然而第二步它只是缓存当前RowKey对应的HRegion的位置，因而如果下一个要查的RowKey不在同一个HRegion中，则需要继续查询hbase:meta所在的HRegion，然而随着时间的推移，客户端缓存的位置信息越来越多，以至于不需要再次查找hbase:meta Table的信息，除非某个HRegion因为宕机或Split被移动，此时需要重新查询并且更新缓存。<br><img src="/images/HBaseArchitecture-Blog-Fig6.png"></p>
<h2 id="HRegionServer详解"><a href="#HRegionServer详解" class="headerlink" title="HRegionServer详解"></a>HRegionServer详解</h2><p>HRegionServer一般和DataNode在同一台机器上运行，实现数据的本地性。HRegionServer包含多个HRegion，由WAL(HLog)、BlockCache、MemStore、HFile组成</p>
<p>WAL：<br>WAL即Write Ahead Log，在早期版本中称为HLog，它是HDFS上的一个文件，如其名字所表示的，所有写操作都会先保证将数据写入这个Log文件后，才会真正更新MemStore，最后写入HFile中。</p>
<p>采用这种模式，可以保证HRegionServer宕机后，我们依然可以从该Log文件中读取数据，Replay所有的操作，而不至于数据丢失。这个Log文件会定期Roll出新的文件而删除旧的文件(那些已持久化到HFile中的Log可以删除)。</p>
<p>WAL文件存储在&#x2F;hbase&#x2F;WALs&#x2F;${HRegionServer_Name}的目录中(在0.94之前，存储在&#x2F;hbase&#x2F;.logs&#x2F;目录中)，一般一个HRegionServer只有一个WAL实例，也就是说一个HRegionServer的所有WAL写都是串行的(就像log4j的日志写也是串行的)，这当然会引起性能问题，因而在HBase 1.0之后，通过HBASE-5699实现了多个WAL并行写(MultiWAL)，该实现采用HDFS的多个管道写，以单个HRegion为单位。</p>
<blockquote>
<p>WAL的用处就是为了容灾，具体来说就是HRegionServer宕机后的数据恢复</p>
</blockquote>
<p>BlockCache：<br>BlockCache是一个读缓存，即“引用局部性”原理（也应用于CPU，分空间局部性和时间局部性，空间局部性是指CPU在某一时刻需要某个数据，那么有很大的概率在下一时刻它需要的数据在其附近；时间局部性是指某个数据在被访问过一次后，它有很大的概率在不久的将来会被再次的访问），将数据预读取到内存中，以提升读的性能。</p>
<p>HBase中提供两种BlockCache的实现：默认on-heap LruBlockCache和BucketCache(通常是off-heap)。通常BucketCache的性能要差于LruBlockCache，然而由于GC的影响，LruBlockCache的延迟会变的不稳定，而BucketCache由于是自己管理BlockCache，而不需要GC，因而它的延迟通常比较稳定，这也是有些时候需要选用BucketCache的原因。</p>
<blockquote>
<p>BlockCache作用是提升读数据的性能。注意，WAL和BlockCache都是服务于HRegionServer的，即服务于该Server上存储的所有HRegion数据</p>
</blockquote>
<p>HRegion：<br>HRegion是一个Table中的一个Region在一个HRegionServer中的表达。一个Table可以有一个或多个Region，他们可以在一个相同的HRegionServer上，也可以分布在不同的HRegionServer上，一个HRegionServer可以有多个HRegion，他们分别属于不同的Table。</p>
<p>HStore：<br>HRegion由多个Store(HStore)构成，每个HStore对应了一个Table在这个HRegion中的一个Column Family，即每个Column Family就是一个集中的存储单元，因而最好将具有相近IO特性的Column存储在一个Column Family，以实现高效读取(数据局部性原理，可以提高缓存的命中率)。HStore是HBase中存储的核心，它实现了读写HDFS功能，一个HStore由一个MemStore 和0个或多个StoreFile组成。</p>
<p>MemStore：<br>MemStore是一个写缓存(In Memory Sorted Buffer)，所有数据的写在完成WAL日志写后，会写入MemStore中，由MemStore根据一定的算法将数据Flush到底层HDFS文件中(HFile)，通常每个HRegion中的每个Column Family有一个自己的MemStore。</p>
<p>HFile：<br>HFile(StoreFile) 用于存储HBase的数据(Cell&#x2F;KeyValue)。在HFile中的数据是按RowKey、Column Family、Column排序，对相同的Cell(即这三个值都一样)，则按timestamp倒序排列。</p>
<blockquote>
<p>HStore是个逻辑概念，就如同HRegion一样，底层真正存储数据的是HFile，而MemStore负责将内存的数据flush到HFile<br>MemStore与HStore对应，表示col family列簇的数据，所以HRegion包含多个HStore，这样划分是为了提升IO性能</p>
</blockquote>
<p><img src="/images/HBaseArchitecture-Blog-Fig8.png"></p>
<h2 id="HRegionServer写数据"><a href="#HRegionServer写数据" class="headerlink" title="HRegionServer写数据"></a>HRegionServer写数据</h2><p>当客户端发起一个Put请求时，首先它从hbase:meta表中查出该Put数据最终需要去的HRegionServer。然后客户端将Put请求发送给相应的HRegionServer，在HRegionServer中它首先会将该Put操作写入WAL日志文件中(Flush到磁盘中)。<br><img src="/images/HBaseArchitecture-Blog-Fig9.png"></p>
<p>写完WAL日志文件后，HRegionServer根据Put中的TableName和RowKey找到对应的HRegion，并根据Column Family找到对应的HStore，并将Put写入到该HStore的MemStore中。此时写成功，并返回通知客户端。<br><img src="/images/HBaseArchitecture-Blog-Fig10.png"></p>
<p>MemStore是一个In Memory Sorted Buffer，在每个HStore中都有一个MemStore，即它是一个HRegion的一个Column Family对应一个实例。它的排列顺序以RowKey、Column Family、Column的顺序以及Timestamp的倒序，如下所示：<br><img src="/images/HBaseArchitecture-Blog-Fig11.png"></p>
<p>每一次Put&#x2F;Delete请求都是先写入到MemStore中，再Flush成一个新的StoreFile(底层实现是HFile)，即一个HStore(Column Family)可以有0个或多个StoreFile(HFile)。有以下三种情况可以触发MemStore的Flush动作，需要注意的是MemStore的最小Flush单元是HRegion而不是单个MemStore。</p>
<p>1、当一个HRegion中的所有MemStore的大小总和超过了hbase.hregion.memstore.flush.size的大小，默认128MB。此时当前的HRegion中所有的MemStore会Flush到HDFS中。</p>
<p>2、当全局MemStore的大小超过了hbase.regionserver.global.memstore.upperLimit的大小，默认40％的内存使用量。此时当前HRegionServer中所有HRegion中的MemStore都会Flush到HDFS中，Flush顺序是MemStore大小的倒序，直到总体的MemStore使用量低于hbase.regionserver.global.memstore.lowerLimit，默认38%的内存使用量。</p>
<blockquote>
<p>触发MemStore flush到HFile的条件，不是MemStore负载，而是HRegion或者HRegionServer设置的负载条件</p>
</blockquote>
<h1 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h1><p>我们使用HBase的Java API来建表，插入数据以及按照行主键查询数据。我们也会建立一个限制列范围的基本表查询，以及使用过滤器进行分页查询。</p>
<p>之前学习了HBase的整体架构，现在了解一下我们的应用如何通过Java API与HBase进行交互。如同之前提到的，你也同样可以通过其他的RPC（Remote Procedure Call）技术手段与HBase交互，比如Apache Thrift通过REST网关的方式，但我们主要使用Java API的方式。API提供了DDL（数据定义语言）和DML（数据操作语言）你会发现和关系型数据库SQL的语言很相似。假设我们要存储用户信息，我们先开始建立一张新表。下列代码展示如何使用HBaseAdmin类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">HBaseAdmin admin = new HBaseAdmin(conf);</span><br><span class="line">HTableDescriptor tableDescriptor = new HTableDescriptor(TableName.valueOf(&quot;people&quot;));</span><br><span class="line">tableDescriptor.addFamily(new HColumnDescriptor(&quot;personal&quot;));</span><br><span class="line">tableDescriptor.addFamily(new HColumnDescriptor(&quot;contactinfo&quot;));</span><br><span class="line">tableDescriptor.addFamily(new HColumnDescriptor(&quot;creditcard&quot;));</span><br><span class="line">admin.createTable(tableDescriptor);</span><br></pre></td></tr></table></figure>

<p>下面的代码展示了如何使用Put类插入John Doe的数据，指定名称和电子邮件指定（为了简单期间，这里忽略了通常应该有的错误处理）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">HTable table = new HTable(conf, &quot;people&quot;);</span><br><span class="line">Put put = new Put(Bytes.toBytes(&quot;doe-john-m-12345&quot;));</span><br><span class="line">put.add(Bytes.toBytes(&quot;personal&quot;), Bytes.toBytes(&quot;givenName&quot;), Bytes.toBytes(&quot;John&quot;));</span><br><span class="line">put.add(Bytes.toBytes(&quot;personal&quot;), Bytes.toBytes(&quot;mi&quot;), Bytes.toBytes(&quot;M&quot;));</span><br><span class="line">put.add(Bytes.toBytes(&quot;personal&quot;), Bytes.toBytes(&quot;surame&quot;), Bytes.toBytes(&quot;Doe&quot;));</span><br><span class="line">put.add(Bytes.toBytes(&quot;contactinfo&quot;), Bytes.toBytes(&quot;email&quot;), Bytes.toBytes(&quot;john.m.doe@gmail.com&quot;));</span><br><span class="line">table.put(put);</span><br><span class="line">table.flushCommits();</span><br><span class="line">table.close();</span><br></pre></td></tr></table></figure>

<p>上面的代码中示例是Put类提供了唯一行主键作为构造方法参数。接下来我们会添加值，必须包括列簇、列标识符、二进制数组形式的值。<br>或许你会注意到，HBase API的常用工具类中的Bytes类是经常用到的，它提供了一些方法能够在原始类型、字符串与二进制数组间转换。（添加一个toBytes()静态引用方法能够节省大堆代码）接下来我们将数据存入表中，刷新提交确认本地缓存的改变能够生效，最终关闭表。更新数据也和之前展示的代码方式相同。<br>与关系型数据库不同，HBase即使只有一列改变也必须更新整行数据。假如你只需要更新一列，只需要在Put类和HBase中指定需要更新的列。也会有确认并更新的动作，本质上就是一系列并发操作，只是在用户确认待替换的值之后才进行更新动作。</p>
<p>如下面的代码所示，使用Get类来查询我们刚刚创建完成的数据。（从这里开始，会忽略一些代码如构建配置，实例化HTable、提交及关闭）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get get = new Get(Bytes.toBytes(&quot;doe-john-m-12345&quot;));</span><br><span class="line">get.addFamily(Bytes.toBytes(&quot;personal&quot;));</span><br><span class="line">get.setMaxVersions(3);</span><br><span class="line">Result result = table.get(get);</span><br></pre></td></tr></table></figure>

<p>上面的代码中实例化了Get类，并且提供了待查询的行主键。接下来我们通过 addFamily 方法告知HBase：我们只需要从个人信息列簇中获取数据。这样能够减少HBase在读取数据时与磁盘的交互。我们还指定了结果中每列最多保存三个版本，这样就能列出每列的历史数据。最终会返回一个结果实例，包含所有可以查看的返回值列。</p>
<p>很多情况下你需要查询多行数据，HBase使用扫描行来实现。正如在第二篇在HBase的shell工具中执行scan，下面主要讨论Scan类。Scan类支持多种条件选项，比如待查询的行主键范围、需要包含的列和列簇、以及需要展示的最大数据版本。你也可以添加一个过滤器，通过自定义过滤逻辑限制需要返回哪些行和列。过滤器的常用场景就是分页，例如我们可能想要获取所有的姓Smith的人，每次一页25人。下面的代码展示了如何使用基本的scan方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scan scan = new Scan(Bytes.toBytes(&quot;smith-&quot;));</span><br><span class="line">scan.addColumn(Bytes.toBytes(&quot;personal&quot;), Bytes.toBytes(&quot;givenName&quot;));</span><br><span class="line">scan.addColumn(Bytes.toBytes(&quot;contactinfo&quot;), Bytes.toBytes(&quot;email&quot;));</span><br><span class="line">scan.setFilter(new PageFilter(25));</span><br><span class="line">ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">for (Result result : scanner) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap实现原理分析</title>
    <url>/2017/04/12/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h1><p>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。</p>
<p>数组<br>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</p>
<p>链表<br>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。</p>
<p>哈希表<br>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p>
<p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组”</p>
<p>哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16&#x3D;12,28%16&#x3D;12,108%16&#x3D;12,140%16&#x3D;12。所以12、28、108以及140都存储在数组下标为12的位置。</p>
<p>HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p>
<p>首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。<br><code>transient Entry[] table;</code></p>
<h1 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h1><p> 既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 存储时:</span><br><span class="line">int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure></p>
<p>1）put<br>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？<br>　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index&#x3D;0，记做:Entry[0] &#x3D; A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next &#x3D; A,Entry[0] &#x3D; B,如果又进来C,index也等于0,那么C.next &#x3D; B,Entry[0] &#x3D; C；这样我们发现index&#x3D;0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说<code>数组中存储的是最后插入的元素</code>。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return putForNullKey(value); //null总是放在数组的第一个链表中</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        //遍历链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            //如果key在链表中已存在，则替换为新value</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    //如果size超过threshold，则扩充table大小。再散列</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>
<p>2）get</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        //先定位到数组元素，再遍历该元素处的链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）null key的存取<br><code>null key总是存放在Entry[]数组的第一个元素</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">            if (e.key == null) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private V getForNullKey() &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">            if (e.key == null)</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4）确定数组index：hashcode % table.length取模<br>HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns index for hash code h.</span><br><span class="line">    */</span><br><span class="line">   static int indexFor(int h, int length) &#123;</span><br><span class="line">       return h &amp; (length-1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>按位与，作用上相当于取模mod或者取余%。<br>这意味着数组下标相同，并不表示hashCode相同。</p>
<p> 5）table初始大小<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">      .....</span><br><span class="line">      // Find a power of 2 &gt;= initialCapacity</span><br><span class="line">      int capacity = 1;</span><br><span class="line">      while (capacity &lt; initialCapacity)</span><br><span class="line">          capacity &lt;&lt;= 1;</span><br><span class="line">      this.loadFactor = loadFactor;</span><br><span class="line">      threshold = (int)(capacity * loadFactor);</span><br><span class="line">      table = new Entry[capacity];</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>注意table初始大小并不是构造函数中的initialCapacity！而是 &gt;= initialCapacity的2的n次幂！</code></p>
<p>————为什么这么设计呢？——</p>
<h1 id="解决hash冲突的办法"><a href="#解决hash冲突的办法" class="headerlink" title="解决hash冲突的办法"></a>解决hash冲突的办法</h1><p>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）<br>再哈希法<br><code>链地址法</code><br>建立一个公共溢出区<br>Java中hashmap的解决办法就是采用的链地址法。</p>
<h1 id="再散列rehash过程"><a href="#再散列rehash过程" class="headerlink" title="再散列rehash过程"></a>再散列rehash过程</h1><p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span><br><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            src[j] = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                //重新计算index</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK8中的HashMap实现"><a href="#JDK8中的HashMap实现" class="headerlink" title="JDK8中的HashMap实现"></a>JDK8中的HashMap实现</h1><p>一直到JDK7为止，HashMap的结构都是这么简单，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。</p>
<p>这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。再最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。</p>
<p><code>JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而JDK8中采用的是位桶+链表/红黑树（有关红黑树请查看红黑树）的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树</code>。</p>
<p>JDK8中，当同一个hash值的节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树（上图中null节点没画）。这就是JDK7与JDK8中HashMap实现的最大区别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">	Node&lt;K,V&gt; p; </span><br><span class="line">	int n, i;</span><br><span class="line">	//如果当前map中无数据，执行resize方法。并且返回n</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">	 //如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上就完事了</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">	//否则的话，说明这上面有元素</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">	    //如果这个元素的key与要插入的一样，那么就替换一下，也完事。</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">	    //1.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">		//还是遍历这条链子上的数据，跟jdk7没什么区别</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">			//2.完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null) //true || --</span><br><span class="line">                    e.value = value;</span><br><span class="line">		   //3.</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">	//判断阈值，决定是否扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">	    //4.</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</code><br>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p>
<p><code>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</code><br>一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，<code>HashMap是在bucket中储存键对象和值对象，作为Map.Entry</code>。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p>
<p><code>“当两个对象的hashcode相同会发生什么？” </code><br>从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p>
<p><code>“如果两个键的hashcode相同，你如何获取值对象？”</code><br>面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案：将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。<br>其中一些记得这个重要知识点的面试者会说，<code>找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象</code>。完美的答案！<br>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。<br>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。</p>
<p><code>“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”</code><br>除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。<code>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置</code>。<br>如果你能够回答这道问题，下面的问题来了：</p>
<p><code>“你了解重新调整HashMap大小存在什么问题吗？”</code><br>你可能回答不上来，这时面试官会提醒你当<code>多线程的情况下，可能产生条件竞争(race condition)</code>。<br>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。<code>在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了</code>。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p>
<p>热心的读者贡献了更多的关于HashMap的问题：<br>为什么String, Interger这样的wrapper类适合作为键？ <code>String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了</code>。其他的wrapper类也有这个特点。<code>不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象</code>。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。<br>我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。<code>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁</code>。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>Hive</title>
    <url>/2017/05/13/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/Hive/</url>
    <content><![CDATA[<h1 id="认识Hive"><a href="#认识Hive" class="headerlink" title="认识Hive"></a>认识Hive</h1><p>首先我们要知道hive到底是做什么的。下面这几段文字很好的描述了hive的特性：<br>1、hive是基于Hadoop的一个<code>数据仓库工具</code>，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。
　　</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>下面我来讲讲hive的技术架构，大家先看下面的架构图：<br><img src="/images/hive-structure.png"></p>
<p>Hive架构包括如下组件：CLI（command line interface）、JDBC&#x2F;ODBC、Thrift Server、WEB GUI、metastore和Driver(Complier、Optimizer和Executor)，这些组件我可以分为两大类：服务端组件和客户端组件。</p>
<p>首先讲讲服务端组件：<br><code>Driver组件</code>：该组件包括Complier、Optimizer和Executor，它的作用是将我们写的HiveQL（类SQL）语句进行解析、编译优化，生成执行计划，然后调用底层的mapreduce计算框架。</p>
<p><code>Metastore组件</code>：元数据服务组件，Hive 将元数据存储在数据库中，如 mysql、derby。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。元数据对于hive十分重要，因此hive支持把metastore服务独立出来，安装到远程的服务器集群里，从而解耦hive服务和metastore服务，保证hive运行的健壮性</p>
<p><code>Thrift服务</code>：thrift是facebook开发的一个软件框架，它用来进行可扩展且跨语言的服务的开发，hive集成了该服务，能让不同的编程语言调用hive的接口。</p>
<p>客户端组件：<br><code>CLI</code>：command line interface，命令行接口。</p>
<p><code>Thrift客户端</code>：上面的架构图里没有写上Thrift客户端，但是hive架构的许多客户端接口是建立在thrift客户端之上，包括JDBC和ODBC接口。</p>
<p><code>WEBGUI</code>：hive客户端提供了一种通过网页的方式访问hive所提供的服务。这个接口对应hive的hwi组件（hive web interface），使用前要启动hwi服务。</p>
<p>Hive的执行流程如下图所示：<br><img src="/images/hive-workline.png"></p>
<h2 id="Hive基本操作"><a href="#Hive基本操作" class="headerlink" title="Hive基本操作"></a>Hive基本操作</h2><p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; CREATE TABLE pokes (foo INT, bar STRING); </span><br><span class="line">        Creates a table called pokes with two columns, the first being an integer and the other a string</span><br></pre></td></tr></table></figure>

<p>创建一个新表，结构与其他一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; create table new_table like records;</span><br></pre></td></tr></table></figure>

<p>创建分区表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; create table logs(ts bigint,line string) partitioned by (dt String,country String);</span><br></pre></td></tr></table></figure>

<p>加载分区表数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; load data local inpath &#x27;/home/hadoop/input/hive/partitions/file1&#x27; into table logs partition (dt=&#x27;2001-01-01&#x27;,country=&#x27;GB&#x27;);</span><br></pre></td></tr></table></figure>

<p>展示表中有多少分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; show partitions logs;</span><br></pre></td></tr></table></figure>

<p>展示所有表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; SHOW TABLES;</span><br><span class="line">        lists all the tables</span><br><span class="line">hive&gt; SHOW TABLES &#x27;.*s&#x27;;</span><br><span class="line">lists all the table that end with &#x27;s&#x27;. </span><br></pre></td></tr></table></figure>

<p>显示表的结构信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; DESCRIBE invites;</span><br><span class="line">        shows the list of columns</span><br></pre></td></tr></table></figure>

<p>更新表的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; ALTER TABLE source RENAME TO target;</span><br></pre></td></tr></table></figure>

<p>添加新一列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; ALTER TABLE invites ADD COLUMNS (new_col2 INT COMMENT &#x27;a comment&#x27;);</span><br></pre></td></tr></table></figure>

<p>删除表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; DROP TABLE records;</span><br></pre></td></tr></table></figure>

<p>删除表中数据，但要保持表的结构定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; dfs -rmr /user/hive/warehouse/records;</span><br></pre></td></tr></table></figure>

<p>从本地文件加载数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; LOAD DATA LOCAL INPATH &#x27;/home/hadoop/input/ncdc/micro-tab/sample.txt&#x27; OVERWRITE INTO TABLE records;</span><br></pre></td></tr></table></figure>

<p>显示所有函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; show functions;</span><br></pre></td></tr></table></figure>

<p>查看函数用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; describe function substr;</span><br></pre></td></tr></table></figure>

<p>查看数组、map、结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; select col1[0],col2[&#x27;b&#x27;],col3.c from complex;</span><br></pre></td></tr></table></figure>

<p>内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; SELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</span><br></pre></td></tr></table></figure>

<p>查看hive为某个查询使用多少个MapReduce作业</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; Explain SELECT sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</span><br></pre></td></tr></table></figure>

<p>外连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; SELECT sales.*, things.* FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);</span><br><span class="line">hive&gt; SELECT sales.*, things.* FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);</span><br><span class="line">hive&gt; SELECT sales.*, things.* FROM sales FULL OUTER JOIN things ON (sales.id = things.id);</span><br></pre></td></tr></table></figure>

<p>in查询：Hive不支持，但可以使用LEFT SEMI JOIN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; SELECT * FROM things LEFT SEMI JOIN sales ON (sales.id = things.id);</span><br></pre></td></tr></table></figure>

<p>Map连接：Hive可以把较小的表放入每个Mapper的内存来执行连接操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; SELECT /*+ MAPJOIN(things) */ sales.*, things.* FROM sales JOIN things ON (sales.id = things.id);</span><br><span class="line">INSERT OVERWRITE TABLE ..SELECT：新表预先存在</span><br><span class="line">hive&gt; FROM records2</span><br><span class="line">    &gt; INSERT OVERWRITE TABLE stations_by_year SELECT year, COUNT(DISTINCT station) GROUP BY year </span><br><span class="line">    &gt; INSERT OVERWRITE TABLE records_by_year SELECT year, COUNT(1) GROUP BY year</span><br><span class="line">    &gt; INSERT OVERWRITE TABLE good_records_by_year SELECT year, COUNT(1) WHERE temperature != 9999 AND (quality = 0 OR quality = 1 OR quality = 4 OR quality = 5 OR quality = 9) GROUP BY year;  </span><br><span class="line"></span><br><span class="line">CREATE TABLE ... AS SELECT：新表表预先不存在</span><br><span class="line">hive&gt;CREATE TABLE target AS SELECT col1,col2 FROM source;</span><br></pre></td></tr></table></figure>

<p>创建视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature !=9999;</span><br></pre></td></tr></table></figure>

<p>查看视图详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hive&gt; DESCRIBE EXTENDED valid_records;</span><br></pre></td></tr></table></figure>

<h2 id="与关系数据库的区别"><a href="#与关系数据库的区别" class="headerlink" title="与关系数据库的区别"></a>与关系数据库的区别</h2><p>使用hive的命令行接口，感觉很像操作关系数据库，但是hive和关系数据库还是有很大的不同，下面我就比较下hive与关系数据库的区别，具体如下：<br>1、hive和关系数据库存储文件的系统不同，hive使用的是hadoop的HDFS（hadoop的分布式文件系统），关系数据库则是服务器本地的文件系统；</p>
<p>2、hive使用的计算模型是mapreduce，而关系数据库则是自己设计的计算模型；</p>
<p>3、关系数据库都是为实时查询的业务进行设计的，而hive则是为海量数据做数据挖掘设计的，实时性很差；实时性的区别导致hive的应用场景和关系数据库有很大的不同；<br>想象你在操作RMDB数据库，如果是全表扫描，就用Hive+Hadoop,如果是索引访问，就用HBase+Hadoop 。</p>
<p>4、Hive本身不存储和计算数据，它完全依赖于HDFS和MapReduce，Hive中的表纯逻辑。<br>hbase是物理表，不是逻辑表，提供一个超大的内存hash表，搜索引擎通过它来存储索引，方便查询操作。</p>
<p>5、Hive很容易扩展自己的存储能力和计算能力，这个是继承hadoop的，而关系数据库在这个方面要比数据库差很多。</p>
<p>6、关系数据库里，表的加载模式（数据库存储数据的文件格式）是在数据加载时候强制确定的，如果加载数据时候发现加载的数据不符合模式，关系数据库则会拒绝加载数据，这个就叫“写时模式”，写时模式会在数据加载时候对数据模式进行检查校验的操作。</p>
<p>Hive在加载数据时候和关系数据库不同，<code>hive在加载数据时候不会对数据进行检查，也不会更改被加载的数据文件，而检查数据格式的操作是在查询操作时候执行，这种模式叫“读时模式”</code>。在实际应用中，写时模式在加载（写）数据时候会对列进行索引，对数据进行压缩，因此加载数据的速度很慢，但是当数据加载好了，我们去查询数据的时候，速度很快。但是当我们的数据是非结构化，存储模式也是未知时候，关系数据操作这种场景就麻烦多了，这时候hive就会发挥它的优势。</p>
<p>7、关系数据库一个重要的特点是可以对某一行或某些行的数据进行更新、删除操作，<code>hive不支持对某个具体行的操作，hive对数据的操作只支持覆盖原数据和追加数据。Hive也不支持事务和索引</code>。更新、事务和索引都是关系数据库的特征，这些hive都不支持，也不打算支持，原因是hive的设计是海量数据进行处理，全数据的扫描是常态，针对某些具体数据进行操作的效率是很差的，<code>对于更新操作，hive是通过查询将原表的数据进行转化最后存储在新表里</code>，这和传统数据库的更新操作有很大不同。</p>
<p>8、Hive也可以在hadoop做实时查询上做一份自己的贡献，那就是和hbase集成，hbase可以进行快速查询，但是hbase不支持类SQL的语句，那么此时hive可以给hbase提供sql语法解析的外壳，可以<code>用类sql语句操作hbase数据库</code>。</p>
<h2 id="Hive数据类型"><a href="#Hive数据类型" class="headerlink" title="Hive数据类型"></a>Hive数据类型</h2><p>Hive支持两种数据类型，一类叫原子数据类型，一类叫复杂数据类型。</p>
<p>原子数据类型包括数值型、布尔型和字符串类型（和JAVA基本数据类型一一对应）<br><code>hive不支持日期类型，在hive里日期都是用字符串来表示的，而常用的日期格式转化操作则是通过自定义函数进行操作</code>。</p>
<p>复杂数据类型包括数组（ARRAY）、映射（MAP）和结构体（STRUCT）</p>
<p>下面我们看看hive使用复杂数据类型的实例，建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table complex(col1 ARRAY&lt;INT&gt;,</span><br><span class="line">Col2 MAP&lt;STRING,INT&gt;,</span><br><span class="line">Col3 STRUCT&lt;a:STRING,b :INT,c:DOUBLE&gt;);</span><br></pre></td></tr></table></figure>

<h2 id="Hive数据模型"><a href="#Hive数据模型" class="headerlink" title="Hive数据模型"></a>Hive数据模型</h2><p>hive的数据模型包括：database、table、partition和bucket。</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>Hive中的表和关系型数据库中的表在概念上很类似，<code>每个表在HDFS中都有相应的目录用来存储表的数据</code>，这个目录可以通过${HIVE_HOME}&#x2F;conf&#x2F;hive-site.xml配置文件中的 hive.metastore.warehouse.dir属性来配置，这个属性默认的值是&#x2F;user&#x2F;hive&#x2F;warehouse(这个目录在 HDFS上)，我们可以根据实际的情况来修改这个配置。</p>
<p>如果我有一个表wyp，那么在HDFS中会创建&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;wyp 目录(这里假定hive.metastore.warehouse.dir配置为&#x2F;user&#x2F;hive&#x2F;warehouse)；wyp表所有的数据都存放在这个目录中。</p>
<h3 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h3><p>Hive中的外部表和表很类似，但是其<code>数据不是放在自己表所属的目录中，而是存放到别处，这样的好处是如果你要删除这个外部表，该外部表所指向的数据是不会被删除的，它只会删除外部表对应的元数据</code>；而如果你要删除表，该表对应的所有数据包括元数据都会被删除。</p>
<p>下面是创建表的实例语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table tuoguan_tbl (flied string);</span><br><span class="line">Load data local inpath ‘home/hadoop/test.txt’ into table tuoguan_tbl;</span><br></pre></td></tr></table></figure>

<p>外部表创建的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create external table external_tbl (flied string)</span><br><span class="line">    Location  ‘/home/hadoop/external_table’;</span><br><span class="line">Load data local inpath ‘home/hadoop/test.txt’ into table external_tbl;</span><br></pre></td></tr></table></figure>

<p>hive加载数据时候不会对元数据进行任何检查，只是简单的移动文件的位置，如果源文件格式不正确，也只有在做查询操作时候才能发现，那个时候错误格式的字段会以NULL来显示。</p>
<h3 id="分区（partition）"><a href="#分区（partition）" class="headerlink" title="分区（partition）"></a>分区（partition）</h3><p>hive里分区的概念是根据“分区列”的值对表的数据进行粗略划分的机制，<code>在hive存储上就体现在表的主目录（hive的表实际显示就是一个文件夹）下的一个子目录，这个文件夹的名字就是我们定义的分区列的名字，分区列不是表里的某个字段，而是独立的列，我们根据这个列存储表的里的数据文件。使用分区是为了加快数据分区的查询速度而设计的，我们在查询某个具体分区列里的数据时候没必要进行全表扫描</code>。</p>
<p>创建分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create table logs(ts bigint,line string)</span><br><span class="line">Partitioned by (dt string,country string);</span><br></pre></td></tr></table></figure>

<p>加载数据：<br><code>Load data local inpath ‘/home/hadoop/par/file01.txt’ into table logs partition (dt=’2012-06-02’,country=’cn’);</code></p>
<p>在hive数据仓库里实际存储的路径如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/user/hive/warehouse/logs/dt=2013-06-02/country=cn/file1.txt</span><br><span class="line">/user/hive/warehouse/logs/dt=2013-06-02/country=cn/file2.txt</span><br><span class="line">/user/hive/warehouse/logs/dt=2013-06-02/country=us/file3.txt</span><br><span class="line">/user/hive/warehouse/logs/dt=2013-06-02/country=us/file4.txt</span><br></pre></td></tr></table></figure>

<p>我们看到在表logs的目录下有了两层子目录dt&#x3D;2013-06-02和country&#x3D;cn<br>查询操作：<br><code>Select ts,dt,line  from logs where country=’cn’</code></p>
<p>这个时候我们的查询操作只会扫描file1.txt和file2.txt文件。</p>
<h3 id="桶（bucket）"><a href="#桶（bucket）" class="headerlink" title="桶（bucket）"></a>桶（bucket）</h3><p>上面的table和partition都是目录级别的拆分数据，bucket则是<code>对数据源数据文件本身来拆分数据</code>。使用桶的表会将源数据文件按一定规律拆分成多个文件，要使用bucket，我们首先要打开hive对桶的控制，命令如下：<br><code>set hive.enforce.bucketing = true</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">建临时表student_tmp，并导入数据：</span><br><span class="line">hive&gt; desc student_tmp;         </span><br><span class="line">OK</span><br><span class="line">id      int</span><br><span class="line">age     int</span><br><span class="line">name    string</span><br><span class="line">stat_date       string</span><br><span class="line">Time taken: 0.106 seconds</span><br><span class="line">hive&gt; select * from student_tmp;</span><br><span class="line">OK</span><br><span class="line">1       20      zxm     20120801</span><br><span class="line">2       21      ljz     20120801</span><br><span class="line">3       19      cds     20120801</span><br><span class="line">4       18      mac     20120801</span><br><span class="line">5       22      android 20120801</span><br><span class="line">6       23      symbian 20120801</span><br><span class="line">7       25      wp      20120801</span><br><span class="line">Time taken: 0.123 seconds</span><br><span class="line"> </span><br><span class="line">建student表：</span><br><span class="line">hive&gt;create table student(id INT, age INT, name STRING)</span><br><span class="line">       &gt;partitioned by(stat_date STRING) </span><br><span class="line">       &gt;clustered by(id) sorted by(age) into 2 bucket</span><br><span class="line">       &gt;row format delimited fields terminated by &#x27;,&#x27;;</span><br><span class="line"> </span><br><span class="line">设置环境变量：</span><br><span class="line">       &gt;set hive.enforce.bucketing = true; </span><br><span class="line"> </span><br><span class="line">插入数据：</span><br><span class="line">       &gt;from student_tmp </span><br><span class="line">       &gt;insert overwrite table student partition(stat_date=&quot;20120802&quot;) </span><br><span class="line">       &gt;select id,age,name where stat_date=&quot;20120801&quot; sort by age;</span><br><span class="line"> </span><br><span class="line">查看文件目录：</span><br><span class="line">$ hadoop fs -ls /user/hive/warehouse/studentstat_date=20120802/</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   1 work supergroup         31 2012-07-31 19:52 /user/hive/warehouse/student/stat_date=20120802/000000_0</span><br><span class="line">-rw-r--r--   1 work supergroup         39 2012-07-31 19:52 /user/hive/warehouse/student/stat_date=20120802/000001_0</span><br></pre></td></tr></table></figure>

<p>桶文件是按指定字段（cluster字段）值进行hash，然后取余桶的个数例如上面例子2</p>
<p>桶运用的场景有限，一个是做map连接的运算，我在后面的文章里会讲到，一个就是取样操作了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看sampling数据：</span><br><span class="line">hive&gt; select * from student tablesample(bucket 1 out of 2 on id);                                                                               </span><br><span class="line">Total MapReduce jobs = 1</span><br><span class="line">Launching Job 1 out of 1</span><br><span class="line">.......</span><br><span class="line">OK</span><br><span class="line">4       18      mac     20120802</span><br><span class="line">2       21      ljz     20120802</span><br><span class="line">6       23      symbian 20120802</span><br><span class="line">Time taken: 20.608 seconds</span><br></pre></td></tr></table></figure>

<p>tablesample是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y)<br>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例。例如，table总共分了64份，当y&#x3D;32时，抽取 (64&#x2F;32&#x3D;)2个bucket的数据，当y&#x3D;128时，抽取(64&#x2F;128&#x3D;)1&#x2F;2个bucket的数据。x表示从哪个bucket开始抽取。例如，table总bucket数为32，tablesample(bucket 3 out of 16)，表示总共抽取（32&#x2F;16&#x3D;）2个bucket的数据，分别为第3个bucket和第（3+16&#x3D;）19个bucket的数据。</p>
<h2 id="Hive的数据存储"><a href="#Hive的数据存储" class="headerlink" title="Hive的数据存储"></a>Hive的数据存储</h2><p>首先，Hive 没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由的组织 Hive 中的表，只需要在创建表的时候告诉 Hive 数据中的列分隔符和行分隔符，Hive 就可以解析数据。</p>
<p>其次，Hive 中所有的数据都存储在 HDFS 中，Hive 中包含以下数据模型：Table，External Table，Partition，Bucket。</p>
<p>1、Hive 中的 Table 和数据库中的 Table 在概念上是类似的，每一个 Table 在 Hive 中都有一个相应的目录存储数据。例如，一个表 pvs，它在 HDFS 中的路径为：&#x2F;wh&#x2F;pvs，其中，wh 是在 hive-site.xml 中由 ${hive.metastore.warehouse.dir} 指定的数据仓库的目录，所有的 Table 数据（不包括 External Table）都保存在这个目录中。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Hive中的日志分为两种<br>1、系统日志，记录了hive的运行情况，错误状况。<br>2、Job 日志，记录了Hive中job的执行的历史过程。</p>
<p>系统日志存储在什么地方呢 ？<br>在hive&#x2F;conf&#x2F; hive-log4j.properties 文件中记录了Hive日志的存储情况</p>
<p>默认的存储情况：<br>hive.root.logger&#x3D;WARN,DRFA<br>hive.log.dir&#x3D;&#x2F;tmp&#x2F;${user.name} # 默认的存储位置<br>hive.log.file&#x3D;hive.log  # 默认的文件名</p>
<p>Job日志又存储在什么地方呢 ？<br>&#x2F;&#x2F;Location of Hive run time structured log file<br>HIVEHISTORYFILELOC(“hive.querylog.location”, “&#x2F;tmp&#x2F;“ + System.getProperty(“user.name”)),<br>默认存储与 &#x2F;tmp&#x2F;{user.name}目录下。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>JDNI是什么</title>
    <url>/2017/04/14/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/JDNI%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>JNDI是 Java 命名与目录接口（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一，不少专家认为，没有透彻理解JNDI的意义和作用，就没有真正掌握J2EE特别是EJB的知识。<br>那么，JNDI到底起什么作用？</p>
<p>要了解JNDI的作用，我们可以从“如果不用JNDI我们怎样做？用了JNDI后我们又将怎样做？”这个问题来探讨。</p>
<p>没有JNDI的做法：<br>程序员开发时，知道要开发访问MySQL数据库的应用，于是将一个对 MySQL JDBC 驱动程序类的引用进行了编码，并通过使用适当的 JDBC URL 连接到数据库。<br>就像以下代码这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection conn=null;</span><br><span class="line">try &#123;</span><br><span class="line">  Class.forName(&quot;com.mysql.jdbc.Driver&quot;,</span><br><span class="line">                true, Thread.currentThread().getContextClassLoader());</span><br><span class="line">  conn=DriverManager.getConnection(&quot;jdbc:mysql://MyDBServer?user=qingfeng&amp;password=mingyue&quot;);</span><br><span class="line">  /* 使用conn并进行SQL操作 */</span><br><span class="line">  ......</span><br><span class="line">  conn.close();</span><br><span class="line">&#125; </span><br><span class="line">catch(Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">  if(conn!=null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      conn.close();</span><br><span class="line">    &#125; catch(SQLException e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是传统的做法，也是以前非Java程序员（如Delphi、VB等）常见的做法。这种做法一般在小规模的开发过程中不会产生问题，只要程序员熟悉Java语言、了解JDBC技术和MySQL，可以很快开发出相应的应用程序。</p>
<p>没有JNDI的做法存在的问题：<br>1、数据库服务器名称MyDBServer 、用户名和口令都可能需要改变，由此引发JDBC URL需要修改；<br>2、数据库可能改用别的产品，如改用DB2或者Oracle，引发JDBC驱动程序包和类名需要修改；<br>3、随着实际使用终端的增加，原配置的连接池参数可能需要调整；<br>4、……</p>
<p>解决办法：<br>程序员应该不需要关心“具体的数据库后台是什么？JDBC驱动程序是什么？JDBC URL格式是什么？访问数据库的用户名和口令是什么？”等等这些问题，程序员编写的程序应该没有对 JDBC 驱动程序的引用，没有服务器名称，没有用户名称或口令 —— 甚至没有数据库池或连接管理。</p>
<blockquote>
<p>把这些问题交给<code>J2EE容器</code>来配置和管理，程序员只需要对这些配置和管理进行引用即可。</p>
</blockquote>
<p>由此，就有了JNDI。</p>
<p>用了JNDI之后的做法：<br>首先，在在J2EE容器中配置JNDI参数，定义一个数据源，也就是JDBC引用参数，给这个数据源设置一个名称；然后，在程序中，通过数据源名称引用数据源从而访问后台数据库。</p>
<p>具体操作如下（以JBoss为例）：<br>1、配置数据源<br>在JBoss的 D:&#x2F;jboss420GA&#x2F;docs&#x2F;examples&#x2F;jca 文件夹下面，有很多不同数据库引用的数据源定义模板。将其中的 mysql-ds.xml 文件Copy到你使用的服务器下，如 D:&#x2F;jboss420GA&#x2F;server&#x2F;default&#x2F;deploy。<br>修改 mysql-ds.xml 文件的内容，使之能通过JDBC正确访问你的MySQL数据库，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;datasources&gt;</span><br><span class="line">&lt;local-tx-datasource&gt;</span><br><span class="line">    &lt;jndi-name&gt;MySqlDS&lt;/jndi-name&gt;</span><br><span class="line">    &lt;connection-url&gt;jdbc:mysql://localhost:3306/lw&lt;/connection-url&gt;</span><br><span class="line">    &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt;</span><br><span class="line">    &lt;user-name&gt;root&lt;/user-name&gt;</span><br><span class="line">    &lt;password&gt;rootpassword&lt;/password&gt;</span><br><span class="line">&lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter&lt;/exception-sorter-class-name&gt;</span><br><span class="line">    &lt;metadata&gt;</span><br><span class="line">       &lt;type-mapping&gt;mySQL&lt;/type-mapping&gt;</span><br><span class="line">    &lt;/metadata&gt;</span><br><span class="line">&lt;/local-tx-datasource&gt;</span><br><span class="line">&lt;/datasources&gt;</span><br></pre></td></tr></table></figure>

<p>这里，定义了一个名为MySqlDS的数据源，其参数包括JDBC的URL，驱动类名，用户名及密码等。</p>
<p>2、在程序中引用数据源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection conn=null;</span><br><span class="line">try &#123;</span><br><span class="line">  Context ctx=new InitialContext();</span><br><span class="line">  Object datasourceRef=ctx.lookup(&quot;java:MySqlDS&quot;); //引用数据源</span><br><span class="line">  DataSource ds=(Datasource)datasourceRef;</span><br><span class="line">  conn=ds.getConnection();</span><br><span class="line">  /* 使用conn进行数据库SQL操作 */</span><br><span class="line">  ......</span><br><span class="line">  c.close();</span><br><span class="line">&#125; </span><br><span class="line">catch(Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">  if(conn!=null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      conn.close();</span><br><span class="line">    &#125; catch(SQLException e) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用JDBC或者通过JNDI引用数据源的编程代码量相差无几，但是现在的程序可以不用关心具体JDBC参数了。<br>在系统部署后，如果数据库的相关参数变更，只需要重新配置 mysql-ds.xml 修改其中的JDBC参数，只要保证数据源的名称不变，那么程序源代码就无需修改。</p>
<p>由此可见，JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署。</p>
<p>JNDI的扩展：<br>JNDI在满足了数据源配置的要求的基础上，还进一步扩充了作用：所有与系统外部的资源的引用，都可以通过JNDI定义和引用。</p>
<p>所以，在J2EE规范中，J2EE 中的资源并不局限于 JDBC 数据源。引用的类型有很多，其中包括资源引用（已经讨论过）、环境实体和 EJB 引用。特别是 EJB 引用，它暴露了 JNDI 在 J2EE 中的另外一项关键角色：查找其他应用程序组件。</p>
<p>EJB 的 JNDI 引用非常类似于 JDBC 资源的引用。在服务趋于转换的环境中，这是一种很有效的方法。可以对应用程序架构中所得到的所有组件进行这类配置管理，从 EJB 组件到 JMS 队列和主题，再到简单配置字符串或其他对象，这可以降低随时间的推移服务变更所产生的维护成本，同时还可以简化部署，减少集成工作。</p>
<p>总结：<br>J2EE 规范要求所有 J2EE 容器都要提供 JNDI 规范的实现。JNDI 在 J2EE 中的角色就是“交换机” —— J2EE 组件在运行时间接地查找其他组件、资源或服务的通用机制。在多数情况下，提供 JNDI 供应者的容器可以充当有限的数据存储，这样管理员就可以设置应用程序的执行属性，并让其他应用程序引用这些属性（Java 管理扩展（Java Management Extensions，JMX）也可以用作这个目的）。JNDI 在 J2EE 应用程序中的主要角色就是提供间接层，这样组件就可以发现所需要的资源，而不用了解这些间接性。</p>
<p>在 J2EE 中，JNDI 是把 J2EE 应用程序合在一起的粘合剂，JNDI 提供的间接寻址允许跨企业交付可伸缩的、功能强大且很灵活的应用程序。这是 J2EE 的承诺，而且经过一些计划和预先考虑，这个承诺是完全可以实现的</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA SOCKET</title>
    <url>/2017/04/23/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/JAVA%20SOCKET/</url>
    <content><![CDATA[<h1 id="Socket的由来"><a href="#Socket的由来" class="headerlink" title="Socket的由来"></a>Socket的由来</h1><p>Unix的输入输出(IO)系统遵循Open-Read-Write-Close这样的操作范本。当一个用户进程进行IO操作之前，它需要调用Open来指定并获取待操作文件或设备读取或写入的权限。一旦IO操作对象被打开，那么这个用户进程可以对这个对象进行一次或多次的读取或写入操作。Read操作用来从IO操作对象读取数据，并将数据传递给用户进程。Write操作用来将用户进程中的数据传递（写入）到IO操作对象。 当所有的Read和Write操作结束之后，用户进程需要调用Close来通知系统其完成对IO对象的使用。</p>
<p><code>在Unix开始支持进程间通信（InterProcess Communication，简称IPC）时，IPC的接口就设计得类似文件IO操作接口</code>。在Unix中，一个进程会有一套可以进行读取写入的IO描述符。IO描述符可以是文件，设备或者是通信通道（socket套接字）。一个文件描述符由三部分组成：创建（打开socket），读取写入数据（接受和发送到socket）还有销毁（关闭socket）。</p>
<blockquote>
<p>Socket可以认为是IPC（进程间通信）接口定义的进程的IO描述符。通俗的说，Socket是用于进程间通信的IO。</p>
</blockquote>
<p>在Unix系统中，类BSD版本的<code>IPC接口是作为TCP和UDP协议之上的一层进行实现的</code>。消息的目的地使用socket地址来表示。一个socket地址是由网络地址和端口号组成的通信标识符。</p>
<p>进程间通信操作需要一对儿socket。进程间通信通过在一个进程中的一个socket与另一个进程中得另一个socket进行数据传输来完成。当一个消息执行发出后，这个消息在发送端的socket中处于排队状态，直到下层的网络协议将这些消息发送出去。当消息到达接收端的socket后，其也会处于排队状态，直到接收端的进程对这条消息进行了接收处理。</p>
<h1 id="TCP和UDP通信"><a href="#TCP和UDP通信" class="headerlink" title="TCP和UDP通信"></a>TCP和UDP通信</h1><p>关于socket编程我们有两种通信协议可以进行选择。一种是数据报通信，另一种就是流通信。</p>
<h2 id="数据报通信"><a href="#数据报通信" class="headerlink" title="数据报通信"></a>数据报通信</h2><p>数据报通信协议，就是我们常说的UDP（User Data Protocol 用户数据报协议）。UDP是一种无连接的协议，这就意味着我们每次发送数据报时，<code>需要同时发送本机的socket描述符和接收端的socket描述符</code>。因此，我们在每次通信时都需要发送额外的数据。</p>
<h2 id="流通信"><a href="#流通信" class="headerlink" title="流通信"></a>流通信</h2><p>流通信协议，也叫做TCP(Transfer Control Protocol，传输控制协议)。和UDP不同，TCP是一种基于连接的协议。在使用流通信之前，我们必须在通信的一对儿socket之间建立连接。其中一个socket作为服务器进行监听连接请求。另一个则作为客户端进行连接请求。一旦两个socket建立好了连接，他们可以单向或双向进行数据传输。</p>
<p>读到这里，我们多少有这样的疑问，我们进行socket编程使用UDP还是TCP呢。选择基于何种协议的socket编程取决于你的具体的客户端-服务器端程序的应用场景。下面我们简单分析一下TCP和UDP协议的区别，或许可以帮助你更好地选择使用哪种。<br>1、在UDP中，每次发送数据报时，需要附带上本机的socket描述符和接收端的socket描述符。而由于TCP是基于连接的协议，在通信的socket对之间需要在通信之前建立连接，因此会有建立连接这一耗时存在于TCP协议的socket编程。<br>2、<code>在UDP中，数据报数据在大小上有64KB的限制。而TCP中也不存在这样的限制</code>。一旦TCP通信的socket对建立了连接，他们之间的通信就类似IO流，所有的数据会按照接受时的顺序读取。<br>3、<code>UDP是一种不可靠的协议，发送的数据报不一定会按照其发送顺序被接收端的socket接受</code>。然后TCP是一种可靠的协议。接收端收到的包的顺序和包在发送端的顺序是一致的。</p>
<p>简而言之，TCP适合于诸如远程登录(rlogin,telnet)和文件传输（FTP）这类的网络服务。因为这些需要传输的数据的大小不确定。而UDP相比TCP更加简单轻量一些。UDP用来实现实时性较高或者丢包不重要的一些服务。在局域网中UDP的丢包率都相对比较低。</p>
<h1 id="TCP套接字的生命周期"><a href="#TCP套接字的生命周期" class="headerlink" title="TCP套接字的生命周期"></a>TCP套接字的生命周期</h1><blockquote>
<p>新的Socket实例创建后，就立即能用于发送和接收数据。也就是说，当Socket实例返回时，它已经连接到了一个远程终端，并通过协议的底层实现完成了TCP消息或握手信息的交换</p>
</blockquote>
<h2 id="客户端连接的建立"><a href="#客户端连接的建立" class="headerlink" title="客户端连接的建立"></a>客户端连接的建立</h2><p>Socket构造函数的调用与客户端连接建立时所关联的协议事件之间的关系下图所示<br><img src="/images/20131114102114890.png"></p>
<p>当客户端以服务器端的互联网地址W.X.Y.Z和端口号Q作为参数，调用Socket的构造函数时，底层实现将创建一个套接字实例，该实例的初始状态是关闭的。<br>TCP开放握手也称为3次握手，这通常包括3条消息：</p>
<blockquote>
<p>一条从客户端到服务端的连接请求，一条从服务端到客户端的确认消息，以及另一条从客户端到服务端的确认消息。</p>
</blockquote>
<p><code>对客户端而言，一旦它收到了服务端发来的确认消息，就立即认为连接已经建立</code>。通常这个过程发生的很快，但连接请求消息或服务端的回复消息都有可能在传输过程中丢失，因此TCP协议实现将以递增的时间间隔重复发送几次握手消息。如果TCP客户端在一段时间后还没有收到服务端的回复消息，则发生超时并放弃连接。如果服务端并没有接收连接，则服务端的TCP将发送一条拒绝消息而不是确认消息。</p>
<h2 id="服务端连接的建立"><a href="#服务端连接的建立" class="headerlink" title="服务端连接的建立"></a>服务端连接的建立</h2><p>与客户端的事件序列则有所不同。服务端首先创建一个ServerSocket实例，并将其与已知端口相关联（在此为Q），套接字实现为新的ServerSocket实例创建一个底层数据结构，并就Q赋给本地端口，<code>并将特定的通配符（*）赋给本地IP地址（服务器可能有多个IP地址，不过通常不会指定该参数）</code>，如下图所示：<br><img src="/images/20131114103956484"></p>
<p>现在服务端可以调用ServerSocket的accept（）方法，来将阻塞等待客户端连接请求的到来。当客户端的连接请求到来时，将为连接创建一个新的套接字数据结构。该套接字的地址根据到来的分组报文设置：分组报文的目标互联网地址和端口号成为该套接字的本地互联网地址和端口号；而分组报文的源地址和端口号则成为改套接字的远程互联网地址和端口号。注意，新套接字的本地端口号总是与ServerSocket的端口号一致。除了要创建一个新的底层套接字数据结构外，服务端的TCP实现还要向客户端发送一个TCP握手确认消息。如下图所示：<br><img src="/images/20131114104647406"></p>
<p>但是，<code>对于服务端来说，在接收到客户端发来的第3条消息之前，服务端TCP并不会认为握手消息已经完成</code>。一旦收到客户端发来的第3条消息，则表示连接已建立，此时一个新的数据结构将从服务端所关联的列表中移除，并为创建一个Socket实例，作为accept（）方法的返回值。如下图所示：<br><img src="/images/20131114105515281"></p>
<blockquote>
<p>这里有非常重要的一点需要注意，在ServerSocket关联的列表中的每个数据结构，都代表了一个与另一端的客户端已经完成建立的TCP连接。<code>实际上，客户只要收到了开放握手的第2条消息，就可以立即发送数据——这可能比服务端调用accept（）方法为其获取一个Socket实例要早很长时间</code>。</p>
</blockquote>
<h2 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h2><p>TCP协议有一个优雅的关闭机制，以保证应用程序在关闭时不必担心正在传输的数据会丢失，这个机制还可以设计为<code>允许两个方向的数据传输相互独立地终止</code>。</p>
<p>关闭机制的工作流程是：<br>应用程序通过调用连接套接字的close（）方法或shutdownOutput（）方法表明数据已经发送完毕。底层TCP实现首先将留在SendQ队列中的数据传输出去（这还要依赖于另一端的RecvQ队列的剩余空间），然后向另一端发送一个关闭TCP连接的握手消息。该关闭握手消息可以看做流结束的标志：它告诉接收端TCP不会再有新的数据传入RecvQ队列了。注意：<code>关闭握手消息本身并没有传递给接收端应用程序，而是通过read（）方法返回-1来指示其在字节流中的位置</code>。而正在关闭的TCP将等待其关闭握手消息的确认消息，该确认消息表明在连接上传输的所有数据已经安全地传输到了RecvQ中。只要收到了确认消息，该连接变成了<code>“半关闭”</code>状态。<br><code>直到连接的另一个方向上收到了对称的握手消息后，连接才完全关闭——也就是说，连接的两端都表明它们没有数据发送了</code>。</p>
<p>TCP连接的关闭事件序列可能以两种方式发生：<br>一种方式是先由一个应用程序调用close（）方法或shutdownOutput方法，并在另一端调用close（）方法之前完成其关闭握手消息；<br>另一种方式是两端同时调用close（）方法，他们的关闭握手消息在网络上交叉传输。<br>下图展示了以第一种方式关闭连接时，发起关闭的一端底层实现中的事件序列：<br><img src="/images/20131114132921140"></p>
<blockquote>
<p>注意，如果连接处于半关闭状态时，远程终端已经离开，那么本地底层数据结构则无限期地保持在该状态。当另一端的关闭握手消息到达后，则发回一条确认消息并将状态改为“Time—Wait”。<code>虽然应用程序中相应的Socket实例可能早已消失，与之关联的底层数据结构还将在底层实现中继续存留几分钟</code></p>
</blockquote>
<p>对于没有首先发起关闭的一端，关闭握手消息达到后，它立即发回一个确认消息，并将连接状态改为“Close—Wait”。<code>此时，只需要等待应用程序调用Socket的close（）方法。调用该方法后，将发起最终的关闭消息 ，并释放底层套接字数据结构</code>。 下图展示了没有首先发起关闭的一端底层实现中的事件序列：<br><img src="/images/20131114134838328"></p>
<blockquote>
<p>注意这样一个事实：close（）方法和shutdownOutput（）方法都没有等待关闭握手的完成，而是调用后立即返回，这样，<code>当应用程序调用close（）方法或shutdownOutput（）方法并成功关闭连接时，有可能还有数据留在SendQ队列中。如果连接的任何一端在数据传输到RecvQ队列之前崩溃，数据将丢失，而发送端应用程序却不会知道</code>。</p>
</blockquote>
<p> 最好的解决方案是设计一种应用程序协议，以使首先调用close（）方法的一方在接收到了应用程序的数据已接收保证后，才真正执行关闭操作。例如，<code>客户端程序确认其接收到的字节数与其发送的字节数相等后，它就能够知道此时在连接的两个方向上都没有数据在传输，因此可以安全地关闭连接</code>。</p>
<p> 关闭TCP连接的最后微妙之处在于对Time—Wait状态的需要。TCP规范要求在终止连接时，两端的关闭握手都完成后，至少要有一个套接字在Time—Wait状态保持一段时间。这个要求的提出是由于消息在网络中传输时可能延迟。如果在连接两端都完成了关闭握手后，它们都移除了其底层数据结构，而此时在同样一对套接字地址之间又建立了新的连接，那么前一个连接在网络上传输时延迟的消息就可能在新建立的连接后到达。由于包含了相同的源地址和目的地址，<code>旧消息就会被错误地认为是属于新连接的</code>，其包含的数据就可能被错误地分配到应用程序中。虽然这种情况很少发生，TCP还是使用了包括Time—Write状态在内的多种机制对其进行防范。</p>
<p>Time—Wait状态最重要的作用是：</p>
<blockquote>
<p>只要底层套接字数据结构还存在，就不允许在相同的本地端口上关联其他套接字，尤其试图使用该端口创建新的Socket实例时，将抛出IOException异常。</p>
</blockquote>
<h1 id="Socket数据传输的底层实现"><a href="#Socket数据传输的底层实现" class="headerlink" title="Socket数据传输的底层实现"></a>Socket数据传输的底层实现</h1><p>由于TCP提供了一种可信赖的字节流服务，<code>任何写入Socket和OutputStream的数据副本都必须保留，直到连接的另一端将这些数据成功接收</code>。向输出流写数据并不意味着数据实际上已经被发送——它们只是被复制到了本地缓冲区，就算在Socket的OutputStream上进行flush（）操作，也不能保证数据能够立即发送到信道</p>
<p>在使用TCP套接字时，需要记住的最重要的一点是：<code>不能假设在连接的一端将数据写入输出流和在另一端从输入流读出数据之间有任何的一致性</code>。尤其是在发送端由单个输出流的write（）方法传输的数据，可能会通过另一端的多个输入流的read（）方法获取，而一个read（）方法可能会返回多个write（）方法传输的数据。</p>
<p>一般来讲，我们可以认为TCP连接上发送的所有字节序列在某一瞬间被分成了3个FIFO队列：<br>1、SendQ：在发送端底层实现中缓存的字节，这些字节已经写入输出流，但还没在接收端成功接收。它占用大约37KB内存。<br>2、RecvQ：在接收端底层实现中缓存的字节，这些字节等待分配到接收程序——即从输入流中读取。它占用大约25KB内存。<br>3、Delivered：接收者从输入流已经读取到的字节。</p>
<p>当我们调用OutputStream的write（）方法时，将向SendQ追加字节。</p>
<p>TCP协议负责将字节按顺序从SendQ移动到RecvQ。这里有重要的一点需要明确：<code>这个转移过程无法由用户程序控制或直接观察到，并且在块中发生，这些块的大小在一定程度上独立于传递给write（）方法的缓冲区大小</code>。</p>
<p>接收程序从Socket的InputStream读取数据时，字节就从RecvQ移动到Delivered中，而转移的块的大小依赖于RecvQ中的数据量和传递给read（）方法的缓冲区的大小。</p>
<h1 id="TCP通信中由于底层队列填满而造成的死锁问题"><a href="#TCP通信中由于底层队列填满而造成的死锁问题" class="headerlink" title="TCP通信中由于底层队列填满而造成的死锁问题"></a>TCP通信中由于底层队列填满而造成的死锁问题</h1><blockquote>
<p>造成死锁产生的原因是因为客户端在发送数据的同时，没有及时读取反馈回来的数据，从而使数据都阻塞在了底层的传输队列中</p>
</blockquote>
<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"> </span><br><span class="line">public class CompressClientNoDeadlock &#123;</span><br><span class="line"> </span><br><span class="line">  public static final int BUFSIZE = 256;  // Size of read buffer</span><br><span class="line"> </span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">    if (args.length != 3)  // Test for correct #  of args</span><br><span class="line">      throw new IllegalArgumentException(&quot;Parameter(s): &lt;Server&gt; &lt;Port&gt; &lt;File&gt;&quot;);</span><br><span class="line"> </span><br><span class="line">    String server = args[0];               // Server name or IP address</span><br><span class="line">    int port = Integer.parseInt(args[1]);  // Server port</span><br><span class="line">    String filename = args[2];             // File to read data from</span><br><span class="line"> </span><br><span class="line">    // Open input and output file (named input.gz)</span><br><span class="line">    final FileInputStream fileIn = new FileInputStream(filename);</span><br><span class="line">    FileOutputStream fileOut = new FileOutputStream(filename + &quot;.gz&quot;);</span><br><span class="line"> </span><br><span class="line">    // Create socket connected to server on specified port</span><br><span class="line">    final Socket sock = new Socket(server, port);</span><br><span class="line"> </span><br><span class="line">    // Send uncompressed byte stream to server</span><br><span class="line">    Thread thread = new Thread() &#123;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          SendBytes(sock, fileIn);</span><br><span class="line">        &#125; catch (Exception ignored) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line"> </span><br><span class="line">    // Receive compressed byte stream from server</span><br><span class="line">    InputStream sockIn = sock.getInputStream();</span><br><span class="line">    int bytesRead;                      // Number of bytes read</span><br><span class="line">    byte[] buffer = new byte[BUFSIZE];  // Byte buffer</span><br><span class="line">    while ((bytesRead = sockIn.read(buffer)) != -1) &#123;</span><br><span class="line">      fileOut.write(buffer, 0, bytesRead);</span><br><span class="line">      System.out.print(&quot;R&quot;);   // Reading progress indicator</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();      // End progress indicator line</span><br><span class="line"> </span><br><span class="line">    sock.close();     // Close the socket and its streams</span><br><span class="line">    fileIn.close();   // Close file streams</span><br><span class="line">    fileOut.close();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public static void SendBytes(Socket sock, InputStream fileIn)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">    OutputStream sockOut = sock.getOutputStream();</span><br><span class="line">    int bytesRead;                      // Number of bytes read</span><br><span class="line">    byte[] buffer = new byte[BUFSIZE];  // Byte buffer</span><br><span class="line">    while ((bytesRead = fileIn.read(buffer)) != -1) &#123;</span><br><span class="line">      sockOut.write(buffer, 0, bytesRead);</span><br><span class="line">      System.out.print(&quot;W&quot;);   // Writing progress indicator</span><br><span class="line">    &#125;</span><br><span class="line">    sock.shutdownOutput();     // Done sending</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对该示例而言，当需要传递的文件容量不是很大时，程序运行正常，也能得到预期的结果，但如果尝试运行该客户端并传递给它一个大文件，改文件压缩后仍然很大（在此，大的精确定义取决于程序运行的系统，不过压缩后依然超过2MB的文件应该就可以使改程序产生死锁问题），那么客户端将打印出一堆W后停止，而且不会打印出任何R，程序也不会终止。</p>
<p>为什么会产生这种情况呢？我们来看程序，客户端很明显是一边读取本地文件中的数据，一边调用输出流的write（）方法，将数据送入客户端主机的SendQ队列，直到文件中的数据被读取完，客户端才调用输入流的read（）方法，读取服务端发送回来的数据。</p>
<p>考虑这种情况：客户端和服务端的SendQ队列和RecvQ队列中都有500字节的数据空间，而客户端发送了一个10000字节的文件，同时假设对于这个文件，服务端读取1000字节并返回500字节，即压缩比为2:1，当客户端发送了2000字节后，服务端将最终全部读取这些字节，并发回1000字节，由于客户端此时并没有调用输入流的read（）方法从客户端主机的RecvQ队列中移出数据到Delivered，因此，此时客户端的RecvQ队列和服务端的SendQ队列都被填满了，此时客户端还在继续发送数据，又发送了1000字节的数据，并且被服务端全部读取，但此时服务端的write操作尝试都已被阻塞，不能继续发送数据给客户端，当客户端再发送了另外的1000字节数据后，客户端的SendQ队列和服务端的RecvQ队列都将被填满，后续的客户端write操作也将阻塞，从而形成死锁。</p>
<p>解决方案：<br>方案一是在编写客户端程序时，使客户端一边循环调用输出流的read（）方法向服务端发送数据，一边循环调用输入流的read（）方法读取从服务端反馈回来的数据，但这也不能完全保证不会产生死锁。</p>
<p>更好的解决方案是在不同的线程中执行客户端的write循环和read循环。一个线程从文件中反复读取未压缩的字节并将其发送给服务器，直到文件的结尾，然后调用该套接字的shutdownOutput（）方法。另一个线程从服务端的输入流中不断读取压缩后的字节，并将其写入输出文件，直到到达了输入流的结尾（服务器关闭了套接字）。这样，便可以实现一边发送，一边读取，而且如果一个线程阻塞了，另一个线程仍然可以独立执行。这样我们可以对客户端代码进行简单的修改，将SendByes（）方法调用放到一个线程中</p>
<p>当然，解决这个问题也可以不使用多线程，而是使用NIO机制（Channel和Selector）。</p>
<h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><h2 id="端口选择"><a href="#端口选择" class="headerlink" title="端口选择"></a>端口选择</h2><p>在选择端口时，需要注意一点，就是0~1023这些端口都已经被系统预留了。这些端口为一些常用的服务所使用，比如邮件，FTP和HTTP。当你在编写服务器端的代码，选择端口时，<code>请选择一个大于1023的端口</code>。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>客户端向服务器端发送连接请求后，就被动地等待服务器的响应。典型的TCP客户端要经过下面三步操作：<br>1、创建一个Socket实例：构造函数向指定的远程主机和端口建立一个TCP连接；<br>2、通过套接字的I&#x2F;O流与服务端通信；<br>3、使用Socket类的close方法关闭连接。</p>
<p>服务端的工作是建立一个通信终端，并被动地等待客户端的连接。典型的TCP服务端执行如下两步操作：<br>1、创建一个ServerSocket实例并指定本地端口，用来监听客户端在该端口发送的TCP连接请求；<br>2、重复执行：<br>1）调用ServerSocket的accept（）方法以获取客户端连接，并通过其返回值创建一个Socket实例；<br>2）为返回的Socket实例开启新的线程，并使用返回的Socket实例的I&#x2F;O流与客户端通信；<br>3）通信完成后，使用Socket类的close（）方法关闭该客户端的套接字连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String host = &quot;127.0.0.1&quot;;</span><br><span class="line">        int port = 8919;</span><br><span class="line">        try &#123;</span><br><span class="line">          Socket client = new Socket(host, port);</span><br><span class="line">          Writer writer = new OutputStreamWriter(client.getOutputStream());</span><br><span class="line">          writer.write(&quot;Hello From Client&quot;);</span><br><span class="line">          writer.flush();</span><br><span class="line">          writer.close();</span><br><span class="line">          client.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            ServerSocket server = new ServerSocket(port);</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">            Reader reader = new InputStreamReader(socket.getInputStream());</span><br><span class="line">            char chars[] = new char[1024];</span><br><span class="line">            int len;</span><br><span class="line">            StringBuilder builder = new StringBuilder();</span><br><span class="line">            while ((len=reader.read(chars)) != -1) &#123;</span><br><span class="line">               builder.append(new String(chars, 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Receive from client message=: &quot; + builder);</span><br><span class="line">            reader.close();</span><br><span class="line">            socket.close();</span><br><span class="line">            server.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>Java通过<code>DatagramPacket</code>类和<code>DatagramSocket</code>类来使用UDP套接字，客户端和服务器端都通过DatagramSocket的send（）方法和receive（）方法来发送和接收数据，用DatagramPacket来包装需要发送或者接收到的数据。<br>发送信息时，Java创建一个包含待发送信息的DatagramPacket实例，并将其作为参数传递给DatagramSocket实例的send（）方法；接收信息时，Java程序首先创建一个DatagramPacket实例，该实例预先分配了一些空间，并将接收到的信息存放在该空间中，然后把该实例作为参数传递给DatagramSocket实例的receive（）方法。</p>
<blockquote>
<p>在创建DatagramPacket实例时，要注意：如果该实例用来包装待接收的数据，则不指定数据来源的远程主机和端口，只需指定一个缓存数据的byte数组即可（在调用receive（）方法接收到数据后，源地址和端口等信息会自动包含在DatagramPacket实例中），而如果该实例用来包装待发送的数据，则要指定要发送到的目的主机和端口。</p>
</blockquote>
<p>通信步骤：<br>UDP客户端首先向被动等待联系的服务器发送一个数据报文。一个典型的UDP客户端要经过下面三步操作：<br>1、创建一个DatagramSocket实例，可以有选择地对本地地址和端口号进行设置，如果设置了端口号，则客户端会在该端口号上监听从服务器端发送来的数据；<br>2、使用DatagramSocket实例的send（）和receive（）方法来发送和接收DatagramPacket实例，进行通信；<br>3、通信完成后，调用DatagramSocket实例的close（）方法来关闭该套接字。</p>
<p>由于UDP是无连接的，因此UDP服务端不需要等待客户端的请求以建立连接。另外，UDP服务器为所有通信使用同一套接字，这点与TCP服务器不同，TCP服务器则为每个成功返回的accept()方法创建一个新的套接字。一个典型的UDP服务端要经过下面三步操作：<br>1、创建一个DatagramSocket实例，指定本地端口号，并可以有选择地指定本地地址，此时，服务器已经准备好从任何客户端接收数据报文；<br>2、使用DatagramSocket实例的receive（）方法接收一个DatagramPacket实例，当receive（）方法返回时，数据报文就包含了客户端的地址，这样就知道了回复信息应该发送到什么地方；<br>3、使用DatagramSocket实例的send（）方法向服务器端返回DatagramPacket实例。</p>
<p>UDP程序在receive()方法处阻塞，直到收到一个数据报文或等待超时。由于UDP协议是不可靠协议，如果数据报在传输过程中发生丢失，那么程序将会一直阻塞在receive()方法处，这样客户端将永远都接收不到服务器端发送回来的数据，但是又没有任何提示。为了避免这个问题，我们在客户端使用DatagramSocket类的setSoTimeout()方法来制定receive()方法的最长阻塞时间，并指定重发数据报的次数，如果每次阻塞都超时，并且重发次数达到了设置的上限，则关闭客户端。</p>
<p>客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int TIMEOUT = 5000;  //设置接收数据的超时时间</span><br><span class="line">    private static final int MAXNUM = 5;      //设置重发数据的最多次数</span><br><span class="line">    public static void main(String args[])throws IOException&#123;</span><br><span class="line">        String str_send = &quot;Hello UDPserver&quot;;</span><br><span class="line">        byte[] buf = new byte[1024];</span><br><span class="line">        //客户端在9000端口监听接收到的数据</span><br><span class="line">        DatagramSocket ds = new DatagramSocket(9000);</span><br><span class="line">        InetAddress loc = InetAddress.getLocalHost();</span><br><span class="line">        //定义用来发送数据的DatagramPacket实例</span><br><span class="line">        DatagramPacket dp_send= new DatagramPacket(str_send.getBytes(),str_send.length(),loc,3000);</span><br><span class="line">        //定义用来接收数据的DatagramPacket实例</span><br><span class="line">        DatagramPacket dp_receive = new DatagramPacket(buf, 1024);</span><br><span class="line">        //数据发向本地3000端口</span><br><span class="line">        ds.setSoTimeout(TIMEOUT);              //设置接收数据时阻塞的最长时间</span><br><span class="line">        int tries = 0;                         //重发数据的次数</span><br><span class="line">        boolean receivedResponse = false;     //是否接收到数据的标志位</span><br><span class="line">        //直到接收到数据，或者重发次数达到预定值，则退出循环</span><br><span class="line">        while(!receivedResponse &amp;&amp; tries&lt;MAXNUM)&#123;</span><br><span class="line">            //发送数据</span><br><span class="line">            ds.send(dp_send);</span><br><span class="line">            try&#123;</span><br><span class="line">                //接收从服务端发送回来的数据</span><br><span class="line">                ds.receive(dp_receive);</span><br><span class="line">                //如果接收到的数据不是来自目标地址，则抛出异常</span><br><span class="line">                if(!dp_receive.getAddress().equals(loc))&#123;</span><br><span class="line">                    throw new IOException(&quot;Received packet from an umknown source&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                //如果接收到数据。则将receivedResponse标志位改为true，从而退出循环</span><br><span class="line">                receivedResponse = true;</span><br><span class="line">            &#125;catch(InterruptedIOException e)&#123;</span><br><span class="line">                //如果接收数据时阻塞超时，重发并减少一次重发的次数</span><br><span class="line">                tries += 1;</span><br><span class="line">                System.out.println(&quot;Time out,&quot; + (MAXNUM - tries) + &quot; more tries...&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(receivedResponse)&#123;</span><br><span class="line">            //如果收到数据，则打印出来</span><br><span class="line">            System.out.println(&quot;client received data from server：&quot;);</span><br><span class="line">            String str_receive = new String(dp_receive.getData(),0,dp_receive.getLength()) + </span><br><span class="line">                    &quot; from &quot; + dp_receive.getAddress().getHostAddress() + &quot;:&quot; + dp_receive.getPort();</span><br><span class="line">            System.out.println(str_receive);</span><br><span class="line">            //由于dp_receive在接收了数据之后，其内部消息长度值会变为实际接收的消息的字节数，</span><br><span class="line">            //所以这里要将dp_receive的内部消息长度重新置为1024</span><br><span class="line">            dp_receive.setLength(1024);   </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果重发MAXNUM次数据后，仍未获得服务器发送回来的数据，则打印如下信息</span><br><span class="line">            System.out.println(&quot;No response -- give up.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br></pre></td></tr></table></figure>

<p>服务器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str_send = &quot;Hello UDPclient&quot;;</span><br><span class="line">        byte[] buf = new byte[1024];</span><br><span class="line">        //服务端在3000端口监听接收到的数据</span><br><span class="line">        DatagramSocket ds = new DatagramSocket(3000);</span><br><span class="line">        //接收从客户端发送过来的数据</span><br><span class="line">        DatagramPacket dp_receive = new DatagramPacket(buf, 1024);</span><br><span class="line">        System.out.println(&quot;server is on，waiting for client to send data......&quot;);</span><br><span class="line">        boolean f = true;</span><br><span class="line">        while(f)&#123;</span><br><span class="line">            //服务器端接收来自客户端的数据</span><br><span class="line">            ds.receive(dp_receive);</span><br><span class="line">            System.out.println(&quot;server received data from client：&quot;);</span><br><span class="line">            String str_receive = new String(dp_receive.getData(),0,dp_receive.getLength()) + </span><br><span class="line">                    &quot; from &quot; + dp_receive.getAddress().getHostAddress() + &quot;:&quot; + dp_receive.getPort();</span><br><span class="line">            System.out.println(str_receive);</span><br><span class="line">            //数据发动到客户端的3000端口</span><br><span class="line">            DatagramPacket dp_send= new DatagramPacket(str_send.getBytes(),str_send.length(),dp_receive.getAddress(),9000);</span><br><span class="line">            ds.send(dp_send);</span><br><span class="line">            //由于dp_receive在接收了数据之后，其内部消息长度值会变为实际接收的消息的字节数，</span><br><span class="line">            //所以这里要将dp_receive的内部消息长度重新置为1024</span><br><span class="line">            dp_receive.setLength(1024);</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br></pre></td></tr></table></figure>

<h2 id="TCP与UDP编程的区别"><a href="#TCP与UDP编程的区别" class="headerlink" title="TCP与UDP编程的区别"></a>TCP与UDP编程的区别</h2><p>1、UDP套接字和TCP套接字的一个微小但重要的差别：UDP协议保留了消息的边界信息。<br>DatagramSocket的每一次receive()调用最多只能接收调用一次send()方法所发送的数据，而且，<code>不同的receive()方法调用绝对不会返回同一个send()方法所发送的数据</code>。</p>
<p>当在TCP套接字的输出流上调用write（）方法返回后，所有调用者都知道数据已经被复制到一个传输缓存区中，实际上此时数据可能已经被发送，也有可能还没有被传送，而UDP协议没有提供从网络错误中恢复的机制，因此，并不对可能需要重传的数据进行缓存。这就意味着，<code>当send（）方法调用返回时，消息已经被发送到了底层的传输信道中</code>。</p>
<p>2、UDP数据报文所能负载的最多数据，亦及一次传送的最大数据为65507个字节（64K）<br>当消息从网络中到达后，其所包含的数据被TCP的read（）方法或UDP的receive（）方法返回前，数据存储在一个先进先出的接收数据队列中。对于已经建立连接的TCP套接字来说，所有已接受但还未传送的字节都看作是一个连续的字节序列。然而，对于UDP套接字来说，接收到的数据可能来自不同的发送者，一个UDP套接字所接受的数据存放在一个消息队列中，每个消息都关联了其源地址信息，每次receive（）调用只返回一条消息。如果receive（）方法在一个缓存区大小为n的DatagramPacket实例中调用，而<code>接受队里中的第一条消息的长度大于n，则receive（）方法只返回这条消息的钱n个字节，超出部分会被自动放弃，而且对接收程序没有任何消息丢失的提示</code>！</p>
<p>3、DatagramPacket的内部消息长度值在接收数据后会发生改变，变为实际接收到的数据的长度值。<br>每一个DatagramPacket实例都包含一个内部消息长度值，其初始值为byte缓存数组的长度值，而该实例一旦接受到消息，这个长度值便会变为接收到的消息的实际长度值，这一点可以用DatagramPacket类的getLength（）方法来测试。如果一个应用程序使用同一个DatagramPacket实例多次调用receive（）方法，每次调用前就必须显式地将其内部消息长度重置为缓存区的实际长度，以免接受的数据发生丢失（见上面客户端代码第53行，服务端代码第29行）。</p>
<p>4、DatagramPacket的getData（）方法总是返回缓冲区的原始大小，忽略了实际数据的内部偏移量和长度信息。<br>由于DatagramPacket的getData（）方法总是返回缓冲数组的原始大小，即刚开始创建缓冲数组时指定的大小，在上面程序中，该长度为1024，因此如果我们要获取接收到的数据，就必须截取getData（）方法返回的数组中只含接收到的数据的那一部分。<br>在Java1.6之后，我们可以使用Arrays.copyOfRange（）方法来实现</p>
<blockquote>
<p>TCP连接中，服务器Socket会为每个客户端建立一个Socket连接，通过每个Socket连接的输入流可以从FIFO接收队列里源源不断取得数据。<br>然而，UDP连接中，因为没有建立连接的过程，所以服务器端是通过收到的数据报的协议字段来获取客户端IP和端口号的，所以它不能“源源不断”地接受客户端数据，它只会将完整的数据报一次性读取干净。所以说，<code>TCP是通过流通信的，而UDP是通过数据报通信的</code>！ </p>
</blockquote>
<h2 id="Socket传输JAVA对象"><a href="#Socket传输JAVA对象" class="headerlink" title="Socket传输JAVA对象"></a>Socket传输JAVA对象</h2><p>因为Socket本质上是依赖IO流来发送和接受数据，所以当需要传对象时，可以使用对象序列化。<br>具体步骤：<br>1、需要传输的对象类必须实现Serilizable标记接口<br> 2、用ObjectOutputStream包装Socket的OutputStream，再writeObject<br> 3、服务器端接收到客户端Socket后，用ObjectInputStream保证Socket的InputStream，再readObject</p>
<h3 id="自定义Socket传输协议"><a href="#自定义Socket传输协议" class="headerlink" title="自定义Socket传输协议"></a>自定义Socket传输协议</h3><blockquote>
<p>在传输消息时，用Java内置的方法和工具确实很用，如：对象序列化，RMI远程调用等。<br>但有时候，针对要传输的特定类型的数据，实现自己的方法可能更简单、容易或有效。<br>显而易见地好处就是<code>灵活性（决定传输的数据而非整个对象）</code>，<code>根据协议最短排除收到的垃圾数据</code></p>
</blockquote>
<p>自定义Socket传输协议的步骤：<br>1、编写满足业务需求的类<br>2、根据协议格式，实现将业务对象转化为byte[]的方法<br>3、通过OutputStream发送数据<br>4、服务器端获取输入流，读取输入流，实现根据byte[]还原（创建）业务对象的方法</p>
<p>该例子是一个简单的投票协议。这里，一个客户端向服务器发送一个请求消息，消息中包含了一个候选人的ID，范围在0~1000。程序支持两种请求：一种是查询请求，即向服务器询问候选人当前获得的投票总数，服务器发回一个响应消息，包含了原来的候选人ID和该候选人当前获得的选票总数；另一种是投票请求，即向指定候选人投一票，服务器对这种请求也发回响应消息，包含了候选人ID和获得的选票数（包含了刚刚投的一票）。</p>
<p><code>在实现一个协议时，一般会定义一个专门的类来存放消息中所包含的的信息</code>。在我们的例子中，客户端和服务端发送的消息都很简单，唯一的区别是服务端发送的消息还包含了选票总数和一个表示相应消息的标志。因此，可以用一个类来表示客户端和服务端的两种消息。下面的VoteMsg.java类展示了每条消息中的基本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VoteMsg &#123;</span><br><span class="line">  private boolean isInquiry; // true if inquiry; false if vote</span><br><span class="line">  private boolean isResponse;// true if response from server</span><br><span class="line">  private int candidateID;   // in [0,1000]</span><br><span class="line">  private long voteCount;    // nonzero only in response</span><br><span class="line"> </span><br><span class="line">  public static final int MAX_CANDIDATE_ID = 1000;</span><br><span class="line"> </span><br><span class="line">  public VoteMsg(boolean isResponse, boolean isInquiry, int candidateID, long voteCount)</span><br><span class="line">      throws IllegalArgumentException &#123;</span><br><span class="line">    // check invariants</span><br><span class="line">    if (voteCount != 0 &amp;&amp; !isResponse) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Request vote count must be zero&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (candidateID &lt; 0 || candidateID &gt; MAX_CANDIDATE_ID) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Bad Candidate ID: &quot; + candidateID);</span><br><span class="line">    &#125;</span><br><span class="line">    if (voteCount &lt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Total must be &gt;= zero&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.candidateID = candidateID;</span><br><span class="line">    this.isResponse = isResponse;</span><br><span class="line">    this.isInquiry = isInquiry;</span><br><span class="line">    this.voteCount = voteCount;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void setInquiry(boolean isInquiry) &#123;</span><br><span class="line">    this.isInquiry = isInquiry;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void setResponse(boolean isResponse) &#123;</span><br><span class="line">    this.isResponse = isResponse;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public boolean isInquiry() &#123;</span><br><span class="line">    return isInquiry;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public boolean isResponse() &#123;</span><br><span class="line">    return isResponse;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void setCandidateID(int candidateID) throws IllegalArgumentException &#123;</span><br><span class="line">    if (candidateID &lt; 0 || candidateID &gt; MAX_CANDIDATE_ID) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Bad Candidate ID: &quot; + candidateID);</span><br><span class="line">    &#125;</span><br><span class="line">    this.candidateID = candidateID;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public int getCandidateID() &#123;</span><br><span class="line">    return candidateID;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void setVoteCount(long count) &#123;</span><br><span class="line">    if ((count != 0 &amp;&amp; !isResponse) || count &lt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Bad vote count&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    voteCount = count;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public long getVoteCount() &#123;</span><br><span class="line">    return voteCount;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    String res = (isInquiry ? &quot;inquiry&quot; : &quot;vote&quot;) + &quot; for candidate &quot; + candidateID;</span><br><span class="line">    if (isResponse) &#123;</span><br><span class="line">      res = &quot;response to &quot; + res + &quot; who now has &quot; + voteCount + &quot; vote(s)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们要根据一定的协议来对其进行编解码，我们定义一个VoteMsgCoder接口，它提供了对投票消息进行序列化和反序列化的方法。toWrie（）方法用于根据一个特定的协议，将投票消息转换成一个字节序列，fromWire（）方法则根据相同的协议，对给定的字节序列进行解析，并根据信息的内容返回一个该消息类的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public interface VoteMsgCoder &#123;</span><br><span class="line">  byte[] toWire(VoteMsg msg) throws IOException;</span><br><span class="line">  VoteMsg fromWire(byte[] input) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出实现了VoteMsgCoder接口的类，基于文本的编码方式<br>首先是用文本方式对消息进行编码的程序。该协议指定使用ASCII字符集对文本进行编码。消息的开头是一个所谓的”魔术字符串“，<code>即一个字符序列，用于快速将投票协议的消息和网络中随机到来的垃圾消息区分开</code>，投票&#x2F;查询布尔值被编码为字符形似，‘v’代表投票消息，‘i’代表查询消息。是否为服务器发送的响应消息，由字符‘R’指示，状态标记后面是候选人ID，其后跟的是选票总数，它们都编码成十进制字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class VoteMsgTextCoder implements VoteMsgCoder &#123;</span><br><span class="line">  /*</span><br><span class="line">   * Wire Format &quot;VOTEPROTO&quot; &lt;&quot;v&quot; | &quot;i&quot;&gt; [&lt;RESPFLAG&gt;] &lt;CANDIDATE&gt; [&lt;VOTECNT&gt;]</span><br><span class="line">   * Charset is fixed by the wire format.</span><br><span class="line">   */</span><br><span class="line"> </span><br><span class="line">  // Manifest constants for encoding</span><br><span class="line">  public static final String MAGIC = &quot;Voting&quot;;</span><br><span class="line">  public static final String VOTESTR = &quot;v&quot;;</span><br><span class="line">  public static final String INQSTR = &quot;i&quot;;</span><br><span class="line">  public static final String RESPONSESTR = &quot;R&quot;;</span><br><span class="line"> </span><br><span class="line">  public static final String CHARSETNAME = &quot;US-ASCII&quot;;</span><br><span class="line">  public static final String DELIMSTR = &quot; &quot;;</span><br><span class="line">  public static final int MAX_WIRE_LENGTH = 2000;</span><br><span class="line"> </span><br><span class="line">  public byte[] toWire(VoteMsg msg) throws IOException &#123;</span><br><span class="line">    String msgString = MAGIC + DELIMSTR + (msg.isInquiry() ? INQSTR : VOTESTR)</span><br><span class="line">        + DELIMSTR + (msg.isResponse() ? RESPONSESTR + DELIMSTR : &quot;&quot;)</span><br><span class="line">        + Integer.toString(msg.getCandidateID()) + DELIMSTR</span><br><span class="line">        + Long.toString(msg.getVoteCount());</span><br><span class="line">    byte data[] = msgString.getBytes(CHARSETNAME);</span><br><span class="line">    return data;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public VoteMsg fromWire(byte[] message) throws IOException &#123;</span><br><span class="line">    ByteArrayInputStream msgStream = new ByteArrayInputStream(message);</span><br><span class="line">    Scanner s = new Scanner(new InputStreamReader(msgStream, CHARSETNAME));</span><br><span class="line">    boolean isInquiry;</span><br><span class="line">    boolean isResponse;</span><br><span class="line">    int candidateID;</span><br><span class="line">    long voteCount;</span><br><span class="line">    String token;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">      token = s.next();</span><br><span class="line">      if (!token.equals(MAGIC)) &#123;</span><br><span class="line">        throw new IOException(&quot;Bad magic string: &quot; + token);</span><br><span class="line">      &#125;</span><br><span class="line">      token = s.next();</span><br><span class="line">      if (token.equals(VOTESTR)) &#123;</span><br><span class="line">        isInquiry = false;</span><br><span class="line">      &#125; else if (!token.equals(INQSTR)) &#123;</span><br><span class="line">        throw new IOException(&quot;Bad vote/inq indicator: &quot; + token);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        isInquiry = true;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      token = s.next();</span><br><span class="line">      if (token.equals(RESPONSESTR)) &#123;</span><br><span class="line">        isResponse = true;</span><br><span class="line">        token = s.next();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        isResponse = false;</span><br><span class="line">      &#125;</span><br><span class="line">      // Current token is candidateID</span><br><span class="line">      // Note: isResponse now valid</span><br><span class="line">      candidateID = Integer.parseInt(token);</span><br><span class="line">      if (isResponse) &#123;</span><br><span class="line">        token = s.next();</span><br><span class="line">        voteCount = Long.parseLong(token);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        voteCount = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException ioe) &#123;</span><br><span class="line">      throw new IOException(&quot;Parse error...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return new VoteMsg(isResponse, isInquiry, candidateID, voteCount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toWire（）方法简单地创建一个字符串，该字符串中包含了消息的所有字段，并由空白符隔开。fromWire（）方法首先检查”魔术字符串“，如果在消息最前面没有魔术字符串，则抛出一个异常。在理说明了在实现协议时非常重要的一点：<code>永远不要对从网络中来的任何输入进行任何假设。你的程序必须时刻为任何可能的输入做好准备，并能很好的对其进行处理</code></p>
<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Socket client = new Socket(&quot;127.0.0.1&quot;, 12325);</span><br><span class="line">		VoteMsg voteMsg = new VoteMsg(false, true, 1, 0L);</span><br><span class="line">		VoteMsgTextCoder coder = new VoteMsgTextCoder();</span><br><span class="line">		byte[] bytes = coder.toWire(voteMsg);</span><br><span class="line">		OutputStream oStream = client.getOutputStream();</span><br><span class="line">		PrintStream printStream = new PrintStream(oStream);</span><br><span class="line">		printStream.write(bytes);</span><br><span class="line">		client.close();</span><br></pre></td></tr></table></figure>

<p>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerSocket server = new ServerSocket(12325);</span><br><span class="line">    	Socket client = server.accept();</span><br><span class="line">    	InputStream iStream = client.getInputStream();</span><br><span class="line">    	ByteBuffer byteBuffer = new ByteBuffer();</span><br><span class="line">    	byte b;</span><br><span class="line">    	while((b=(byte)iStream.read()) != -1) &#123;</span><br><span class="line">    		byteBuffer.append(b);</span><br><span class="line">    	&#125;</span><br><span class="line">    	VoteMsgTextCoder voteMsgTextCoder = new VoteMsgTextCoder();</span><br><span class="line">    	byte[] bytes = byteBuffer.toArray();</span><br><span class="line">    	VoteMsg voteMsg = voteMsgTextCoder.fromWire(bytes);</span><br><span class="line">    	System.out.println(voteMsg.getCandidateID());</span><br><span class="line">    	server.close();</span><br><span class="line">    	client.close();</span><br></pre></td></tr></table></figure>

<h3 id="应用程序协议中消息的成帧与解析"><a href="#应用程序协议中消息的成帧与解析" class="headerlink" title="应用程序协议中消息的成帧与解析"></a>应用程序协议中消息的成帧与解析</h3><p>由于协议通常处理的是由一组字段组成的离散的信息，因此应用程序协议必须指定消息的接收者如何确定何时消息已被完整接收。<code>成帧技术就是解决接收端如何定位消息首尾位置问题的</code>，  由于协议通常处理的是由一组字段组成的离散的信息，因此应用程序协议必须指定消息的接收者如何确定何时消息已被完整。主要有两种技术使接收者能够准确地找到消息的结束位置：</p>
<p>1、<code>基于定界符</code>：消息的结束由一个唯一的标记指出，即发送者在传输完数据后显式添加的一个特定字节序列，这个特殊标记不能在传输的数据中出现（这也不是绝对的，应用填充技术能够对消息中出现的定界符进行修改，从而使接收者不将其识别为定界符）。该方法通常用在以文本方式编码的消息中。</p>
<p>2、<code>显式长度</code>：在变长字段或消息前附加一个固定大小的字段，用来指示该字段或消息中包含了多少字节。该方法主要用在以二进制字节方式编码的消息中。</p>
<blockquote>
<p>由于UDP套接字保留了消息的边界信息，因此不需要进行成帧处理（实际上，主要是DatagramPacket负载的数据有一个确定的长度，接收者能够准确地知道消息的结束位置），而TCP协议中没有消息边界的概念<br>因此，在使用TCP套接字时，成帧就是一个非常重要的考虑因素（在TCP连接中，接收者读取完最后一条消息的最后一个字节后，将受到一个流结束标记，即read（）返回-1，该标记指示出已经读取到了消息的末尾，非严格意义上来讲，这也算是基于定界符方法的一种特殊情况）。</p>
</blockquote>
<p>下面给出一个自定义实现上面两种成帧技术的Demo（书上的例子），先定义一个Framer接口，它由两个方法：frameMag（）方法用来添加成帧信息并将指定消息输出到指定流，nextMsg（）方法则扫描指定的流，从中抽取出下一条消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line">public interface Framer &#123;</span><br><span class="line">  void frameMsg(byte[] message, OutputStream out) throws IOException;</span><br><span class="line">  byte[] nextMsg() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码实现了基于定界符的成帧方法，定界符为换行符“\n”，frameMsg（）方法并没有实现填充，当成帧的字节序列中包含有定界符时，它只是简单地抛出异常；nextMsg（）方法扫描刘，直到读取到了定界符，并返回定界符前面所有的字符，如果流为空则返回null，如果直到流结束也没找到定界符，程序将抛出一个异常来指示成帧错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.EOFException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line">public class DelimFramer implements Framer &#123;</span><br><span class="line"> </span><br><span class="line">  private InputStream in;        // 数据来源</span><br><span class="line">  private static final byte DELIMITER = &#x27;\n&#x27;; // 定界符</span><br><span class="line"> </span><br><span class="line">  public DelimFramer(InputStream in) &#123;</span><br><span class="line">    this.in = in;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public void frameMsg(byte[] message, OutputStream out) throws IOException &#123;</span><br><span class="line">    for (byte b : message) &#123;</span><br><span class="line">      if (b == DELIMITER) &#123;</span><br><span class="line">        //如果在消息中检查到界定符，则抛出异常</span><br><span class="line">        throw new IOException(&quot;Message contains delimiter&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.write(message);</span><br><span class="line">    out.write(DELIMITER);</span><br><span class="line">    out.flush();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public byte[] nextMsg() throws IOException &#123;</span><br><span class="line">    ByteArrayOutputStream messageBuffer = new ByteArrayOutputStream();</span><br><span class="line">    int nextByte;</span><br><span class="line"> </span><br><span class="line">    while ((nextByte = in.read()) != DELIMITER) &#123;</span><br><span class="line">      //如果流已经结束还没有读取到定界符</span><br><span class="line">      if (nextByte == -1) &#123; </span><br><span class="line">        //如果读取到的流为空，则返回null</span><br><span class="line">        if (messageBuffer.size() == 0) &#123; </span><br><span class="line">          return null;</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">          //如果读取到的流不为空，则抛出异常</span><br><span class="line">          throw new EOFException(&quot;Non-empty message without delimiter&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      messageBuffer.write(nextByte); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return messageBuffer.toByteArray();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码实现了基于长度的成帧方法，适用于长度小于65535个字节的消息。发送者首先给出指定消息的长度，并将长度信息以big-endian顺序（从左边开始，由高位到低位发送）存入2个字节的整数中，再将这两个字节存放在完整的消息内容前，连同消息一起写入输出流；在接收端，使用DataInputStream读取整型的长度信息，readFully（）方法将阻塞等待，直到给定的数组完全填满。使用这种成帧方法，发送者不需要检查要成帧的消息内容，而只需要检查消息的长度是否超出了限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.EOFException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line">public class LengthFramer implements Framer &#123;</span><br><span class="line">  public static final int MAXMESSAGELENGTH = 65535;</span><br><span class="line">  public static final int BYTEMASK = 0xff;</span><br><span class="line">  public static final int SHORTMASK = 0xffff;</span><br><span class="line">  public static final int BYTESHIFT = 8;</span><br><span class="line"> </span><br><span class="line">  private DataInputStream in;</span><br><span class="line"> </span><br><span class="line">  public LengthFramer(InputStream in) throws IOException &#123;</span><br><span class="line">    this.in = new DataInputStream(in);    //数据来源</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  //对字节流message添加成帧信息，并输出到指定流 </span><br><span class="line">  public void frameMsg(byte[] message, OutputStream out) throws IOException &#123;</span><br><span class="line">    //消息的长度不能超过65535</span><br><span class="line">    if (message.length &gt; MAXMESSAGELENGTH) &#123;</span><br><span class="line">      throw new IOException(&quot;message too long&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    out.write((message.length &gt;&gt; BYTESHIFT) &amp; BYTEMASK);</span><br><span class="line">    out.write(message.length &amp; BYTEMASK);</span><br><span class="line">    out.write(message);</span><br><span class="line">    out.flush();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public byte[] nextMsg() throws IOException &#123;</span><br><span class="line">    int length;</span><br><span class="line">    try &#123; </span><br><span class="line">      //该方法读取2个字节，将它们作为big-endian整数进行解释，并以int型整数返回它们的值</span><br><span class="line">      length = in.readUnsignedShort(); </span><br><span class="line">    &#125; catch (EOFException e) &#123; // no (or 1 byte) message</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 0 &lt;= length &lt;= 65535</span><br><span class="line">    byte[] msg = new byte[length];</span><br><span class="line">    //该方法处阻塞等待，直到接收到足够的字节来填满指定的数组</span><br><span class="line">    in.readFully(msg); </span><br><span class="line">    return msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于线程池的TCP服务器"><a href="#基于线程池的TCP服务器" class="headerlink" title="基于线程池的TCP服务器"></a>基于线程池的TCP服务器</h1><p>我们让服务器在启动时创建一个由固定线程数量组成的线程池，当一个新的客户端连接请求传入服务器，它将交给线程池中的一个线程处理，该线程处理完这个客户端之后，又返回线程池，继续等待下一次请求。如果连接请求到达服务器时，线程池中所有的线程都已经被占用，它们则在一个队列中等待，直到有空闲的线程可用。</p>
<p>实现步骤<br>1、与一客户一线程服务器一样，线程池服务器首先创建一个ServerSocket实例。<br>2、然后创建N个线程，每个线程反复循环，从（共享的）ServerSocket实例接收客户端连接。当多个线程同时调用一个ServerSocket实例的accept（）方法时，它们都将阻塞等待，直到一个新的连接成功建立，然后系统选择一个线程，为建立起的连接提供服务，其他线程则继续阻塞等待。<br>3、线程在完成对一个客户端的服务后，继续等待其他的连接请求，而不终止。如果在一个客户端连接被创建时，没有线程在accept（）方法上阻塞（即所有的线程都在为其他连接服务），系统则将新的连接排列在一个队列中，直到下一次调用accept（）方法。</p>
<h2 id="不用线程池的实现"><a href="#不用线程池的实现" class="headerlink" title="不用线程池的实现"></a>不用线程池的实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package zyb.org.server;</span><br><span class="line"> </span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 该类为多线程类，用于服务端</span><br><span class="line"> */</span><br><span class="line">public class ServerThread implements Runnable &#123;</span><br><span class="line"> </span><br><span class="line">    private Socket client = null;</span><br><span class="line">    public ServerThread(Socket client)&#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //处理通信细节的静态方法，这里主要是方便线程池服务器的调用</span><br><span class="line">    public static void execute(Socket client)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //获取Socket的输出流，用来向客户端发送数据  </span><br><span class="line">            PrintStream out = new PrintStream(client.getOutputStream());</span><br><span class="line">            //获取Socket的输入流，用来接收从客户端发送过来的数据</span><br><span class="line">            BufferedReader buf = new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">            boolean flag =true;</span><br><span class="line">            while(flag)&#123;</span><br><span class="line">                //接收从客户端发送过来的数据  </span><br><span class="line">                String str =  buf.readLine();</span><br><span class="line">                if(str == null || &quot;&quot;.equals(str))&#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(&quot;bye&quot;.equals(str))&#123;</span><br><span class="line">                        flag = false;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        //将接收到的字符串前面加上echo，发送到对应的客户端  </span><br><span class="line">                        out.println(&quot;echo:&quot; + str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">            buf.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        execute(client);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package zyb.org.server;</span><br><span class="line"> </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 该类实现基于线程池的服务器</span><br><span class="line"> */</span><br><span class="line">public class serverPool &#123;</span><br><span class="line"> </span><br><span class="line">    private static final int THREADPOOLSIZE = 2;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        //服务端在20006端口监听客户端请求的TCP连接 </span><br><span class="line">        final ServerSocket server = new ServerSocket(20006);</span><br><span class="line"> </span><br><span class="line">        //在线程池中一共只有THREADPOOLSIZE个线程，</span><br><span class="line">        //最多有THREADPOOLSIZE个线程在accept()方法上阻塞等待连接请求</span><br><span class="line">        for(int i=0;i&lt;THREADPOOLSIZE;i++)&#123;</span><br><span class="line">            //匿名内部类，当前线程为匿名线程，还没有为任何客户端连接提供服务</span><br><span class="line">            Thread thread = new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    //线程为某连接提供完服务后，循环等待其他的连接请求</span><br><span class="line">                    while(true)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            //等待客户端的连接</span><br><span class="line">                            Socket client = server.accept();</span><br><span class="line">                            System.out.println(&quot;与客户端连接成功！&quot;);</span><br><span class="line">                            //一旦连接成功，则在该线程中与客户端通信</span><br><span class="line">                            ServerThread.execute(client);</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            //先将所有的线程开启</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用线程池的实现"><a href="#使用线程池的实现" class="headerlink" title="使用线程池的实现"></a>使用线程池的实现</h2><p>Executor接口代表了一个根据某种策略来执行Runnable实例的对象，其中可能包括了排队和调度等细节，或如何选择要执行的任务。<br>ava提供了大量的内置Executor接口实现，它们都可以简单方便地使用，ExecutorService接口继承于Executor接口，它提供了一个更高级的工具来关闭服务器，包括正常的关闭和突然的关闭。我们可以通过调用Executors类的各种静态工厂方法来获取ExecutorService实例，而后通过调用execute（）方法来为需要处理的任务分配线程<br>它首先会尝试使用已有的线程，但如果有必要，它会创建一个新的线程来处理任务，另外，如果一个线程空闲了60秒以上，则将其移出线程池，而且任务是在Executor的内部排队，而不像之前的服务器那样是在网络系统中排队。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package zyb.org.server;</span><br><span class="line"> </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 该类通过Executor接口实现服务器</span><br><span class="line"> */</span><br><span class="line">public class ServerExecutor &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        //服务端在20006端口监听客户端请求的TCP连接 </span><br><span class="line">        ServerSocket server = new ServerSocket(20006);</span><br><span class="line">        Socket client = null;</span><br><span class="line">        //通过调用Executors类的静态方法，创建一个ExecutorService实例</span><br><span class="line">        //ExecutorService接口是Executor接口的子接口</span><br><span class="line">        Executor service = Executors.newCachedThreadPool();</span><br><span class="line">        boolean f = true;</span><br><span class="line">        while(f)&#123;</span><br><span class="line">            //等待客户端的连接</span><br><span class="line">            client = server.accept();</span><br><span class="line">            System.out.println(&quot;与客户端连接成功！&quot;);</span><br><span class="line">            //调用execute()方法时，如果必要，会创建一个新的线程来处理任务，但它首先会尝试使用已有的线程，</span><br><span class="line">            //如果一个线程空闲60秒以上，则将其移除线程池；</span><br><span class="line">            //另外，任务是在Executor的内部排队，而不是在网络中排队</span><br><span class="line">            service.execute(new ServerThread(client));</span><br><span class="line">        &#125; </span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于NIO的TCP通信"><a href="#基于NIO的TCP通信" class="headerlink" title="基于NIO的TCP通信"></a>基于NIO的TCP通信</h1><p>在标准IO的Socket编程中，套接字的某些操作可能会造成阻塞：accept（）方法的调用可能会因为等待一个客户端连接而阻塞，read（）方法也可能会因为没有数据可读而阻塞，write（）方法在数据没有完全写入时也可能会发生阻塞，阻塞发生时，该线程被挂起，什么也干不了。</p>
<blockquote>
<p>Java NIO引入了选择器的概念，选择器可以监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道，这也是非阻塞IO的核心。而在标准IO的Socket编程中，单个线程则只能在一个端口监听。</p>
</blockquote>
<h2 id="NIO主要原理及使用"><a href="#NIO主要原理及使用" class="headerlink" title="NIO主要原理及使用"></a>NIO主要原理及使用</h2><p>NIO采取通道（Channel）和缓冲区(Buffer)来传输和保存数据，它是<code>非阻塞式的I/O</code>，即在等待连接、读写数据（这些都是在一线程以客户端的程序中会阻塞线程的操作）的时候，程序也可以做其他事情，以实现线程的异步操作。</p>
<p>考虑一个即时消息服务器，可能有上千个客户端同时连接到服务器，但是在任何时刻只有非常少量的消息需要读取和分发（如果采用线程池或者一线程一客户端方式，则会非常浪费资源），这就需要一种方法能阻塞等待，直到有一个信道可以进行I&#x2F;O操作。NIO的Selector选择器就实现了这样的功能</p>
<blockquote>
<p>一个Selector实例可以同时检查一组信道的I&#x2F;O状态，它就类似一个观察者，只要我们把需要探知的SocketChannel告诉Selector,我们接着做别的事情，当有事件（比如，连接打开、数据到达等）发生时，它会通知我们，传回一组SelectionKey,我们读取这些Key,就会获得我们刚刚注册过的SocketChannel，然后，我们从这个Channel中读取数据，接着我们可以处理这些数据。</p>
</blockquote>
<p>Selector内部原理实际是在做一个对所注册的Channel的<code>轮询</code>访问，不断的轮询(目前就这一个算法)，一旦轮询到一个Channel有所注册的事情发生，比如数据来了，它就会读取Channel中的数据，并对其进行处理。</p>
<p>要使用选择器，需要创建一个Selector实例，并将其注册到想要监控的信道上（通过Channel的方法实现）。最后调用选择器的select（）方法，该方法会阻塞等待，直到有一个或多个信道准备好了I&#x2F;O操作或等待超时，或另一个线程调用了该选择器的wakeup（）方法。现在，在一个单独的线程中，通过调用select（）方法，就能检查多个信道是否准备好进行I&#x2F;O操作，由于非阻塞I&#x2F;O的异步特性，在检查的同时，我们也可以执行其他任务。</p>
<h2 id="基于NIO的TCP连接的建立步骤"><a href="#基于NIO的TCP连接的建立步骤" class="headerlink" title="基于NIO的TCP连接的建立步骤"></a>基于NIO的TCP连接的建立步骤</h2><p>服务端<br>1、传建一个Selector实例；<br>2、将其注册到各种信道，并指定每个信道上感兴趣的I&#x2F;O操作；<br>3、重复执行：<br>1）调用一种select（）方法；<br>2）获取选取的键列表；<br>3）对于已选键集中的每个键：<br>a、获取信道，并从键中获取附件（如果为信道及其相关的key添加了附件的话）；<br>b、确定准备就绪的操纵并执行，如果是accept操作，将接收的信道设置为非阻塞模式，并注册到选择器；<br>c、如果需要，修改键的兴趣操作集；<br>d、从已选键集中移除键</p>
<p>客户端<br>与基于多线程的TCP客户端大致相同，只是这里是通过信道建立的连接，但在等待连接建立及读写时，我们可以异步地执行其他任务。</p>
<h2 id="基于NIO的TCP通信Demo"><a href="#基于NIO的TCP通信Demo" class="headerlink" title="基于NIO的TCP通信Demo"></a>基于NIO的TCP通信Demo</h2><p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line"> </span><br><span class="line">public class TCPEchoClientNonblocking &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        if ((args.length &lt; 2) || (args.length &gt; 3)) </span><br><span class="line">        throw new IllegalArgumentException(&quot;参数不正确&quot;);</span><br><span class="line">        //第一个参数作为要连接的服务端的主机名或IP</span><br><span class="line">        String server = args[0]; </span><br><span class="line">        //第二个参数为要发送到服务端的字符串</span><br><span class="line">        byte[] argument = args[1].getBytes();</span><br><span class="line">        //如果有第三个参数，则作为端口号，如果没有，则端口号设为7</span><br><span class="line">        int servPort = (args.length == 3) ? Integer.parseInt(args[2]) : 7;</span><br><span class="line">        //创建一个信道，并设为非阻塞模式</span><br><span class="line">        SocketChannel clntChan = SocketChannel.open();</span><br><span class="line">        clntChan.configureBlocking(false);</span><br><span class="line">        //向服务端发起连接</span><br><span class="line">        if (!clntChan.connect(new InetSocketAddress(server, servPort)))&#123;</span><br><span class="line">            //不断地轮询连接状态，直到完成连接</span><br><span class="line">            while (!clntChan.finishConnect())&#123;</span><br><span class="line">                //在等待连接的时间里，可以执行其他任务，以充分发挥非阻塞IO的异步特性</span><br><span class="line">                //这里为了演示该方法的使用，只是一直打印&quot;.&quot;</span><br><span class="line">                System.out.print(&quot;.&quot;);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //为了与后面打印的&quot;.&quot;区别开来，这里输出换行符</span><br><span class="line">        System.out.print(&quot;\n&quot;);</span><br><span class="line">        //分别实例化用来读写的缓冲区</span><br><span class="line">        ByteBuffer writeBuf = ByteBuffer.wrap(argument);</span><br><span class="line">        ByteBuffer readBuf = ByteBuffer.allocate(argument.length);</span><br><span class="line">        //接收到的总的字节数</span><br><span class="line">        int totalBytesRcvd = 0; </span><br><span class="line">        //每一次调用read（）方法接收到的字节数</span><br><span class="line">        int bytesRcvd; </span><br><span class="line">        //循环执行，直到接收到的字节数与发送的字符串的字节数相等</span><br><span class="line">        while (totalBytesRcvd &lt; argument.length)&#123;</span><br><span class="line">            //如果用来向通道中写数据的缓冲区中还有剩余的字节，则继续将数据写入信道</span><br><span class="line">            if (writeBuf.hasRemaining())&#123;</span><br><span class="line">                clntChan.write(writeBuf);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果read（）接收到-1，表明服务端关闭，抛出异常</span><br><span class="line">            if ((bytesRcvd = clntChan.read(readBuf)) == -1)&#123;</span><br><span class="line">                throw new SocketException(&quot;Connection closed prematurely&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //计算接收到的总字节数</span><br><span class="line">            totalBytesRcvd += bytesRcvd;</span><br><span class="line">            //在等待通信完成的过程中，程序可以执行其他任务，以体现非阻塞IO的异步特性</span><br><span class="line">            //这里为了演示该方法的使用，同样只是一直打印&quot;.&quot;</span><br><span class="line">            System.out.print(&quot;.&quot;); </span><br><span class="line">        &#125;</span><br><span class="line">        //打印出接收到的数据</span><br><span class="line">        System.out.println(&quot;Received: &quot; +  new String(readBuf.array(), 0, totalBytesRcvd));</span><br><span class="line">        //关闭信道</span><br><span class="line">        clntChan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"> </span><br><span class="line">public class TCPServerSelector&#123;</span><br><span class="line">    //缓冲区的长度</span><br><span class="line">    private static final int BUFSIZE = 256; </span><br><span class="line">    //select方法等待信道准备好的最长时间</span><br><span class="line">    private static final int TIMEOUT = 3000; </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        if (args.length &lt; 1)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Parameter(s): &lt;Port&gt; ...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        for (String arg : args)&#123;</span><br><span class="line">            //实例化一个信道</span><br><span class="line">            ServerSocketChannel listnChannel = ServerSocketChannel.open();</span><br><span class="line">            //将该信道绑定到指定端口</span><br><span class="line">            listnChannel.socket().bind(new InetSocketAddress(Integer.parseInt(arg)));</span><br><span class="line">            //配置信道为非阻塞模式</span><br><span class="line">            listnChannel.configureBlocking(false);</span><br><span class="line">            //将选择器注册到各个信道</span><br><span class="line">            listnChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个实现了协议接口的对象</span><br><span class="line">        TCPProtocol protocol = new EchoSelectorProtocol(BUFSIZE);</span><br><span class="line">        //不断轮询select方法，获取准备好的信道所关联的Key集</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            //一直等待,直至有信道准备好了I/O操作</span><br><span class="line">            if (selector.select(TIMEOUT) == 0)&#123;</span><br><span class="line">                //在等待信道准备的同时，也可以异步地执行其他任务，</span><br><span class="line">                //这里只是简单地打印&quot;.&quot;</span><br><span class="line">                System.out.print(&quot;.&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取准备好的信道所关联的Key集合的iterator实例</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line">            //循环取得集合中的每个键值</span><br><span class="line">            while (keyIter.hasNext())&#123;</span><br><span class="line">                SelectionKey key = keyIter.next(); </span><br><span class="line">                //如果服务端信道感兴趣的I/O操作为accept</span><br><span class="line">                if (key.isAcceptable())&#123;</span><br><span class="line">                    protocol.handleAccept(key);</span><br><span class="line">                &#125;</span><br><span class="line">                //如果客户端信道感兴趣的I/O操作为read</span><br><span class="line">                if (key.isReadable())&#123;</span><br><span class="line">                    protocol.handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">                //如果该键值有效，并且其对应的客户端信道感兴趣的I/O操作为write</span><br><span class="line">                if (key.isValid() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                    protocol.handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                //这里需要手动从键集中移除当前的key</span><br><span class="line">                keyIter.remove(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line">*该接口定义了通用TCPSelectorServer类与特定协议之间的接口，</span><br><span class="line">*它把与具体协议相关的处理各种I/O的操作分离了出来，</span><br><span class="line">*以使不同协议都能方便地使用这个基本的服务模式。</span><br><span class="line">*/</span><br><span class="line">public interface TCPProtocol&#123;</span><br><span class="line">    //accept I/O形式</span><br><span class="line">    void handleAccept(SelectionKey key) throws IOException;</span><br><span class="line">    //read I/O形式</span><br><span class="line">    void handleRead(SelectionKey key) throws IOException;</span><br><span class="line">    //write I/O形式</span><br><span class="line">    void handleWrite(SelectionKey key) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class EchoSelectorProtocol implements TCPProtocol &#123;</span><br><span class="line">    private int bufSize; // 缓冲区的长度</span><br><span class="line">    public EchoSelectorProtocol(int bufSize)&#123;</span><br><span class="line">    this.bufSize = bufSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //服务端信道已经准备好了接收新的客户端连接</span><br><span class="line">    public void handleAccept(SelectionKey key) throws IOException &#123;</span><br><span class="line">        SocketChannel clntChan = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">        clntChan.configureBlocking(false);</span><br><span class="line">        //将选择器注册到连接到的客户端信道，并指定该信道key值的属性为OP_READ，同时为该信道指定关联的附件</span><br><span class="line">        clntChan.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufSize));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //客户端信道已经准备好了从信道中读取数据到缓冲区</span><br><span class="line">    public void handleRead(SelectionKey key) throws IOException&#123;</span><br><span class="line">        SocketChannel clntChan = (SocketChannel) key.channel();</span><br><span class="line">        //获取该信道所关联的附件，这里为缓冲区</span><br><span class="line">        ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">        long bytesRead = clntChan.read(buf);</span><br><span class="line">        //如果read（）方法返回-1，说明客户端关闭了连接，那么客户端已经接收到了与自己发送字节数相等的数据，可以安全地关闭</span><br><span class="line">        if (bytesRead == -1)&#123; </span><br><span class="line">            clntChan.close();</span><br><span class="line">        &#125;else if(bytesRead &gt; 0)&#123;</span><br><span class="line">        //如果缓冲区总读入了数据，则将该信道感兴趣的操作设置为为可读可写</span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //客户端信道已经准备好了将数据从缓冲区写入信道</span><br><span class="line">    public void handleWrite(SelectionKey key) throws IOException &#123;</span><br><span class="line">    //获取与该信道关联的缓冲区，里面有之前读取到的数据</span><br><span class="line">    ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">    //重置缓冲区，准备将数据写入信道</span><br><span class="line">    buf.flip(); </span><br><span class="line">    SocketChannel clntChan = (SocketChannel) key.channel();</span><br><span class="line">    //将数据写入到信道中</span><br><span class="line">    clntChan.write(buf);</span><br><span class="line">    if (!buf.hasRemaining())&#123; </span><br><span class="line">    //如果缓冲区中的数据已经全部写入了信道，则将该信道感兴趣的操作设置为可读</span><br><span class="line">      key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    //为读入更多的数据腾出空间</span><br><span class="line">    buf.compact(); </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>以上的服务端程序，select（）方法第一次能选择出来的准备好的信道都是服务端信道，其关联键值的属性都为OP_ACCEPT，亦及有效操作都为accept，在执行handleAccept方法时，为取得连接的客户端信道也进行了注册，属性为OP_READ，这样下次轮询调用select（）方法时，便会检查到对read操作感兴趣的客户端信道（当然也有可能有关联accept操作兴趣集的信道），从而调用handleRead方法，在该方法中又注册了OP_WRITE属性，那么第三次调用select（）方法时，便会检测到对write操作感兴趣的客户端信道（当然也有可能有关联read操作兴趣集的信道），从而调用handleWrite方法。<br>结果：<br>从结果中很明显地可以看出，服务器端在等待信道准备好的时候，线程没有阻塞，而是可以执行其他任务，这里只是简单的打印”.”，客户端在等待连接和等待数据读写完成的时候，线程没有阻塞，也可以执行其他任务，这里也正是简单的打印”.”。</p>
<p>注意：<br>1、对于非阻塞SocketChannel来说，一旦已经调用connect（）方法发起连接，底层套接字可能既不是已经连接，也不是没有连接，而是正在连接。由于底层协议的工作机制，套接字可能会在这个状态一直保持下去，这时候就需要循环地调用finishConnect（）方法来检查是否完成连接，在等待连接的同时，线程也可以做其他事情，这便实现了线程的异步操作。</p>
<p>2、write（）方法的非阻塞调用只会写出其能够发送的数据，而不会阻塞等待所有数据，而后一起发送，因此在调用write（）方法将数据写入信道时，一般要用到while循环,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while（buf.hasRemaining()）</span><br><span class="line">    channel.write(buf);</span><br></pre></td></tr></table></figure>
<p>3、任何对key（信道）所关联的兴趣操作集的改变，都只在下次调用了select（）方法后才会生效。</p>
<p>4、selectedKeys（）方法返回的键集是<code>可修改</code>的，<code>实际上在两次调用select（）方法之间，都必须手动将其清空，否则，它就会在下次调用select（）方法时仍然保留在集合中，而且可能会有无用的操作来调用它</code>，换句话说，select（）方法只会在已有的所选键集上添加键，它们不会创建新的建集。</p>
<p>5、<code>对于ServerSocketChannel来说，accept是唯一的有效操作</code>，而对于SocketChannel来说，有效操作包括读、写和连接，另外，<code>对于DatagramChannle，只有读写操作是有效的</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="基本套接字"><a href="#基本套接字" class="headerlink" title="基本套接字"></a>基本套接字</h2><p>1、编写TCP客户端程序，在实例化Socket类时，要注意，底层的TCP协议只能处理IP协议，如果传递的第一个参数是主机名字而不是你IP地址，Socket类具体实现的时候会将其解析成相应的地址，若因为某些原因连接失败，构造函数会抛出一个IOException异常。</p>
<p>2、TCP协议读写数据时，<code>read()方法在没有可读数据时会阻塞等待，直到有新的数据可读</code>。另外，<code>TCP协议并不能确定在read()和write()方法中所发送信息的界限，接收或发送的数据可能被TCP协议分割成了多个部分。</code></p>
<p>3、<code>编写TCP服务器端的程序将在accept()方法处阻塞，以等待客户端的连接请求</code>，一旦取得连接，便要为每个客户端的连接建立一个Socket实例来进行数据通信。</p>
<p>4、在UDP程序中，创建DatagramPacket实例时，如果没有指定远程主机地址和端口，则该实例用来接收数据（尽管可以调用setXXX()等方法指定），如果指定了远程主机地址和端口，则该实例用来发送数据。</p>
<p>5、UDP程序在receive()方法处阻塞，直到收到一个数据报文或等待超时。由于UDP协议是不可靠协议，如果数据报在传输过程中发生丢失，那么程序将会一直阻塞在receive()方法处，这对客户端来说是肯定不行的，为了避免这个问题，我们在客户端使用DatagramSocket类的<code>setSoTimeout()方法来制定receive()方法的最长阻塞时间，并指定重发数据报的次数</code>，如果每次阻塞都超时，并且重发次数达到了设置的上限，则关闭客户端。</p>
<p>6、UDP服务器为所有通信使用同一套接字，这点与TCP服务器不同，TCP服务器则为每个成功返回的accept()方法创建一个新的套接字。</p>
<p>7、在UDP程序中，DatagramSocket的每一次receive()调用最多只能接收调用一次send()方法所发送的数据，而且，不同的receive()方法调用绝对不会返回同一个send()方法所发送的额数据。</p>
<p>8、在UDP套接字编程中，如果receive()方法在一个缓冲区大小为n的DatagramPscket实例中调用，而接受队列中的第一个消息长度大于n，则receive()方法只返回这条消息的前n个字节，超出的其他字节部分将自动被丢弃，而且也没有任何消息丢失的提示。因此，接受者应该提供一个足够大的缓存空间的DatagramPacket实例，以完整地存放调用receive()方法时应用程序协议所允许的最大长度的消息。一个DatagramPacket实例中所运行传输的最大数据量为65507个字节，即UDP数据报文所能负载的最多数据，因此，使用一个有65600字节左右缓存数组的数据总是安全的。</p>
<p>9、在UDP套接字编程中，每一个DatagramPacket实例都包含一个内部消息长度值，而该实例一接收到新消息，这个长度值便可能改变（以反映实际接收的消息的字节数）。如果一个应用程序使用同一个DatagramPacket实例多次调用receive()方法，每次调用前就必须显式地将消息的内部长度重置为缓冲区的实际长度。</p>
<p>10、另一个潜在问题的根源是DatagramPacket类的getData()方法,该方法总是返回缓冲区的原始大小，忽略了实际数据的内部偏移量和长度信息。</p>
<h2 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h2><p>1、程序间达成的一种包含了信息交换的形式和意义的共识称为协议，用来实现特定应用程序的协议叫做应用程序协议。</p>
<p>2、TCP&#x2F;IP协议的唯一约束是：信息必须在块中发送和接收，而块的长度必须是8的倍数，因此，我们可以认为TCP&#x2F;IP协议中传输的信息是字节序列。</p>
<p>3、关于字符，对于每个整数值都比255小的一组字符，因为其每个字符都能够作为一个单独的字节进行编码，因此不需要其他信息，而对于可能使用超过一个字节的大整数的编码方式，就有多种方式对其进行编码，这就是编码方案。编码字符集和字符的编码方案结合起来称为字符集。在网络编程中，发送者和接收者必须在文本字符串的表示方式上达成共识，最简单的方法就是使用同一个标准字符集。</p>
<p>4、成帧技术解决了消息接收端如何定位消息的首尾位置的问题。与UDP协议不同，TCP协议中没有消息边界的概念，因此在使用TCP套接字时，成帧就是一个非常重要的考虑因素。</p>
<p>5、主要有两种技术能够使消息接收者准确地找到消息的结束位置：基于定界符和显式长度，前者对消息的结束由一个唯一的标记指出，即发送者在传输完数据后显式添加一个特殊字符序列，这个特殊标记不能在传输的数据中出现，当然，填充技术能够对消息中出现的界定符进行修改，从而使接受者不将其识别为界定符；后者在变长字段或消息前附加一个固定大小的字段值，用来指示该字段或消息中包含多少个字节。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>1、主线程结束后，其他线程也可以继续执行，Java虚拟机只有在所有非守护线程都执行完毕的情况下才终止。</p>
<p>2、服务器一般每分钟都要执行上千次客户端的请求，因此，为了更好的分析异常，大部分的服务器都会将它们的活动记录写入日志，Java中可以用java.util.logging.Logger类来实现相关功能，在Java中，每个日志记录器由一个全局唯一的名字识别，可以通过静态方法getLogger（string name）来获取者由名字name标示的唯一记录器。默认情况下，每个logger有一个ConsoleHandler用来将消息打印到System.err中。Logger的一个重要特征是它是线程安全的，即可以在并行运行的不同线程中调用它的方法，而不需要在调用者中添加额外的同步措施，如果没有这个特征，由不同线程记录的不同消息将错乱无章地写入到日志中。</p>
<p>3、用线程池实现TCP服务器端时，首先创建一个ServerSocket实例，然后创建N个线程，每个线程反复循环，从（共享的）ServerSocket实例接收客户端连接。当多个线程同时调用一个ServerSocket实例的accept（）方法时，它们都将阻塞等待，直到一个新的连接成功建立，然后系统选择一个线程，用于刚刚建立起的新的连接，其他线程则继续阻塞等待。如果在一个客户端连接被创建时，没有线程在accept（）方法上阻塞（即所有的线程都在为其他连接服务），系统则将新的连接排列在一个队列中，直到下一次调用accept（）方法。</p>
<p>4、利用线程池实现服务器端程序时，线程池的大小需要根据负载情况进行调整，以使客户端连接时间最短，理想的情况是有一个调度工具，可以在系统负载增加时扩展线程池的大小（低于上限值），负载减轻时缩减线程池的大小。<code>Java中提供了Executor接口来管理调度线程，它就代表了一个根据某种策略来执行Runnable实例的对象其中可能包含了排队和调度等细节，或如何选择要执行的任务。在使用Executor时，任务是在Executor内部排队，而不是在网络系统中排队</code>。</p>
<p>5、ExecutorService接口继承于Executor接口，当ExecutorService接口的实例调用execute（）方法时，需要传入一个实现了Runnable接口的实例，如果必要，它将创建一个新的线程来处理任务，但它首先会尝试使用已有的线程，如果一个线程空闲了60秒以上，则将被移除线程池。值得注意的是，当达到稳定状态时，缓存线程池服务最终将保持合适的线程数，以使每个线程都保持忙碌，同时又很少创建或销毁线程。</p>
<p>6、阻塞式Socket编程中，Socket的I&#x2F;O会因为多种原因而阻塞。数据输入方法read（）和receive（）在没有数据可读时会阻塞，TCP套接字的write（）方法在没有足够的空间缓存传输的数据时可能阻塞，ServerSocket的accept（）方法和Socket的构造函数都会阻塞等待。当调用一个已经阻塞的方法将使用应用程序停止，并使运行它的线程无效。</p>
<p>7、Write（）方法调用会阻塞等待，直到最后一个字节成功写入到TCP实现的本地缓存中，如果可用的缓存空间比要写入的数据小，在write（）方法调用返回前，必须把一些数据成功传输到连接的另一端。Java现在还没有提供任何使write（）超时或有其他线程将其打断的方法，所以，如果一个可以在Socket实例上发送大量数据的协议可能会无限期地阻塞下去。</p>
<p>8、有两种类型的一对多服务：广播和多播。对于广播，（本地）网络中的所有主机都会接收到一份数据副本，对于多播，消息只是发送给一个多播地址，网络只是将数据分发给那些表示想要接收发送到该多播地址数据的主机。总的来说，<code>只有UDP套接字允许广播和多播</code>。IPv4的多播地址范围是224.0.0.0到239.255.255.255，IPv6中的多播地址是任何由FF开头的地址。除了少数系统暴露的多播地址外，发送者可以向异常范围内的任何地址发送数据。Java中多播应用程序主要通过MulticastSocket实例进行通信。</p>
<p>9、在TCP Socket通信中，其中一端的read（）方法返回-1表明通信的另一端关闭了套接字，更确切地说，是关闭了套接字所关联的输出流。</p>
<p>NIO</p>
<p>1、NIO主要包括两个部分：java.nio.channles包介绍Selector和Channel抽象，java.nio包介绍Buffer抽象。Selector和Channel抽象的关键点是：一次轮询一组客户端，查找哪个客户端需要服务；Buffer则提供了比Stream抽象更高效和可预测的I&#x2F;O。Channel使用的不是流，正是Buffer缓冲区来发送或读写数据。</p>
<p>2、Buffer抽象代表了一个有限容量的数据容器，其本质是一个数组，由指针指示了在哪存放数据和从哪读取数据。使用Buffer有两个主要的好处：第一，与读写缓冲区数据相关联的系统开销暴露给了程序员，可以由程序员直接控制操作；第二，一些对Java对象的特殊Buffer映射操作能够直接操作底层平台的资源。这些操作节省了在不同地址空间中复制数据的开销——这在现代计算机体系结构中是开销很大的操作。</p>
<p>3、NIO的强大功能部分来自于channel的非阻塞特性。NIO的Channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。在非阻塞式信道上调用一个方法总是会返回。例如，在一个非阻塞式ServerSocketChannel上调用accept（）方法，如果有连接请求在等待，则返回客户端SocketChannel，否则，返回null；read（）方法在没有数据可读时，不会阻塞等待，而是返回0。 在等待连接、读取数据等的时候，线程也可以做其他事情，这便实现了线程的异步操作</p>
<p>4、Selector类的select（）方法会阻塞等待，直到有信道准备好了IO操作，或等待超时，或另一个线程唤醒了它（调用了该选择器的wakeup（）方法）。select（）方法返回的是自上次调用它之后，有多少通道变为就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p>5、我们在用Iterator迭代SelectionKey集合时，每次迭代末尾注意调用remove()方法。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除，以备下次该通道变成就绪时，Selector可以再次将其放入已选择键集中。如果不移除每个处理过的键，它就会在下次调用select（）方法时仍然保留在集合中，而且可能会有无用的操作来调用它。Selector选择器实现了在单个线程中监听多个信道的功能。</p>
<p>6、缓冲区是定长的，不可以扩展容量，ByteBuffer是最常用的缓冲区。缓冲区中各索引值的大小关系：0&#x3D;&lt;mark&#x3D;&lt;position&#x3D;&lt;limit&#x3D;&lt;capacity。</p>
<p>7、allocateDirect（）方法尝试分配直接缓存区，使用直接缓冲区，Java将从平台能够直接进行I&#x2F;O操作的存储空间中为缓冲区分配后援存储空间，但不保证一定能成功，因此在尝试分配直接缓冲区后必须调用isDirect（）方法进行检查，分配和销毁直接缓冲区通常要比分配和销毁非直接缓冲区消耗更多的系统资源。</p>
<p>8、Buffer的clear（）方法并不改变缓冲区中的数据，它只是将position设置为0，并将limit设置为等于capacity，从而使缓冲区准备好从缓冲区的put操作或信道的读操作接收新的数据。flip（）方法用来将缓冲区准备为数据传出状态，这通过将limit设置为position的当前值，再将position的值设为0来实现。Rewind（）方法将position设置为0，并使mark值无效，limit值不变，这样便可以重复传送缓冲区中的数据。compact（）方法将position与limit之间的元素复制到缓冲区的开始位置，从而为后续的read（）&#x2F;put（）操作让出空间，但数据复制是一个非常耗费系统资源的操作，因此要保守地使用compact（）方法。如果调用slice（）方法创建了一个共享了原始缓冲区子序列的新缓冲区，则在先缓冲区上调用array（）方法还是返回整个缓冲数组。</p>
<p>9、对于非阻塞SocketChannel来说，一旦已经调用connect（）方法发起连接，底层套接字可能既不是已经连接，也不是没有连接，而是正在连接。由于底层协议的工作机制，套接字可能会在这个状态一直保持下去，这时候就需要循环地调用finishConnect（）方法来检查是否完成连接，在等待连接的同时，线程也可以做其他事情，这便实现了线程的异步操作。</p>
<p>10、每个选择器都有一组与之关联的信道，一个信道也可以注册多个Selector实例，因此可以有多个关联的SelectionKey实例。任何对key所关联的兴趣操作集的改变，都只在下次调用select（）方法后才会生效。对于serverSocketChannel来说，accept是唯一的有效操作，而对于socketChannel来说，有效操作包括读、写和连接，对于DatagramChannle，只有读写操作是有效的。一个信道可能只与一个选择器注册一次，因此后续对register（）方法的调用只是简单地更新该key所关联的兴趣操作集。</p>
<p>11、 selectedKeys（）方法返回的键集是可修改的，实际上在两次调用select（）方法之间，都必须手动将其清空，换句话说，select（）方法只会在已有的所选键集上添加键，它们不会创建新的建集。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>JVM内存</title>
    <url>/2017/04/25/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/JVM%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h1><blockquote>
<p>在HotSpot实现中，内存被划分成Java堆、方法区、Java栈、本地方法栈和PC寄存器几个部分：<br>1、Java栈和本地方法栈用于方法之间的调用，进栈出栈的过程；<br>2、Java堆用于存放对象，在Java中，所有对象的创建都在堆上申请内存，并被GC管理；<br>3、方法区分成PermGen和CodeCache：PermGen存放Java类的相关信息，如静态变量、成员方法和抽象方法等；CodeCache存放JIT编译之后的本地代码；</p>
</blockquote>
<p>JAVA虚拟机把管理的内存划分为几个不同的数据区。<br><img src="/images/2184951-75502fd0f9001ece.png"></p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><blockquote>
<p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例</p>
</blockquote>
<p>Java虚拟机规范中有这样一段描述：所有的对象实例和数据都要在堆上进行分配。为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有两种方法实现：</p>
<p>1 、指针碰撞法<br>假设Java堆中内存时完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。</p>
<p>2、空闲列表法<br>事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。</p>
<p>对象创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A分配内存，指针或记录还未更新，对象B又同时分配到原来的内存，解决这个问题有两种方案：<br>1、采用CAS保证数据更新操作的原子性；<br>2、把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在Java堆中预先分配一个内存块，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）;</p>
<h2 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h2><blockquote>
<p>Java栈是线程私有的，每个线程对应一个Java栈，每个线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），栈帧负责存储<code>局部变量变量表、操作数栈、动态链接和方法返回地址</code>等信息。<code>每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈过程</code>。</p>
</blockquote>
<p><img src="/images/2184951-a72a68ca4967fdd9.png"></p>
<p>局部变量表<br>用于存放方法参数和方法内部定义的局部变量，其大小在代码编译期间已经确定，在方法运行期间不会改变。局部变量表以变量槽（Slot）为最小存储单位，每个Slot能够存放一个boolean、byte、char、shot、int、float、reference和returnAddress类型的32位数据，对于64位的数据类型long和double，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>在方法执行时，如果是实例方法，即非static方法，局部变量表中第0位Slot默认存放对象实例的引用，在方法中可以通过关键字 this 进行访问，方法参数按照参数列表顺序，从第1位Slot开始分配，方法内部变量则按照定义顺序进行分配其余的Slot。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    public int calc(int a, int b, String operation) &#123;</span><br><span class="line">        operation = &quot;+&quot;;</span><br><span class="line">        return  a + b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void main(String args[]) &#123;</span><br><span class="line">        calc(100, 200, &quot;+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的局部变量表如下：<br><img src="/images/2184951-de41c8e6b7e7a36d.png"></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。<br>运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。</p>
<blockquote>
<p>方法区我理解就是静态区，类中的方法体里编译后的代码也保存在这里<br>方法在执行时，方法体的入口地址和方法的返回地址参数都是存放于栈帧中，静态方法和非静态方法一样，只是非静态方法传入的参数包含this<br>【以上是我个人的理解】</p>
</blockquote>
<h3 id="【引申】java中静态方法和非静态方法的存储"><a href="#【引申】java中静态方法和非静态方法的存储" class="headerlink" title="【引申】java中静态方法和非静态方法的存储"></a>【引申】java中静态方法和非静态方法的存储</h3><p>Java中非静态方法是否共用同一块内存？</p>
<p>将某 class 产生出一个 instance 之后，此 class 所有的 instance field 都会新增一份，那么所有的 instance method 是否也会新增一份？答案是不会，我们用field表示字段，用method表示方法，那么加上static区分后就 有四种：</p>
<p>class field：有用static修饰的field<br>class method：有用static修饰的method<br>instance field：没有用static修饰的field<br>instance method：没有用static修饰的method</p>
<p>那么他们在内存中的表示为：</p>
<p>class field：共用一块记忆体<br>class method：共用一块记忆体<br>instance field：随着每个instance各有一块记忆体<br>instance method：共用一块记忆体</p>
<p>如果instance method也随着instance增加而增加的话，那内存消耗也太大了，为了做到共用一小段内存，Java是根据this关键字做到的<br>比如：instance1.instanceMethod(); instance2.instanceMethod(); 在传递给对象参数的时候，Java编译器自动先加上了一个this参数，它表示传递的是这个对象引用，虽然他们两个对象共用一个方法，但是他们的方法中所产生的数据是私有的，这是因为参数被传进来变成call stack内的entry，而各个对象都有不同call stack，所以不会混淆。其实调用每个非static方法时，Java编译器都会自动的先加上当前调用此方法对象的参数，有时候在一个方法调用另一个方法，这时可以不用在前面加上this的，因为要传递的对象参数就是当前执行这个方法的对象。</p>
<p>为什么静态方法中不能调用非静态方法？这是因为静态方法直接跟class相关，调用此方法的时候是类直接调用的，而不是对象，所以Java编译器就没有对象参数可以传递，这样，如果你在静态方法内部调用非静态方法，那么Java编译器怎么判断这个非静态方法是哪个对象调用的？对吧，所以Java编译器就会报错，但是也不是绝对的，Java编译器是隐式的传递对象参数，那么我们总可以显示的传递对象参数吧，如果我们把某个对象的引用传递到static方法里，然后通过这个引用就可以调用非静态方法和访问非静态数据成员了。</p>
<h2 id="指令计数器"><a href="#指令计数器" class="headerlink" title="指令计数器"></a>指令计数器</h2><p>指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码指令的地址，分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成。如果线程执行的是native方法，这个计数器则为空。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中布局可以分成三块区域：<code>对象头、实例数据和对齐填充</code>。<br>1、对象头<br>对象头包括两部分信息：<code>运行时数据和类型指针</code>，如果对象是一个数组，还需要一块用于记录数组长度的数据。</p>
<p>1.1、运行时数据包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向锁ID和偏向时间戳等，这部分数据在32位和64位虚拟机中的长度分别为32bit和64bit，官方称为”Mark Word”。Mark Word被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的数据。<br>32位的虚拟机中，对象未被锁定的状态下，Mark Word的32bit中25bit存储对象的HashCode、4bit存储对象分代年龄、2bit存储锁标志位、1bit固定为0，具体如下：<br><img src="/images/2184951-5718ab305b056d54.png"></p>
<p>其它状态（轻量级锁定、重量级锁定、GC锁定、可偏向锁）下Mark Word的存储内容如下：<br><img src="/images/2184951-3e3fb6dc3ec8253c.png"></p>
<p>1.2、对象头的类型指针指向该对象的类元数据，<code>虚拟机通过这个指针可以确定该对象是哪个类的实例</code>。</p>
<p>2、实例数据<br>实例数据就是在程序代码中所定义的各种类型的字段，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中定义顺序的影响。</p>
<p>3、对齐填充<br>由于HotSpot的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，所以当实例数据不够8字节整数倍时，需要通过对齐填充进行补全。</p>
<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>堆中存放new出来的java对象的field数据<br>栈存放方法体的地址和方法的参数，方法内部的局部变量和方法返回值等临时数据<br>方法区存放类中的static field数据以及方法体编译后的代码，可以理解为一个常量池</p>
<h1 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</p>
<blockquote>
<p>类加载可以理解为：在堆中开辟一段内存空间指向方法区保存的类的常量数据，以后通过访问堆中的JAVA.LANG.CLASS访问方法区的常量（static field 、method）</p>
</blockquote>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类加载的过程包括了<code>加载、验证、准备、解析、初始化</code>五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><blockquote>
<p>在方法区和堆中分配内存，为后续赋值做准备</p>
</blockquote>
<p>1、通过一个类的全限定名来获取其定义的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><blockquote>
<p>方法区常量赋默认值，并关联堆中的CLASS</p>
</blockquote>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote>
<p>确保被加载的类的正确性</p>
</blockquote>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br><code>如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</code>。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote>
<p>正式为类变量分配内存并设置类变量初始值</p>
</blockquote>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在<code>方法区</code>中分配。对于该阶段有以下几点需要注意：<br>i、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。<br>ii、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：public static int value &#x3D; 3；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，<code>所以把value赋值为3的动作将在初始化阶段才会执行</code>。</p>
<p>这里还需要注意如下几点：<br>被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。<br>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。<br>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br><code>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值</code>。</p>
<p>假设上面的类变量value被定义为： public static final int value &#x3D; 3；<br>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote>
<p>关联CLASS堆和方法区的常量</p>
</blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<blockquote>
<p>目标就是堆中的JAVA.LANG.CLASS，即类在堆中的内存空间</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：<br>①声明类变量时指定初始值<br>②使用静态代码块为类变量指定初始值</p>
<p>JVM初始化步骤<br>1、假如这个类还没有被加载和连接，则程序先加载并连接该类<br>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类<br>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：<br>– 创建类的实例，也就是new的方式<br>– 访问某个类或接口的静态变量，或者对该静态变量赋值<br>– 调用类的静态方法<br>– 反射（如Class.forName(“com.shengsiyuan.Test”)）<br>– 初始化某个类的子类，则其父类也会被初始化<br>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p>
<p>在如下几种情况下，Java虚拟机将结束生命周期<br>– 执行了System.exit()方法<br>– 程序正常执行结束<br>– 程序在执行过程中遇到了异常或错误而异常终止<br>– 由于操作系统出现错误而导致Java虚拟机进程终止</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p>启动类加载器：<br>Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，<code>所有的java.*开头的类均被Bootstrap ClassLoader加载</code>）。启动类加载器是无法被Java程序直接引用的。</p>
<p>扩展类加载器：<br>Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如<code>javax.*开头的类</code>），开发者可以直接使用扩展类加载器。</p>
<p>应用程序类加载器：<br>Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径<code>（ClassPath）所指定的类</code>，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>JVM类加载机制</p>
<ul>
<li><p>全盘负责<br>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
</li>
<li><p>父类委托<br>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
</li>
</ul>
<p>双亲委派机制:<br>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
<ul>
<li>缓存机制<br>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><p>类加载有三种方式：<br>1、命令行启动应用时候由JVM初始化加载<br>2、通过Class.forName()方法动态加载<br>3、通过ClassLoader.loadClass()方法动态加载</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>Linux磁盘分区，目录树，文件系统的关系</title>
    <url>/2017/06/01/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%8C%E7%9B%AE%E5%BD%95%E6%A0%91%EF%BC%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><p>首先要明白的是磁盘为什么要分区。</p>
<p>一是从数据安全方面考虑，二是从系统访问磁盘的性能考虑。一个磁盘的某个分区损坏，不在该分区的数据将不会受到影响，这样就能够有效地保护不同业务的数据。过大的磁盘分区在系统进行读写的时候，会降低系统的读写性能，分区能够加速对某个分区数据的访问速度。就如同我们在C盘搜索文件的时候，会遍寻真个磁盘分区，但是当这个分区过大的时候，这个搜索时间会持续很久。</p>
<p>所以，一般来说。当服务器的配置中有未分区的磁盘设备时，安装磁盘之后，首先进行的是磁盘分区。</p>
<p>分区之后，也就是把整个磁盘分成了几份独立的磁盘。在这几个磁盘分区上的数据都是独立的。因此，能够在不同分区上创建不同的文件系统，而不会影响到别的分区的文件。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>操作系统的概念大家都知道，就是管理计算机硬件和软件资源的系统程序，偏底层。那么作为计算机上最重要的资源，数据和文件，该以什么样的方式进行组织和管理呢？</p>
<p>这就需要文件系统。文件系统是组织和管理数据和文件的操作系统。</p>
<p>文件系统不是计算机操作系统的一部分，因为没有哪一种文件系统专属哪一种操作系统。文件系统针对的对象只是文件，而不是计算机。</p>
<p>文件系统是计算机操作系统的一部分，因为没有哪一种操作系统不需要文件的，需要文件就需要文件系统来进行操作。</p>
<p>基于对文件的不同组织和管理方式，存在着很多文件系统可以选用。</p>
<p>在实际的学习和生产环境当中，有基本的文件系统，有日志型型的文件系统，数据库型的文件系统，网络文件系统，和分布式的文件系统等。</p>
<p>这些文件系统存在的意义，也就是解决实际生产过程中数据或者文件的特定问题，比如文件访问的位置，文件的属性，读写的快慢，文件的数量巨大和分散等，都需要文件系统进行组织和管理。</p>
<p>Linux系统能够支持很多种类型的文件系统，在实际生产过程中，选用合适的文件系统，对存在于磁盘上的文件访问有着关键性的作用。</p>
<p>总之，文件系统是组织文件或者数据的一种方式。</p>
<h1 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h1><p>不同于win系统的是，Linux系统通过目录树，这种文件结构来进行文件的操作。目录树最关键的是根目录，访问某个目录下的文件时，也是从根目录开始起步的。因此，若能够通过目录树访问文件，则根目录必须有个着脚的地。</p>
<p>设想这样一种场景：目录树是存在于内存的文件结构，通过目录树来访问某个磁盘该怎么办？那就需要把磁盘挂载到根目录或者根目录某个目录下。这样就可以通过目录进入到磁盘挂载的那个目录下，访问目录下的文件，就是访问这块磁盘数据。</p>
<p>所以，在系统启动后，根目录是必须挂载的，也就是必须有一块磁盘能够存放根目录。这个过程通常是自动挂载的。</p>
<h1 id="磁盘分区，文件系统，目录树三者之间的关系"><a href="#磁盘分区，文件系统，目录树三者之间的关系" class="headerlink" title="磁盘分区，文件系统，目录树三者之间的关系"></a>磁盘分区，文件系统，目录树三者之间的关系</h1><p>这个时候应该了解三者的关系了。</p>
<p>假如我有一个磁盘分区，磁盘上面有数据，那么我怎么让Linux系统访问这些数据呢？</p>
<p>答案当然是，在这块磁盘分区上创建Linux支持的文件系统。假如创建了FAT格式的文件系统，这个时候磁盘分区是有文件系统的，磁盘分区能够被win系统支持并读取里面的数据，但是不能够被Linux读取。</p>
<p>假如，我这块磁盘分区有Linux支持的文件系统，那么Linux该如何读取它呢？</p>
<p>答案是挂载。挂载的意思就是把磁盘挂载到某个目录下。以便Linux系统能够进入磁盘分区。</p>
<p>如果这个时候，磁盘没有文件系统，或者有Linux不支持的文件系统，那么Linux也无法读取磁盘数据。</p>
<p>总结一下就是：</p>
<p>我要读取某块磁盘分区的数据，首先得将其格式化我系统能够支持的文件系统，这样的话它上面的数据我就能够识别了；然后我得把它挂到我的系统上，这样我就能进入了；那么我怎么进入呢？就是通过挂载点——磁盘分区挂载的那个目录，进入那个目录，也就进入了那个磁盘分区了，也能够通过文件系统识别和管理数据了。</p>
<p>—————————————————————————————————PL的分割线———————————————————————————————————————</p>
<p>如此简单的概念和关系，我尽然很久很久没有搞懂。</p>
<p>其实在这个过程中，需要注意的是：</p>
<p>1，为什么要分区</p>
<p>2，为什么要格式化</p>
<p>3，为什么要挂载</p>
<p>三步解决所有问题，当然一个mount命令及其选项告知你每秒的这一切</p>
<p>mount 挂载点 文件系统类型 文件系统类型的选项 挂载设备</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>SSL协议运行机制概述</title>
    <url>/2017/05/21/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/SSL%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>互联网的通信安全，建立在SSL&#x2F;TLS协议之上。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>不使用SSL&#x2F;TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<p>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>SSL&#x2F;TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<p>（1） 所有信息都是加密传播，第三方无法窃听。<br>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。<br>（3） 配备身份证书，防止身份被冒充。</p>
<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。<br>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>
<blockquote>
<p>TLS和SSL协议的作用类似</p>
</blockquote>
<h1 id="基本的运行过程"><a href="#基本的运行过程" class="headerlink" title="基本的运行过程"></a>基本的运行过程</h1><p>SSL&#x2F;TLS协议的基本思路是采用<code>公钥加密法</code>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<br>但是，这里有两个问题。</p>
<p>（1）如何保证公钥不被篡改？<br>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）公钥加密计算量太大，如何减少耗用的时间？<br>解决方法：每一次对话（session），客户端和服务器端都生成一个<code>对话密钥</code>（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
<p>因此，SSL&#x2F;TLS协议的基本过程是这样的：</p>
<p>（1） 客户端向服务器端索要并验证公钥。<br>（2） 双方协商生成”对话密钥”。<br>（3） 双方采用”对话密钥”进行加密通信。</p>
<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h1 id="握手阶段的详细过程"><a href="#握手阶段的详细过程" class="headerlink" title="握手阶段的详细过程"></a>握手阶段的详细过程</h1><h2 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h2><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。<br>在这一步，客户端主要向服务器提供以下信息。</p>
<p>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p>
<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。<br>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p>
<h2 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h2><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。<br>（3） 确认使用的加密方法，比如RSA公钥加密。<br>（4） 服务器证书。</p>
<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h2 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h2><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<h2 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h2><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>ssh原理与运用</title>
    <url>/2017/05/14/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h1 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h1><blockquote>
<p>简单说，SSH是一种网络协议，用于计算机之间的<code>加密登录</code>。</p>
</blockquote>
<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>
<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p>
<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</p>
<p>此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p>
<h1 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h1><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。<br><code>$ ssh user@host</code></p>
<p>如果本地用户名与远程用户名一致，登录时可以省略用户名。<br><code>$ ssh host</code></p>
<p>SSH的默认端口是<code>22</code>，也就是说，你的登录请求会送进远程主机的22端口。<code>使用p参数，可以修改这个端口</code>。<br><code>$ ssh -p 2222 user@host</code></p>
<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>
<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>
<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p>
<h1 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h1><p>如果你是第一次登录对方主机，系统会出现下面的提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">　　The authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.</span><br><span class="line">　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p>
<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p>
<p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br><code>Are you sure you want to continue connecting (yes/no)? yes</code></p>
<p>系统会出现一句提示，表示host主机已经得到认可。<br><code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code></p>
<p>然后，会要求输入密码。<br><code>Password: (enter password)</code></p>
<p>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME&#x2F;.ssh&#x2F;known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是&#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>
<h1 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h1><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以<code>省去输入密码的步骤</code>。</p>
<p>所谓”公钥登录”，原理很简单，就是用户<code>将自己的公钥储存在远程主机上</code>。</p>
<blockquote>
<p>登录的时候，远程主机会向用户发送一段随机字符串，<code>用户用自己的私钥加密后</code>，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
</blockquote>
<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：<br><code>$ ssh-keygen</code></p>
<p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p>
<p>运行结束以后，在$HOME&#x2F;.ssh&#x2F;目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p>
<p>这时再输入下面的命令，将公钥传送到远程主机host上面：<br><code>$ ssh-copy-id user@host</code></p>
<p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的&#x2F;etc&#x2F;ssh&#x2F;sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">　　PubkeyAuthentication yes</span><br><span class="line">　　AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>然后，重启远程主机的ssh服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ubuntu系统</span><br><span class="line">　　service ssh restart</span><br><span class="line">　　// debian系统</span><br><span class="line">　　/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure>

<h1 id="authorized-keys文件"><a href="#authorized-keys文件" class="headerlink" title="authorized_keys文件"></a>authorized_keys文件</h1><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME&#x2F;.ssh&#x2F;authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>
<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：<br><code>$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></p>
<p>这条命令由多个语句组成，依次分解开来看：<br>（1）”$ ssh user@host”，表示登录远程主机；<br>（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh&#x2F;authorized_keys，表示登录后在远程shell上执行的命令：<br>（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；<br>（4）’cat &gt;&gt; .ssh&#x2F;authorized_keys’ &lt; <del>&#x2F;.ssh&#x2F;id_rsa.pub的作用是，将本地的公钥文件</del>&#x2F;.ssh&#x2F;id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p>
<h1 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h1><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。</p>
<p>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：<br><code>$ ssh -D 8080 user@host</code></p>
<p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p>
<h1 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h1><blockquote>
<p>本地端口转发使得本地端口的数据借助指定ip转发到目的ip端口上</p>
</blockquote>
<p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。</p>
<p>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。</p>
<p>我们在host1执行下面的命令：<br><code>$ ssh -L 2121:host2:21 host3</code></p>
<p>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。</p>
<p>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。</p>
<p>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。</p>
<h1 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h1><blockquote>
<p>远程端口转发指定远程ip和端口，使得发往远程端口的数据发到本地端口</p>
</blockquote>
<p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。</p>
<p>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？</p>
<p>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。</p>
<p>我们在host3执行下面的命令：<br><code>$ ssh -R 2121:host2:21 host1</code></p>
<p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有发往该端口的数据转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。</p>
<p>绑定之后，我们在host1就可以连接host2了 </p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>vlan原理详解</title>
    <url>/2017/05/08/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/vlan%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>vlan实现对二层交换机的<code>端口</code>做逻辑上的划分，将交换机中的端口划分为逻辑上的不同<code>广播域</code></p>
</blockquote>
<h1 id="为什么需要VLAN"><a href="#为什么需要VLAN" class="headerlink" title="为什么需要VLAN"></a>为什么需要VLAN</h1><h2 id="什么是VLAN？"><a href="#什么是VLAN？" class="headerlink" title="什么是VLAN？"></a>什么是VLAN？</h2><p>VLAN（Virtual LAN），翻译成中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。<br>在此让我们先复习一下广播域的概念。广播域，指的是广播帧（目标MAC地址全部为1）所能传递到的范围，亦即能够直接通信的范围。严格地说，并不仅仅是广播帧，多播帧（Multicast Frame）和目标不明的单播帧（Unknown Unicast Frame）也能在同一个广播域中畅行无阻。</p>
<blockquote>
<p>本来，二层交换机只能构建单一的广播域，不过使用VLAN功能后，它能够将网络分割成多个广播域。</p>
</blockquote>
<h2 id="未分割广播域时……"><a href="#未分割广播域时……" class="headerlink" title="未分割广播域时……"></a>未分割广播域时……</h2><p>那么，为什么需要分割广播域呢？那是因为，如果仅有一个广播域，有可能会影响到网络整体的传输性能。具体原因，请参看附图加深理解。<br><img src="/images/20130726174341921.png"></p>
<p>图中，是一个由5台二层交换机（交换机1～5）连接了大量客户机构成的网络。假设这时，计算机A需要与计算机B通信。在基于以太网的通信中，必须在数据帧中指定目标MAC地址才能正常通信</p>
<blockquote>
<p>因此计算机A必须先广播“ARP请求（ARP Request）信息”，来尝试获取计算机B的MAC地址。</p>
</blockquote>
<p>交换机1收到广播帧（ARP请求）后，会将它转发给除接收端口外的其他所有端口，也就是Flooding了。接着，交换机2收到广播帧后也会Flooding。交换机3、4、5也还会Flooding。</p>
<blockquote>
<p>最终ARP请求会被转发到同一网络中的所有客户机上。</p>
</blockquote>
<p><img src="/images/20130726174436734.png"></p>
<p>请大家注意一下，这个ARP请求原本是为了获得计算机B的MAC地址而发出的。也就是说：只要计算机B能收到就万事大吉了。可是事实上，数据帧却传遍整个网络，导致所有的计算机都收到了它。如此一来，一方面广播信息消耗了网络整体的带宽，另一方面，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。</p>
<blockquote>
<p>造成了网络带宽和CPU运算能力的大量无谓消耗。</p>
</blockquote>
<h2 id="广播信息是那么经常发出的吗？"><a href="#广播信息是那么经常发出的吗？" class="headerlink" title="广播信息是那么经常发出的吗？"></a>广播信息是那么经常发出的吗？</h2><p>读到这里，您也许会问：广播信息真是那么频繁出现的吗？<br>答案是：是的！实际上广播帧会非常频繁地出现。利用TCP&#x2F;IP协议栈通信时，除了前面出现的ARP外，还有可能需要发出DHCP、RIP等很多其他类型的广播信息。<br>ARP广播，是在需要与其他主机通信时发出的。当客户机请求DHCP服务器分配IP地址时，就必须发出DHCP的广播。而使用RIP作为路由协议时，每隔30秒路由器都会对邻近的其他路由器广播一次路由信息。RIP以外的其他路由协议使用多播传输路由信息，这也会被交换机转发（Flooding）。除了TCP&#x2F;IP以外，NetBEUI、IPX和Apple Talk等协议也经常需要用到广播。例如在Windows下双击打开“网络计算机”时就会发出广播（多播）信息。（Windows XP除外……）<br>总之，广播就在我们身边。下面是一些常见的广播通信：<br>（1）ARP请求：建立IP地址和MAC地址的映射关系。<br>（2）RIP：一种路由协议。<br>（3）DHCP：用于自动设定IP地址的协议。<br>（4）NetBEUI：Windows下使用的网络协议。<br>（5）IPX：NovellNetware使用的网络协议。<br>（6）Apple Talk：苹果公司的Macintosh计算机使用的网络协议。<br>如果整个网络只有一个广播域，那么一旦发出广播信息，就会传遍整个网络，并且对网络中的主机带来额外的负担。因此，在设计LAN时，需要注意如何才能有效地分割广播域。</p>
<h2 id="广播域的分割与VLAN的必要性"><a href="#广播域的分割与VLAN的必要性" class="headerlink" title="广播域的分割与VLAN的必要性"></a>广播域的分割与VLAN的必要性</h2><p>分割广播域时，一般都必须使用到路由器。使用路由器后，可以以路由器上的网络接口（LAN Interface）为单位分割广播域。<br>但是，通常情况下路由器上不会有太多的网络接口，其数目多在1～4个左右。随着宽带连接的普及，宽带路由器（或者叫IP共享器）变得较为常见，但是需要注意的是，它们上面虽然带着多个（一般为4个左右）连接LAN一侧的网络接口，但那实际上是路由器内置的交换机，并不能分割广播域。<br>况且使用路由器分割广播域的话，所能分割的个数完全取决于路由器的网络接口个数，使得用户无法自由地根据实际需要分割广播域。<br>与路由器相比，二层交换机一般带有多个网络接口。因此如果能使用它分割广播域，那么无疑运用上的灵活性会大大提高。</p>
<blockquote>
<p>用于在二层交换机上分割广播域的技术，就是VLAN。通过利用VLAN，我们可以自由设计广播域的构成，提高网络设计的自由度。</p>
</blockquote>
<h1 id="实现VLAN的机制"><a href="#实现VLAN的机制" class="headerlink" title="实现VLAN的机制"></a>实现VLAN的机制</h1><h2 id="实现VLAN的机制-1"><a href="#实现VLAN的机制-1" class="headerlink" title="实现VLAN的机制"></a>实现VLAN的机制</h2><p>在理解了“为什么需要VLAN”之后，接下来让我们来了解一下交换机是如何使用VLAN分割广播域的。<br>首先，在一台未设置任何VLAN的二层交换机上，任何广播帧都会被转发给除接收端口外的所有其他端口（Flooding）。例如，计算机A发送广播信息后，会被转发给端口2、3、4。<br><img src="/images/20130726174726312.png"></p>
<p>这时，如果在交换机上生成红、蓝两个VLAN；同时设置端口1、2属于红色VLAN、端口3、4属于蓝色VLAN。再从A发出广播帧的话，交换机就只会把它转发给同属于一个VLAN的其他端口——也就是同属于红色VLAN的端口2，不会再转发给属于蓝色VLAN的端口。<br>同样，C发送广播信息时，只会被转发给其他属于蓝色VLAN的端口，不会被转发给属于红色VLAN的端口。<br><img src="/images/20130726174753812.png"></p>
<p>就这样，VLAN通过限制广播帧转发的范围分割了广播域。上图中为了便于说明，以红、蓝两色识别不同的VLAN，在实际使用中则是用“VLAN ID”来区分的。</p>
<h2 id="直观地描述VLAN"><a href="#直观地描述VLAN" class="headerlink" title="直观地描述VLAN"></a>直观地描述VLAN</h2><p>如果要更为直观地描述VLAN的话，我们可以把它理解为将一台交换机在逻辑上分割成了数台交换机。在一台交换机上生成红、蓝两个VLAN，也可以看作是将一台交换机换做一红一蓝两台虚拟的交换机。<br><img src="/images/20130726174827609.png"></p>
<p>在红、蓝两个VLAN之外生成新的VLAN时，可以想象成又添加了新的交换机。<br>但是，VLAN生成的逻辑上的交换机是互不相通的。因此，在交换机上设置VLAN后，如果未做其他处理，VLAN间是无法通信的。<br>明明接在同一台交换机上，但却偏偏无法通信——这个事实也许让人难以接受。但它既是VLAN方便易用的特征，又是使VLAN令人难以理解的原因。</p>
<h2 id="需要VLAN间通信时怎么办"><a href="#需要VLAN间通信时怎么办" class="headerlink" title="需要VLAN间通信时怎么办"></a>需要VLAN间通信时怎么办</h2><p>那么，当我们需要在不同的VLAN间通信时又该如何是好呢？<br>请大家再次回忆一下：VLAN是广播域。而通常两个广播域之间由路由器连接，广播域之间来往的数据包都是由路由器中继的。因此，VLAN间的通信也需要路由器提供中继服务，这被称作“VLAN间路由”。<br>VLAN间路由，可以使用普通的路由器，也可以使用三层交换机。其中的具体内容，等有机会再细说吧。在这里希望大家先记住不同VLAN间互相通信时需要用到路由功能。</p>
<h1 id="VLAN的访问链接（Access-Link）"><a href="#VLAN的访问链接（Access-Link）" class="headerlink" title="VLAN的访问链接（Access Link）"></a>VLAN的访问链接（Access Link）</h1><h2 id="交换机的端口类型"><a href="#交换机的端口类型" class="headerlink" title="交换机的端口类型"></a>交换机的端口类型</h2><p>交换机的端口，可以分为以下两种：<br>（1）访问链接（Access Link）<br>（2）汇聚链接（Trunk Link）<br>接下来就让我们来依次学习这两种不同端口的特征。这一讲，首先学习“访问链接”。</p>
<h2 id="访问链接"><a href="#访问链接" class="headerlink" title="访问链接"></a>访问链接</h2><p>访问链接，指的是“只属于一个VLAN，且仅向该VLAN转发数据帧”的端口。</p>
<blockquote>
<p>在大多数情况下，访问链接所连的是客户机。</p>
</blockquote>
<p>通常设置VLAN的顺序是：<br>（1）生成VLAN<br>（2）设定访问链接（决定各端口属于哪一个VLAN）<br>设定访问链接的手法，可以是事先固定的、也可以是根据所连的计算机而动态改变设定。前者被称为“静态VLAN”、后者自然就是“动态VLAN”了。</p>
<h3 id="静态VLAN——基于端口"><a href="#静态VLAN——基于端口" class="headerlink" title="静态VLAN——基于端口"></a>静态VLAN——基于端口</h3><p>静态VLAN又被称为基于端口的VLAN（PortBased VLAN）。顾名思义，就是明确指定各端口属于哪个VLAN的设定方法。<br><img src="/images/20130726174909406.png"></p>
<p>由于需要一个个端口地指定，因此当网络中的计算机数目超过一定数字（比如数百台）后，设定操作就会变得烦杂无比。并且，客户机每次变更所连端口，都必须同时更改该端口所属VLAN的设定——这显然不适合那些需要频繁改变拓补结构的网络。</p>
<h3 id="动态VLAN"><a href="#动态VLAN" class="headerlink" title="动态VLAN"></a>动态VLAN</h3><p>另一方面，动态VLAN则是根据每个端口所连的计算机，随时改变端口所属的VLAN。这就可以避免上述的更改设定之类的操作。动态VLAN可以大致分为3类：<br>（1）基于MAC地址的VLAN（MAC Based VLAN）<br>（2）基于子网的VLAN（Subnet Based VLAN）<br>（3）基于用户的VLAN（User Based VLAN）<br>其间的差异，主要在于根据OSI参照模型哪一层的信息决定端口所属的VLAN。</p>
<h4 id="基于MAC地址的VLAN"><a href="#基于MAC地址的VLAN" class="headerlink" title="基于MAC地址的VLAN"></a>基于MAC地址的VLAN</h4><p>基于MAC地址的VLAN，就是通过查询并记录端口所连计算机上网卡的MAC地址来决定端口的所属。假定有一个MAC地址“A”被交换机设定为属于VLAN “10”，那么不论MAC地址为“A”的这台计算机连在交换机哪个端口，该端口都会被划分到VLAN 10中去。计算机连在端口1时，端口1属于VLAN 10；而计算机连在端口2时，则是端口2属于VLAN 10。<br><img src="/images/20130726174941218.png"></p>
<p>由于是基于MAC地址决定所属VLAN的，因此可以理解为这是一种在OSI的第二层设定访问链接的办法。<br>但是，基于MAC地址的VLAN，在设定时必须调查所连接的所有计算机的MAC地址并加以登录。而且如果计算机交换了网卡，还是需要更改设定。</p>
<h4 id="基于IP地址的VLAN"><a href="#基于IP地址的VLAN" class="headerlink" title="基于IP地址的VLAN"></a>基于IP地址的VLAN</h4><p>基于子网的VLAN，则是通过所连计算机的IP地址，来决定端口所属VLAN的。不像基于MAC地址的VLAN，即使计算机因为交换了网卡或是其他原因导致MAC地址改变，只要它的IP地址不变，就仍可以加入原先设定的VLAN。<br><img src="/images/20130726175015406.png"></p>
<p>因此，与基于MAC地址的VLAN相比，能够更为简便地改变网络结构。IP地址是OSI参照模型中第三层的信息，所以我们可以理解为基于子网的VLAN是一种在OSI的第三层设定访问链接的方法。<br>基于用户的VLAN，则是根据交换机各端口所连的计算机上当前登录的用户，来决定该端口属于哪个VLAN。这里的用户识别信息，一般是计算机操作系统登录的用户，比如可以是Windows域中使用的用户名。这些用户名信息，属于OSI第四层以上的信息。<br>总的来说，决定端口所属VLAN时利用的信息在OSI中的层面越高，就越适于构建灵活多变的网络。</p>
<h1 id="VLAN的汇聚链接（Trunk-Link）"><a href="#VLAN的汇聚链接（Trunk-Link）" class="headerlink" title="VLAN的汇聚链接（Trunk Link）"></a>VLAN的汇聚链接（Trunk Link）</h1><h2 id="需要设置跨越多台交换机的VLAN时……"><a href="#需要设置跨越多台交换机的VLAN时……" class="headerlink" title="需要设置跨越多台交换机的VLAN时……"></a>需要设置跨越多台交换机的VLAN时……</h2><p>到此为止，我们学习的都是使用单台交换机设置VLAN时的情况。那么，如果需要设置跨越多台交换机的VLAN时又如何呢？<br>在规划企业级网络时，很有可能会遇到隶属于同一部门的用户分散在同一座建筑物中的不同楼层的情况，这时可能就需要考虑到如何跨越多台交换机设置VLAN的问题了。假设有如下图所示的网络，且需要将不同楼层的A、C和B、D设置为同一个VLAN。<br><img src="/images/20130726175059421.png"></p>
<p>这时最关键的就是“交换机1和交换机2该如何连接才好呢？”<br>最简单的方法，自然是在交换机1和交换机2上各设一个红、蓝VLAN专用的接口并互联了。<br><img src="/images/20130726175129312.png"></p>
<p>但是，这个办法从扩展性和管理效率来看都不好。例如，在现有网络基础上再新建VLAN时，为了让这个VLAN能够互通，就需要在交换机间连接新的网线。建筑物楼层间的纵向布线是比较麻烦的，一般不能由基层管理人员随意进行。并且，VLAN越多，楼层间（严格地说是交换机间）互联所需的端口也越来越多，交换机端口的利用效率低是对资源的一种浪费、也限制了网络的扩展。<br>为了避免这种低效率的连接方式，人们想办法让交换机间互联的网线集中到一根上，这时使用的就是汇聚链接（Trunk Link）。</p>
<h2 id="何谓汇聚链接？"><a href="#何谓汇聚链接？" class="headerlink" title="何谓汇聚链接？"></a>何谓汇聚链接？</h2><blockquote>
<p>汇聚链接（Trunk Link）指的是能够转发多个不同VLAN的通信的端口。<br>汇聚链路上流通的数据帧，都被附加了用于识别分属于哪个VLAN的特殊信息。</p>
</blockquote>
<p>现在再让我们回过头来考虑一下刚才那个网络如果采用汇聚链路又会如何呢？用户只需要简单地将交换机间互联的端口设定为汇聚链接就可以了。这时使用的网线还是普通的UTP线，而不是什么其他的特殊布线。图例中是交换机间互联，因此需要用交叉线来连接。</p>
<p>接下来，让我们具体看看汇聚链接是如何实现跨越交换机间的VLAN的。<br>A发送的数据帧从交换机1经过汇聚链路到达交换机2时，在数据帧上附加了表示属于红色VLAN的标记。<br>交换机2收到数据帧后，经过检查VLAN标识发现这个数据帧是属于红色VLAN的，因此去除标记后根据需要将复原的数据帧只转发给其他属于红色VLAN的端口。这时的转送，是指经过确认目标MAC地址并与MAC地址列表比对后只转发给目标MAC地址所连的端口。只有当数据帧是一个广播帧、多播帧或是目标不明的帧时，它才会被转发到所有属于红色VLAN的端口。<br>蓝色VLAN发送数据帧时的情形也与此相同。<br><img src="/images/20130726175217593.png"></p>
<p>通过汇聚链路时附加的VLAN识别信息，有可能支持标准的“IEEE 802.1Q”协议，也可能是Cisco产品独有的“ISL（Inter Switch Link）”。如果交换机支持这些规格，那么用户就能够高效率地构筑横跨多台交换机的VLAN。<br>另外，汇聚链路上流通着多个VLAN的数据，自然负载较重。因此，在设定汇聚链接时，有一个前提就是必须支持100Mbps以上的传输速度。<br>另外，默认条件下，汇聚链接会转发交换机上存在的所有VLAN的数据。换一个角度看，可以认为汇聚链接（端口）同时属于交换机上所有的VLAN。由于实际应用中很可能并不需要转发所有VLAN的数据，因此为了减轻交换机的负载、也为了减少对带宽的浪费，我们可以通过用户设定限制能够经由汇聚链路互联的VLAN。</p>
<p>综上所述，设定访问链接的手法有静态VLAN和动态VLAN两种，其中动态VLAN又可以继续细分成几个小类。<br>其中基于子网的VLAN和基于用户的VLAN有可能是网络设备厂商使用独有的协议实现的，不同厂商的设备之间互联有可能出现兼容性问题；因此在选择交换机时，一定要注意事先确认。</p>
<h1 id="VLAN的汇聚方式——IEEE802-1Q与ISL"><a href="#VLAN的汇聚方式——IEEE802-1Q与ISL" class="headerlink" title="VLAN的汇聚方式——IEEE802.1Q与ISL"></a>VLAN的汇聚方式——IEEE802.1Q与ISL</h1><h2 id="汇聚方式"><a href="#汇聚方式" class="headerlink" title="汇聚方式"></a>汇聚方式</h2><p>在交换机的汇聚链接上，可以通过对数据帧附加VLAN信息，构建跨越多台交换机的VLAN。<br>附加VLAN信息的方法，最具有代表性的有：<br>（1）IEEE 802.1Q<br>（2）ISL<br>现在就让我们看看这两种协议分别如何对数据帧附加VLAN信息。</p>
<h2 id="IEEE-802-1Q"><a href="#IEEE-802-1Q" class="headerlink" title="IEEE 802.1Q"></a>IEEE 802.1Q</h2><p>IEEE 802.1Q，俗称“Dot One Q”，是经过IEEE认证的对数据帧附加VLAN识别信息的协议。<br>在此，请大家先回忆一下以太网数据帧的标准格式。<br>IEEE 802.1Q所附加的VLAN识别信息，位于数据帧中“发送源MAC地址”与“类别域”（Type Field）之间。具体内容为2字节的TPID（Tag Protocol IDentifier）和2字节的TCI（Tag Control Information），共计4字节。<br>在数据帧中添加了4字节的内容，那么CRC值自然也会有所变化。这时数据帧上的CRC是插入TPID、TCI后，对包括它们在内的整个数据帧重新计算后所得的值。<br><img src="/images/20130726175307937.png"></p>
<p>而当数据帧离开汇聚链路时，TPID和TCI会被去除，这时还会进行一次CRC的重新计算。<br>TPID字段在以太网报文中所处位置与不带VLAN Tag的报文中协议类型字段所处位置相同。<code>TPID的值固定为0x8100，它标示网络帧承载的802.1Q类型，交换机通过它来确定数据帧内附加了基于IEEE 802.1Q的VLAN信息</code>。</p>
<blockquote>
<p>而实质上的VLAN ID，是TCI中的12位元。由于总共有12位，因此最多可供识别4096个VLAN。</p>
</blockquote>
<p>基于IEEE 802.1Q附加的VLAN信息，就像在传递物品时附加的标签。因此，它也被称作“标签型VLAN”（Tagging VLAN）。</p>
<h2 id="ISL（Inter-Switch-Link）"><a href="#ISL（Inter-Switch-Link）" class="headerlink" title="ISL（Inter Switch Link）"></a>ISL（Inter Switch Link）</h2><p>ISL，是Cisco产品支持的一种与IEEE 802.1Q类似的、用于在汇聚链路上附加VLAN信息的协议。<br>使用ISL后，每个数据帧头部都会被附加26字节的“ISL包头（ISL Header）”，并且在帧尾带上通过对包括ISL包头在内的整个数据帧进行计算后得到的4字节CRC值。换而言之，就是总共增加了30字节的信息。<br>在使用ISL的环境下，当数据帧离开汇聚链路时，只要简单地去除ISL包头和新CRC就可以了。由于原先的数据帧及其CRC都被完整保留，因此无需重新计算CRC。<br><img src="/images/20130726175338265.png"></p>
<p>ISL有如用ISL包头和新CRC将原数据帧整个包裹起来，因此也被称为“封装型VLAN”（Encapsulated VLAN）。<br>需要注意的是，不论是IEEE802.1Q的“Tagging VLAN”，还是ISL的“Encapsulated VLAN”，都不是很严密的称谓。不同的书籍与参考资料中，上述词语有可能被混合使用，因此需要大家在学习时格外注意。<br>并且由于ISL是Cisco独有的协议，因此只能用于Cisco网络设备之间的互联。</p>
<h1 id="VLAN间路由"><a href="#VLAN间路由" class="headerlink" title="VLAN间路由"></a>VLAN间路由</h1><h2 id="VLAN间路由的必要性"><a href="#VLAN间路由的必要性" class="headerlink" title="VLAN间路由的必要性"></a>VLAN间路由的必要性</h2><p>根据目前为止学习的知识，我们已经知道两台计算机即使连接在同一台交换机上，只要所属的VLAN不同就无法直接通信。接下来我们将要学习的就是如何在不同的VLAN间进行路由，使分属不同VLAN的主机能够互相通信。<br>首先，先来复习一下为什么不同VLAN间不通过路由就无法通信。在LAN内的通信，必须在数据帧头中指定通信目标的MAC地址。而为了获取MAC地址，TCP&#x2F;IP协议下使用的是ARP。ARP解析MAC地址的方法，则是通过广播。也就是说，如果广播报文无法到达，那么就无从解析MAC地址，亦即无法直接通信。</p>
<blockquote>
<p>计算机分属不同的VLAN，也就意味着分属不同的广播域，自然收不到彼此的广播报文。因此，属于不同VLAN的计算机之间无法直接互相通信。</p>
</blockquote>
<p>为了能够在VLAN间通信，需要利用OSI参照模型中更高一层——网络层的信息（IP地址）来进行路由。<br>路由功能，一般主要由路由器提供。但在今天的局域网里，我们也经常利用带有路由功能的交换机——三层交换机（Layer 3 Switch）来实现。接下来就让我们分别看看使用路由器和三层交换机进行VLAN间路由时的情况。</p>
<h2 id="使用路由器进行VLAN间路由"><a href="#使用路由器进行VLAN间路由" class="headerlink" title="使用路由器进行VLAN间路由"></a>使用路由器进行VLAN间路由</h2><p>在使用路由器进行VLAN间路由时，与构建横跨多台交换机的VLAN时的情况类似，我们还是会遇到“该如何连接路由器与交换机”这个问题。路由器和交换机的接线方式，大致有以下两种：<br>（1）将路由器与交换机上的每个VLAN分别连接<br>（2）不论VLAN有多少个，路由器与交换机都只用一条网线连接<br>最容易想到的，当然还是“把路由器和交换机以VLAN为单位分别用网线连接”了。将交换机上用于和路由器互联的每个端口设为访问链接（Access Link），然后分别用网线与路由器上的独立端口互联。如下图所示，交换机上有2个VLAN，那么就需要在交换机上预留2个端口用于与路由器互联；路由器上同样需要有2个端口；两者之间用2条网线分别连接。<br><img src="/images/20130726175433375.png"></p>
<p>如果采用这个办法，大家应该不难想象它的扩展性很成问题。每增加一个新的VLAN，都需要消耗路由器的端口和交换机上的访问链接，而且还需要重新布设一条网线。而路由器，通常不会带有太多LAN接口的。新建VLAN时，为了对应增加的VLAN所需的端口，就必须将路由器升级成带有多个LAN接口的高端产品，这部分成本、还有重新布线所带来的开销，都使得这种接线法成为一种不受欢迎的办法。</p>
<p>那么，第二种办法“不论VLAN数目多少，都只用一条网线连接路由器与交换机”呢？当使用一条网线连接路由器与交换机、进行VLAN间路由时，需要用到汇聚链接。<br>具体实现过程为：首先将用于连接路由器的交换机端口设为汇聚链接（Trunk Link），而路由器上的端口也必须支持汇聚链路。双方用于汇聚链路的协议自然也必须相同。接着在路由器上定义对应各个VLAN的“子接口”（Sub Interface）。尽管实际与交换机连接的物理端口只有一个，但在理论上我们可以把它分割为多个虚拟端口。<br>VLAN将交换机从逻辑上分割成了多台，因而用于VLAN间路由的路由器，也必须拥有分别对应各个VLAN的虚拟接口。<br><img src="/images/20130726175513765.png"></p>
<p>采用这种方法的话，即使之后在交换机上新建VLAN，仍只需要一条网线连接交换机和路由器。用户只需要在路由器上新设一个对应新VLAN的子接口就可以了。与前面的方法相比，扩展性要强得多，也不用担心需要升级LAN接口数不足的路由器或是重新布线。</p>
<h2 id="同一VLAN内的通信"><a href="#同一VLAN内的通信" class="headerlink" title="同一VLAN内的通信"></a>同一VLAN内的通信</h2><p>接下来，我们继续学习使用汇聚链路连接交换机与路由器时，VLAN间路由是如何进行的。如下图所示，为各台计算机以及路由器的子接口设定IP地址。<br><img src="/images/20130726175604515.png"></p>
<p>红色VLAN（VLAN ID&#x3D;1）的网络地址为192.168.1.0&#x2F;24，蓝色VLAN（VLAN ID&#x3D;2）的网络地址为192.168.2.0&#x2F;24。各计算机的MAC地址分别为A&#x2F;B&#x2F;C&#x2F;D，路由器汇聚链接端口的MAC地址为R。交换机通过对各端口所连计算机MAC地址的学习，生成如下的MAC地址列表。<br>端口      MAC地址       VLAN<br>1           A                    1<br>2           B                    1<br>3           C                    2<br>4           D                    2<br>5           -                     -<br>6           R                    汇聚</p>
<p>首先考虑计算机A与同一VLAN内的计算机B之间通信时的情形。<br>计算机A发出ARP请求信息，请求解析B的MAC地址。交换机收到数据帧后，检索MAC地址列表中与收信端口同属一个VLAN的表项。结果发现，计算机B连接在端口2上，于是交换机将数据帧转发给端口2，最终计算机B收到该帧。收发信双方同属一个VLAN之内的通信，一切处理均在交换机内完成。<br><img src="/images/20130726175623656.png"></p>
<h2 id="不同VLAN间的通信"><a href="#不同VLAN间的通信" class="headerlink" title="不同VLAN间的通信"></a>不同VLAN间的通信</h2><p>接下来是这一讲的核心内容，不同VLAN间的通信。让我们来考虑一下计算机A与计算机C之间通信时的情况。<br><img src="/images/20130726175659000.png"></p>
<p>计算机A从通信目标的IP地址（192.168.2.1）得出C与本机不属于同一个网段。因此会向设定的默认网关（DefaultGateway，GW）转发数据帧。在发送数据帧之前，需要先用ARP获取路由器的MAC地址。<br>得到路由器的MAC地址R后，接下来就是按图中所示的步骤发送往C去的数据帧。①的数据帧中，目标MAC地址是路由器的地址R、但内含的目标IP地址仍是最终要通信的对象C的地址。这一部分的内容，涉及到局域网内经过路由器转发时的通信步骤，有机会再详细解说吧。<br>交换机在端口1上收到①的数据帧后，检索MAC地址列表中与端口1同属一个VLAN的表项。由于汇聚链路会被看作属于所有的VLAN，因此这时交换机的端口6也属于被参照对象。这样交换机就知道往MAC地址R发送数据帧，需要经过端口6转发。<br>从端口6发送数据帧时，由于它是汇聚链接，因此会被附加上VLAN识别信息。由于原先是来自红色VLAN的数据帧，因此如图中②所示，会被加上红色VLAN的识别信息后进入汇聚链路。路由器收到②的数据帧后，确认其VLAN识别信息，由于它是属于红色VLAN的数据帧，因此交由负责红色VLAN的子接口接收。<br>接着，根据路由器内部的路由表，判断该向哪里中继。<br>由于目标网络192.168.2.0&#x2F;24是蓝色VLAN，且该网络通过子接口与路由器直连，因此只要从负责蓝色VLAN的子接口转发就可以了。这时，数据帧的目标MAC地址被改写成计算机C的目标地址；并且由于需要经过汇聚链路转发，因此被附加了属于蓝色VLAN的识别信息。这就是图中③的数据帧。<br>交换机收到③的数据帧后，根据VLAN标识信息从MAC地址列表中检索属于蓝色VLAN的表项。由于通信目标——计算机C连接在端口3上、且端口3为普通的访问链接，因此交换机会将数据帧去除VLAN识别信息后（数据帧④）转发给端口3，最终计算机C才能成功地收到这个数据帧。<br>进行VLAN间通信时，即使通信双方都连接在同一台交换机上，也必须经过：“发送方——交换机——路由器——交换机——接收方”这样一个流程。</p>
<h1 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h1><h2 id="使用路由器进行VLAN间路由时的问题"><a href="#使用路由器进行VLAN间路由时的问题" class="headerlink" title="使用路由器进行VLAN间路由时的问题"></a>使用路由器进行VLAN间路由时的问题</h2><p>现在，我们知道只要能提供VLAN间路由，就能够使分属不同VLAN的计算机互相通信。但是，如果使用路由器进行VLAN间路由的话，随着VLAN之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈。<br>交换机使用被称为ASIC（ApplicationSpecified Integrated Circuit）的专用硬件芯片处理数据帧的交换操作，在很多机型上都能实现以缆线速度（Wired Speed）交换。而路由器，则基本上是基于软件处理的。即使以缆线速度接收到数据包，也无法在不限速的条件下转发出去，因此会成为速度瓶颈。就VLAN间路由而言，流量会集中到路由器和交换机互联的汇聚链路部分，这一部分尤其特别容易成为速度瓶颈。并且从硬件上看，由于需要分别设置路由器和交换机，在一些空间狭小的环境里可能连设置的场所都成问题。</p>
<h2 id="三层交换机（Layer-3-Switch）"><a href="#三层交换机（Layer-3-Switch）" class="headerlink" title="三层交换机（Layer 3 Switch）"></a>三层交换机（Layer 3 Switch）</h2><p>为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是“带有路由功能的（二层）交换机”。路由属于OSI参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为“三层交换机”。<br>关于三层交换机的内部结构，可以参照下面的简图。<br><img src="/images/20130726175738687.png"></p>
<p>在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽。</p>
<h3 id="使用三层交换机进行VLAN间路由（VLAN内通信）"><a href="#使用三层交换机进行VLAN间路由（VLAN内通信）" class="headerlink" title="使用三层交换机进行VLAN间路由（VLAN内通信）"></a>使用三层交换机进行VLAN间路由（VLAN内通信）</h3><p>在三层交换机内部数据究竟是怎样传播的呢？基本上，它和使用汇聚链路连接路由器与交换机时的情形相同。<br>假设有如下图所示的4台计算机与三层交换机互联。当使用路由器连接时，一般需要在LAN接口上设置对应各VLAN的子接口；而三层交换机则是在内部生成“VLAN接口”（VLAN Interface）。VLAN接口，是用于各VLAN收发数据的接口。（注：在Cisco的Catalyst系列交换机上，VLAN Interface被称为SVI——Switched Virtual Interface）<br><img src="/images/20130726175831031.png"></p>
<p>为了与使用路由器进行VLAN间路由对比，让我们同样来考虑一下计算机A与计算机B之间通信时的情况。首先是目标地址为B的数据帧被发到交换机；通过检索同一VLAN的MAC地址列表发现计算机B连在交换机的端口2上；因此将数据帧转发给端口2。</p>
<h3 id="使用三层交换机进行VLAN间路由（VLAN间通信）"><a href="#使用三层交换机进行VLAN间路由（VLAN间通信）" class="headerlink" title="使用三层交换机进行VLAN间路由（VLAN间通信）"></a>使用三层交换机进行VLAN间路由（VLAN间通信）</h3><p>接下来设想一下计算机A与计算机C间通信时的情形。针对目标IP地址，计算机A可以判断出通信对象不属于同一个网络，因此向默认网关发送数据（Frame 1）。<br>交换机通过检索MAC地址列表后，经由内部汇聚链接，将数据帧转发给路由模块。在通过内部汇聚链路时，数据帧被附加了属于红色VLAN的VLAN识别信息（Frame 2）。<br>路由模块在收到数据帧时，先由数据帧附加的VLAN识别信息分辨出它属于红色VLAN，据此判断由红色VLAN接口负责接收并进行路由处理。因为目标网络192.168.2.0&#x2F;24是直连路由器的网络、且对应蓝色VLAN；因此，接下来就会从蓝色VLAN接口经由内部汇聚链路转发回交换模块。在通过汇聚链路时，这次数据帧被附加上属于蓝色VLAN的识别信息（Frame 3）。<br>交换机收到这个帧后，检索蓝色VLAN的MAC地址列表，确认需要将它转发给端口3。由于端口3是通常的访问链接，因此转发前会先将VLAN识别信息去除（Frame 4）。最终，计算机C成功地收到交换机转发来的数据帧。<br><img src="/images/20130726175909406.png"></p>
<h1 id="加速VLAN间通信的手段"><a href="#加速VLAN间通信的手段" class="headerlink" title="加速VLAN间通信的手段"></a>加速VLAN间通信的手段</h1><h2 id="流（Flow）"><a href="#流（Flow）" class="headerlink" title="流（Flow）"></a>流（Flow）</h2><p>根据到此为止的学习，我们已经知道VLAN间路由，必须经过外部的路由器或是三层交换机的内置路由模块。但是，有时并不是所有的数据都需要经过路由器（或路由模块）。<br>例如，使用FTP（File Transfer Protocol）传输容量为数MB以上的较大的文件时，由于MTU的限制，IP协议会将数据分割成小块后传输、并在接收方重新组合。这些被分割的数据，“发送的目标”是完全相同的。发送目标相同，也就意味着同样的目标IP地址、目标端口号（注：特别强调一下，这里指的是TCP&#x2F;UDP端口）。自然，源IP地址、源端口号也应该相同。这样一连串的数据流被称为“流”（Flow）。<br>只要将流最初的数据正确地路由以后，后继的数据理应也会被同样地路由。<br>据此，后继的数据不再需要路由器进行路由处理；通过省略反复进行的路由操作，可以进一步提高VLAN间路由的速度。<br><img src="/images/20130726175938406.png"></p>
<h2 id="加速VLAN间路由的机制"><a href="#加速VLAN间路由的机制" class="headerlink" title="加速VLAN间路由的机制"></a>加速VLAN间路由的机制</h2><p>接下来，让我们具体考虑一下该如何使用三层交换机进行高速VLAN间路由。<br>首先，整个流的第一块数据，照常由交换机转发→路由器路由→再次由交换机转发到目标所连端口。这时，将第一块数据路由的结果记录到缓存里保存下来。需要记录的信息有：<br>（1）目标IP地址<br>（2）源IP地址<br>（3）目标TCP&#x2F;UDP端口号<br>（4）源TCP&#x2F;UDP端口号<br>（5）接收端口号（交换机）<br>（6）转发端口号（交换机）<br>（7）转发目标MAC地址<br>等等。<br>同一个流的第二块以后的数据到达交换机后，直接通过查询先前保存在缓存中的信息查出“转发端口号”后就可以转发给目标所连端口了。<br>这样一来，就不需要再一次次经由内部路由模块中继，而仅凭交换机内部的缓存信息就足以判断应该转发的端口。<br>这时，交换机会对数据帧进行由路由器中继时相似的处理，例如改写MAC地址、IP包头中的TTL和Check Sum校验码信息等。<br><img src="/images/20130726180010687.png"></p>
<p>通过在交换机上缓存路由结果，实现了以缆线速度（Wired Speed）接收发送方传输来数据的数据、并且能够全速路由、转发给接收方。<br>需要注意的是，类似的加速VLAN间路由的手法多由各厂商独有的技术所实现，并且该功能的称谓也因厂商而异。例如，在Cisco的Catalyst系列交换机上，这种功能被称为“多层交换”（Multi Layer Switching）。另外，除了三层交换机的内部路由模块，外部路由器中的某些机型也支持类似的高速VLAN间路由机制。</p>
<h1 id="传统型路由器存在的意义"><a href="#传统型路由器存在的意义" class="headerlink" title="传统型路由器存在的意义"></a>传统型路由器存在的意义</h1><h2 id="路由器的必要性"><a href="#路由器的必要性" class="headerlink" title="路由器的必要性"></a>路由器的必要性</h2><p>三层交换机的价格，在问世之初非常昂贵，但是现在它们的价格已经下降了许多。目前国外一些廉价机型的售价，折合成人民币后仅为一万多元，而且还在继续下降中。<br>既然三层交换机能够提供比传统型路由器更为高速的路由处理，那么网络中还有使用路由器的必要吗？<br>答案是：“是”。<br>使用路由器的必要性，主要表现在以下几个方面：<br>（1）用于与WAN连接<br>三层交换机终究是“交换机”。也就是说，绝大多数机型只配有LAN（以太网）接口。在少数高端交换机上也有用于连接WAN的串行接口或是ATM接口，但在大多数情况下，连接WAN还是需要用到路由器。<br>（2）保证网络安全<br>在三层交换机上，通过数据包过滤也能确保一定程度的网络安全。但是使用路由器所提供的各种网络安全功能，用户可以构建更为安全可靠的网络。<br>路由器提供的网络安全功能中，除了最基本的数据包过滤功能外，还能基于IPSec构建VPN（VirtualPrivate Network）、利用RADIUS进行用户认证等等。<br>（3）支持除TCP&#x2F;IP以外的异构网络架构<br>尽管TCP&#x2F;IP已经成为当前网络协议架构的主流，但还有不少网络利用Novell Netware下的IPX&#x2F;SPX或Macintosh下的AppleTalk等网络协议。三层交换机中，除了部分高端机型外基本上还只支持TCP&#x2F;IP。因此，在需要使用除TCP&#x2F;IP之外其他网络协议的环境下，路由器还是必不可少的。<br>注：在少数高端交换机上，也能支持上述路由器的功能。例如Cisco的Catalyst 6500系列，就可以选择与WAN连接的接口模块；还有可选的基于IPSec实现VPN的模块；并且也能支持TCP&#x2F;IP以外的其他网络协议。</p>
<h2 id="路由器和交换机配合构建LAN的实例"><a href="#路由器和交换机配合构建LAN的实例" class="headerlink" title="路由器和交换机配合构建LAN的实例"></a>路由器和交换机配合构建LAN的实例</h2><p>下面让我们来看一个路由器和交换机搭配构建LAN的实例。<br><img src="/images/20130726180050656.png"></p>
<p>利用在各楼层配置的二层交换机定义VLAN，连接TCP&#x2F;IP客户计算机。各楼层间的VLAN间通信，利用三层交换机的高速路由加以实现。如果网络环境要求高可靠性，还可以考虑冗余配置三层交换机。<br>与WAN的连接，则通过带有各种网络接口的路由器进行。并且，通过路由器的数据包过滤和VPN等功能实现网络安全。此外，使用路由器还能支持Novell Netware等TCP&#x2F;IP之外的网络。<br>只有在充分掌握了二层、三层交换机以及传统路由器的基础上，才能做到物竞其用，构筑出高效率、高性价比的网络。</p>
<h1 id="使用VLAN设计局域网"><a href="#使用VLAN设计局域网" class="headerlink" title="使用VLAN设计局域网"></a>使用VLAN设计局域网</h1><h2 id="使用VLAN设计局域网的特点"><a href="#使用VLAN设计局域网的特点" class="headerlink" title="使用VLAN设计局域网的特点"></a>使用VLAN设计局域网的特点</h2><p>通过使用VLAN构建局域网，用户能够不受物理链路的限制而自由地分割广播域。<br>另外，通过先前提到的路由器与三层交换机提供的VLAN间路由，能够适应灵活多变的网络构成。<br>但是，由于利用VLAN容易导致网络构成复杂化，因此也会造成整个网络的组成难以把握。<br>可以这样说，在利用VLAN时，除了有“网络构成灵活多变”这个优点外，还搭配着“网络构成复杂化”这个缺点。<br>下面，就让我们来看看具体的实例。</p>
<h2 id="不使用VLAN的局域网中网络构成的改变"><a href="#不使用VLAN的局域网中网络构成的改变" class="headerlink" title="不使用VLAN的局域网中网络构成的改变"></a>不使用VLAN的局域网中网络构成的改变</h2><p>假设有如图所示的由1台路由器、2台交换机构成的“不使用VLAN构建”的网络。<br><img src="/images/20130726180130125.png"></p>
<p>图中的路由器，带有2个LAN接口。左侧的网络是192.168.1.0&#x2F;24，右侧是192.168.2.0&#x2F;24。<br>现在如果想将192.168.1.0&#x2F;24这个网络上的计算机A转移到192.168.2.0&#x2F;24上去，就需要改变物理连接、将A接到右侧的交换机上。<br>并且，当需要新增一个地址为192.168.3.0&#x2F;24的网络时，还要在路由器上再占用一个LAN接口并添置一台交换机。而由于这台路由器上只带了2个LAN接口，因此为了新增网络还必须将路由器升级为带有3个以上LAN接口的产品。</p>
<h2 id="使用VLAN的局域网中网络构成的改变"><a href="#使用VLAN的局域网中网络构成的改变" class="headerlink" title="使用VLAN的局域网中网络构成的改变"></a>使用VLAN的局域网中网络构成的改变</h2><p>接下来再假设有一个由1台路由器、2台交换机构成的“使用VLAN”的局域网。交换机与交换机、交换机与路由器之间均为汇聚链路；并且假设192.168.1.0&#x2F;24对应红色VLAN、192.168.2.0&#x2F;24对应蓝色VLAN。<br><img src="/images/20130726180206046.png"></p>
<p>需要将连接在交换机1上192.168.1.0&#x2F;24这个网段的计算机A转属192.168.2.0&#x2F;24时，无需更改物理布线。只要在交换机上生成蓝色VLAN，然后将计算机A所连的端口1加入到蓝色VLAN中去，使它成为访问链接即可。<br>然后，根据需要设定计算机A的IP地址、默认网关等信息就可以了。如果IP地址相关的设定是由DHCP获取的，那么在客户机方面无需进行任何设定修改，就可以在不同网段间移动。<br>利用VLAN后，我们可以在免于改动任何物理布线的前提下，自由进行网络的逻辑设计。如果所处的工作环境恰恰需要经常改变网络布局，那么利用VLAN的优势就非常明显了。<br>并且，当需要新增一个地址为192.168.3.0&#x2F;24的网段时，也只需要在交换机上新建一个对应192.168.3.0&#x2F;24的VLAN，并将所需的端口加入它的访问链路就可以了。<br>如果网络环境中还需要利用外部路由器，则只要在路由器的汇聚端口上新增一个子接口的设定就可以完成全部操作，而不需要消耗更多的物理接口（LAN接口）。要使用的是三层交换机内部的路由模块，则只需要新设一个VLAN接口即可。<br>网络环境的成长，往往是难以预测的，很可能经常会出现需要分割现有网络或是增加新网络的情况。而充分活用VLAN后，就可以轻易地解决这些问题。</p>
<h2 id="利用VLAN而导致的网络结构复杂化"><a href="#利用VLAN而导致的网络结构复杂化" class="headerlink" title="利用VLAN而导致的网络结构复杂化"></a>利用VLAN而导致的网络结构复杂化</h2><p>虽然利用VLAN可以灵活地构建网络，但是同时，它也带来了网络结构复杂化的问题。<br>特别是由于数据流纵横交错，一旦发生故障时，准确定位并排除故障会比较困难。<br>为了便于理解数据流向的复杂化，假设有下图所示的网络。计算机A向计算机C发送数据时，数据流的整体走向如下：<br>计算机A→交换机1→路由器→交换机1→交换机2→计算机C<br><img src="/images/20130726180236218.png"></p>
<p>首先计算机A向交换机1送出数据（①），其后数据被转发给路由器（②）进行VLAN间路由。路由后的数据，再从汇聚链路返回交换机1（③）。由于通信目标计算机C并不直连在交换机1上，因此还需要经过汇聚链路转发到交换机2（④）。在交换机2上，数据最终被转发到C所连的端口2上，这才完成整个流程（⑤）。<br>在这个例子中，仅由2台交换机构成网络，其数据流已经如此复杂，如果构建横跨多台交换机的VLAN的话，每个数据流的流向显然会更加难以把握。</p>
<h2 id="网络的逻辑结构与物理结构"><a href="#网络的逻辑结构与物理结构" class="headerlink" title="网络的逻辑结构与物理结构"></a>网络的逻辑结构与物理结构</h2><p>为了对应日渐复杂化的数据流，管理员需要从“逻辑结构”与“物理结构”两方面入手，把握好网络的现状。<br>物理结构，指的是从物理层和数据链路层观察到的网络的现状，表示了网络的物理布线形态和VLAN的设定等等。<br>而逻辑结构，则表示从网络层以上的层面观察到的网络结构。下面我们就试着以路由器为中心分析一个IP网络的逻辑结构。<br>还是先前的那个例子，描绘了布线形态和VLAN设定的“物理结构”如下图所示。<br><img src="/images/20130726180318750.png"></p>
<p>分析这个物理结构并转换成以路由器为中心的逻辑结构后，会得到如下的逻辑结构图。当我们需要进行路由或是数据包过滤的设定时，都必须在逻辑结构的基础上进行<br><img src="/images/20130726180338921.png"></p>
<p>把握这两种网络结构图的区别是十分重要的，特别是在VLAN和三层交换机大行其道的现代企业级网络当中。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>volatile关键字解析</title>
    <url>/2017/04/21/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<h1 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h1><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于<code>程序运行过程中的临时数据是存放在主存（物理内存）当中的</code>，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>也就是，<code>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中</code>。举个简单的例子，比如下面的这段代码：<br><code>i = i + 1;</code><br>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的<code>缓存一致性问题</code>。通常称这种被多个线程访问的变量为共享变量。<br>也就是说，<code>如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题</code>。</p>
<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：<br>1）通过在总线加LOCK锁的方式<br>2）通过缓存一致性协议</p>
<p>这2种方式都是硬件层面上提供的方式。<br>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为<code>CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存</code>。比如上面例子中 如果一个线程在执行 i &#x3D; i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，<code>MESI协议保证了每个缓存中使用的共享变量的副本是一致的</code>。它核心的思想是：<br><code>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取</code>。<br><img src="/images/212219343783699"></p>
<h1 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h1><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：<br>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。<br>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。<br>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？<br><code>i = 9;</code><br>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。<br>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<blockquote>
<p>无法保证原子性就会读到脏数据</p>
</blockquote>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>举个简单的例子，看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程1执行的代码</span><br><span class="line">int i = 0;</span><br><span class="line">i = 10;</span><br><span class="line"> </span><br><span class="line">//线程2执行的代码</span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.<br>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 0;              </span><br><span class="line">boolean flag = false;</span><br><span class="line">i = 1;                //语句1  </span><br><span class="line">flag = true;          //语句2</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序<br><code>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</code><br>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10;    //语句1</span><br><span class="line">int r = 2;    //语句2</span><br><span class="line">a = a + 3;    //语句3</span><br><span class="line">r = a*a;     //语句4</span><br></pre></td></tr></table></figure>

<p>这段代码有4个语句，那么可能的一个执行顺序是：<br><img src="/images/212305263939989"></p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3<br>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，<code>如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行</code>。<br>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br>从上面可以看出，<code>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性</code>。<br>也就是说，</p>
<blockquote>
<p>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
</blockquote>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>Java内存模型规定<br>所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。<br>线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：<br><code>i  = 10;</code><br>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。<br>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h2 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h2><p>在Java中，<code>对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行</code>。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：<br>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">y = x;         //语句2</span><br><span class="line">x++;           //语句3</span><br><span class="line">x = x + 1;     //语句4</span><br></pre></td></tr></table></figure>

<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x &#x3D; x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说</p>
<blockquote>
<p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
</blockquote>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，<code>如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现</code>。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>对于可见性，Java提供了<code>volatile</code>关键字来保证可见性。</p>
<blockquote>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
</blockquote>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>下面就来具体介绍下happens-before原则（先行发生原则）：<br>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。</p>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：<br>1、<code>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的</code>。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>2、第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>3、第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，<code>如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</code><br>4、第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h1 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h1><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<h2 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。</p>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程1</span><br><span class="line">boolean stop = false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种<code>标记办法</code>。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。<br>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：<br>第一：使用volatile关键字会强制将修改的值立即写入主存；<br>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。<br>那么线程1读取到的就是最新的正确的值</p>
<h2 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h2><blockquote>
<p>不保证</p>
</blockquote>
<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>下面看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。<br>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10&#x3D;10000。</p>
<p>这里面就有一个误区了</p>
<blockquote>
<p>volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
</blockquote>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，<br>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；<br>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。<br>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意</p>
<blockquote>
<p>线程1的自增操作不是原子操作，线程1恢复后的下一步不是读取i的值，而是对工作内存的i进行+1操作。所以尽管主内存已经更新了线程2对i的修改，但线程1依然不知情！</p>
</blockquote>
<p>把上面的代码改成以下任何一种都可以达到效果：<br>1、采用synchronized：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line"> </span><br><span class="line">// 让++操作变成原子操作，这样其实volatile就没用了</span><br><span class="line">    public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、采用Lock：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、采用AtomicInteger：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  AtomicInteger inc = new AtomicInteger();</span><br><span class="line"> </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap）</p>
<blockquote>
<p>CAS做赋值操作前会比较当前值是否符合预期，符合预期才赋值</p>
</blockquote>
<h2 id="volatile能保证有序性吗"><a href="#volatile能保证有序性吗" class="headerlink" title="volatile能保证有序性吗"></a>volatile能保证有序性吗</h2><blockquote>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
</blockquote>
<p>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>

<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：<br>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2）它会强制将对缓存的修改操作立即写入主存；<br>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h1 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h1><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中</p>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>事实上，我的理解就是</p>
<blockquote>
<p>上面的2个条件需要保证<code>对volatile变量的操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行</code>。</p>
</blockquote>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<h2 id="状态标记量"><a href="#状态标记量" class="headerlink" title="状态标记量"></a>状态标记量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile boolean flag = false;</span><br><span class="line"> </span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile boolean inited = false;</span><br><span class="line">//线程1:</span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = true;            </span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<h2 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>从放弃JSP谈前后端解耦</title>
    <url>/2017/07/09/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E4%BB%8E%E6%94%BE%E5%BC%83JSP%E8%B0%88%E5%89%8D%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6/</url>
    <content><![CDATA[<h1 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h1><p>前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，<br>并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。<br>这个步骤是系统架构从猿进化成人的必经之路。</p>
<p>核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。</p>
<p>名词解释：<br>在互联网架构中，<br>web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。<br>应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。<br>一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。</p>
<hr>
<h1 id="术业有专攻（开发人员分离）"><a href="#术业有专攻（开发人员分离）" class="headerlink" title="术业有专攻（开发人员分离）"></a>术业有专攻（开发人员分离）</h1><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax&#x2F;jquery&#x2F;js&#x2F;html&#x2F;css等等），又搞后端（java&#x2F;mysql&#x2F;oracle等等）。</p>
<p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。<br>正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p>
<p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。</p>
<p>对于后端java工程师：<br>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http&#x2F;tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。<br>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p>
<p>对于前端工程师：<br>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less&#x2F;sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。<br>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p>
<p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。<br>并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。</p>
<p>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。</p>
<hr>
<h1 id="原始人时代（各种耦合）"><a href="#原始人时代（各种耦合）" class="headerlink" title="原始人时代（各种耦合）"></a>原始人时代（各种耦合）</h1><p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc&#x2F;struts + spring + spring jdbc&#x2F;hibernate&#x2F;mybatis 等等。</p>
<p>大多数项目在java后端都是分了三层，控制层（controller&#x2F;action），业务层（service&#x2F;manage），持久层（dao）。<br>控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。<br>然后jsp页面上使用各种标签（jstl&#x2F;el&#x2F;struts标签等）或者手写java表达式（&lt;%&#x3D;%&gt;）将后台的数据展现出来，玩的是MVC那套思路。</p>
<p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？<br>你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat&#x2F;jboss&#x2F;weblogic&#x2F;websphere&#x2F;jetty&#x2F;resin）里，对吧？</p>
<p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。<br>那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p>
<p>好，下面在浏览器中输入你的网站域名（<a href="http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）</a><br>我捡干的说了啊，基础不好的童鞋请自己去搜。</p>
<p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp&#x2F;ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p>
<p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p>
<p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p>
<p>这就是为什么，越是大中型的web应用，他们越是要解耦。<br>理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。<br>但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p>
<p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。<br>注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~</p>
<p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，<br>要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？<br>还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？<br>（引用：《架构探险-轻量级微服务架构》，黄勇）</p>
<p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p>
<hr>
<h1 id="JSP的痛点"><a href="#JSP的痛点" class="headerlink" title="JSP的痛点"></a>JSP的痛点</h1><p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，<br>因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p>
<p>1.动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。<br>一旦服务器出现状况，前后台一起玩完，用户体验极差。</p>
<p>2.UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），<br>修改问题时需要双方协同开发，效率低下。</p>
<p>3.jsp必须要在支持java的服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），<br>性能提不上来。</p>
<p>4.第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p>
<p>5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p>
<p>6.jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p>
<p>7.如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p>
<p>8.需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p>
<p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！</p>
<hr>
<h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><p>以前老的方式是：<br>1.产品经历&#x2F;领导&#x2F;客户提出需求<br>2.UI做出设计图<br>3.前端工程师做html页面<br>4.后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）<br>5.集成出现问题<br>6.前端返工<br>7.后端返工<br>8.二次集成<br>9.集成成功<br>10.交付</p>
<p>新的方式是：<br>1.产品经历&#x2F;领导&#x2F;客户提出需求<br>2.UI做出设计图<br>3.前后端约定接口&amp;数据&amp;参数<br>4.前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）<br>5.前后端集成<br>6.前端页面调整<br>7.集成成功<br>8.交付</p>
<hr>
<h1 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h1><p>以前老的方式是：<br>1.客户端请求<br>2.服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）<br>3.调用service,dao代码完成业务逻辑<br>4.返回jsp<br>5.jsp展现一些动态的代码</p>
<p>新的方式是：<br>1.浏览器发送请求<br>2.直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）<br>3.html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）<br>4.填充html，展现动态效果，在页面上进行解析并操作DOM。<br>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，<br>使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）</p>
<p>总结一下新的方式的请求步骤：<br>大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件&#x2F;数据库&#x2F;缓存&#x2F;消息队列服务器集群<br>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p>
<hr>
<h1 id="前后分离的优势"><a href="#前后分离的优势" class="headerlink" title="前后分离的优势"></a>前后分离的优势</h1><p>1.可以实现真正的前后端解耦，前端服务器使用nginx。<br>前端&#x2F;WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端&#x2F;应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。<br>（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）</p>
<p>2.发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。<br>页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。<br>接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。<br>双方互不干扰，前端与后端是相亲相爱的一家人。</p>
<p>3.在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。<br>（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）</p>
<p>4.减少后端服务器的并发&#x2F;负载压力<br>除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。<br>且除了第一次页面请求外，浏览器会大量调用本地缓存。</p>
<p>5.即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p>
<p>6.也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，<br>那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p>
<p>7.页面显示的东西再多也不怕，因为是异步加载。</p>
<p>8.nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p>
<p>9.增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p>
<p>10.提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p>
<p>11.在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），<br>内网使用http，性能和安全都有保障。</p>
<p>12.前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p>
<hr>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1.在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，<br>推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p>
<p>2.上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p>
<p>3.加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p>
<p>4.我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p>
<p>5.如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p>
<p>6.以前还有人在使用类似于velocity&#x2F;freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p>
<p>7.这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp&#x2F;servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p>
<p>8.如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p>
<p>9.对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？<br>因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是<br>服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。<br>类似于数据校验这种，前后端都需要做！</p>
<p>10.前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p>
<hr>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>1.其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。</p>
<p>2.如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，<br>这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。<br>浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p>
<p>3.如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。<br>JSONP的方式也被淘汰掉了。</p>
<p>4.如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。</p>
<p>5.前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。<br>千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目<br>前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。<br>前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。<br>前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>数字签名数字证书</title>
    <url>/2017/05/14/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><ol>
<li><p><img src="/images/bg2011080901.png"><br>鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p>
</li>
<li><p><img src="/images/bg2011080902.png"><br>鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</p>
</li>
<li><p><img src="/images/bg2011080903.png"><br>苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p>
</li>
<li><p><img src="/images/bg2011080904.png"><br>鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p>
</li>
<li><p><img src="/images/bg2011080905.png"><br>鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p>
</li>
<li><p><img src="/images/bg2011080906.png"><br>然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</p>
</li>
<li><p><img src="/images/bg2011080907.png"><br>鲍勃将这个签名，附在信件下面，一起发给苏珊。</p>
</li>
<li><p><img src="/images/bg2011080908.png"><br>苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p>
</li>
<li><p><img src="/images/bg2011080909.png"><br>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
</li>
<li><p><img src="/images/bg2011080910.png"><br>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p>
</li>
</ol>
<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><ol start="11">
<li><p><img src="/images/bg2011080911.png"><br>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）</p>
</li>
<li><p><img src="/images/bg2011080912.png"><br>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p>
</li>
<li><p><img src="/images/bg2011080913.png"><br>苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</p>
</li>
<li><p><img src="/images/bg2011080914.jpg"><br>下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</p>
</li>
<li><p><img src="/images/bg2011080915.png"><br>首先，客户端向服务器发出加密请求。</p>
</li>
<li><p><img src="/images/bg2011080916.png"><br>服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。  </p>
</li>
<li><p><img src="/images/bg2011080917.png"><br>客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</p>
</li>
<li><p><img src="/images/bg2011080918.png"><br>如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p>
</li>
<li><p><img src="/images/bg2011080919.jpg"><br>如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</p>
</li>
<li><p><img src="/images/bg2011080920.png"><br>如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>浅析若干Java序列化工具</title>
    <url>/2017/04/24/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E6%B5%85%E6%9E%90%E8%8B%A5%E5%B9%B2Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>在Java中socket传输数据时，数据类型往往比较难选择。可能要考虑带宽、跨语言、版本的兼容等问题。比较常见的做法有：<br>采用java对象的序列化和反序列化<br>把对象包装成JSON字符串传输<br>Google工具protoBuf的开源</p>
</blockquote>
<p>为了便于说明各个做法的区别，分别对这三种做法进行阐述。 对UserVo对象进行序列化，class UserVo如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package serialize;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class UserVo</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private List&lt;UserVo&gt; friends;</span><br><span class="line">    //此处省略Getter和Setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化一个UserVo实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UserVo user = new UserVo();</span><br><span class="line">user.setName(&quot;zzh&quot;);</span><br><span class="line">user.setAge(18);</span><br><span class="line"> </span><br><span class="line">UserVo f1 = new UserVo();</span><br><span class="line">f1.setName(&quot;jj&quot;);</span><br><span class="line">f1.setAge(17);</span><br><span class="line">UserVo f2 = new UserVo();</span><br><span class="line">f2.setName(&quot;qq&quot;);</span><br><span class="line">f2.setAge(19);</span><br><span class="line"> </span><br><span class="line">List&lt;UserVo&gt; friends = new ArrayList&lt;UserVo&gt;();</span><br><span class="line">friends.add(f1);</span><br><span class="line">friends.add(f2);</span><br><span class="line">user.setFriends(friends);</span><br></pre></td></tr></table></figure>

<h1 id="采用java对象的序列化和反序列化"><a href="#采用java对象的序列化和反序列化" class="headerlink" title="采用java对象的序列化和反序列化"></a>采用java对象的序列化和反序列化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream os = new ByteArrayOutputStream();</span><br><span class="line">       ObjectOutputStream oos = new ObjectOutputStream(os);</span><br><span class="line">       oos.writeObject(user);</span><br><span class="line">       oos.flush();</span><br><span class="line">       oos.close();</span><br><span class="line">       System.out.println(os.toByteArray().length);</span><br></pre></td></tr></table></figure>

<p>序列化大小：205<br>优点：java原生支持，不需要提供第三方的类库，使用比较简单。<br>缺点：无法跨语言，字节数占用比较大，某些情况下对于对象属性的变化比较敏感。</p>
<h1 id="把对象包装成JSON字符串传输"><a href="#把对象包装成JSON字符串传输" class="headerlink" title="把对象包装成JSON字符串传输"></a>把对象包装成JSON字符串传输</h1><p>JSON工具类有许多种，这里列出三个比较流行的json工具类：Jackson,Gson,FastJson.</p>
<h2 id="开源的Jackson"><a href="#开源的Jackson" class="headerlink" title="开源的Jackson"></a>开源的Jackson</h2><p>Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package serialize.json;</span><br><span class="line"> </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import org.codehaus.jackson.JsonEncoding;</span><br><span class="line">import org.codehaus.jackson.JsonGenerator;</span><br><span class="line">import org.codehaus.jackson.map.ObjectMapper;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"> </span><br><span class="line">import serialize.UserVo;</span><br><span class="line"> </span><br><span class="line">public class JacksonTest</span><br><span class="line">&#123;</span><br><span class="line">    private UserVo user = null;</span><br><span class="line">    private JsonGenerator jsonGenerator = null;</span><br><span class="line">    private ObjectMapper objectMapper = null;</span><br><span class="line"> </span><br><span class="line">    @Before</span><br><span class="line">    public void init()</span><br><span class="line">    &#123;</span><br><span class="line">        user = new UserVo();</span><br><span class="line">        user.setName(&quot;zzh&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line"> </span><br><span class="line">        UserVo f1 = new UserVo();</span><br><span class="line">        f1.setName(&quot;jj&quot;);</span><br><span class="line">        f1.setAge(17);</span><br><span class="line">        UserVo f2 = new UserVo();</span><br><span class="line">        f2.setName(&quot;qq&quot;);</span><br><span class="line">        f2.setAge(19);</span><br><span class="line"> </span><br><span class="line">        List&lt;UserVo&gt; friends = new ArrayList&lt;UserVo&gt;();</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line">        user.setFriends(friends);</span><br><span class="line"> </span><br><span class="line">        objectMapper = new ObjectMapper();</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            jsonGenerator = objectMapper.getJsonFactory().createJsonGenerator(System.out,JsonEncoding.UTF8);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @After</span><br><span class="line">    public void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            if(jsonGenerator != null)</span><br><span class="line">            &#123;</span><br><span class="line">                jsonGenerator.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!jsonGenerator.isClosed())</span><br><span class="line">            &#123;</span><br><span class="line">                jsonGenerator.close();</span><br><span class="line">            &#125;</span><br><span class="line">            jsonGenerator = null;</span><br><span class="line">            objectMapper = null;</span><br><span class="line">            user = null;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void writeJson()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            jsonGenerator.writeObject(user);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(objectMapper.writeValueAsBytes(user).length);</span><br><span class="line">           // System.out.println(objectMapper.writeValueAsString(user).length());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void readJson()</span><br><span class="line">    &#123;</span><br><span class="line">        String serString = &quot;&#123;\&quot;name\&quot;:\&quot;zzh\&quot;,\&quot;age\&quot;:18,\&quot;friends\&quot;:[&#123;\&quot;name\&quot;:\&quot;jj\&quot;,\&quot;age\&quot;:17,\&quot;friends\&quot;:null&#125;,&#123;\&quot;name\&quot;:\&quot;qq\&quot;,\&quot;age\&quot;:19,\&quot;friends\&quot;:null&#125;]&#125;&quot;;</span><br><span class="line">        UserVo uservo = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            uservo = objectMapper.readValue(serString, UserVo.class);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(uservo.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化大小：111</p>
<h2 id="Google的Gson"><a href="#Google的Gson" class="headerlink" title="Google的Gson"></a>Google的Gson</h2><p>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。<br>Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，<code>能够直接跑在JDK上</code>。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。Gson在功能上面无可挑剔，但是性能上面比FastJson有所差距。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package serialize.json;</span><br><span class="line"> </span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"> </span><br><span class="line">import com.google.gson.Gson;</span><br><span class="line">import com.google.gson.JsonSyntaxException;</span><br><span class="line"> </span><br><span class="line">import serialize.UserVo;</span><br><span class="line"> </span><br><span class="line">public class GsonTest</span><br><span class="line">&#123;</span><br><span class="line">    private UserVo user = null;</span><br><span class="line"> </span><br><span class="line">    @Before</span><br><span class="line">    public void init()</span><br><span class="line">    &#123;</span><br><span class="line">        user = new UserVo();</span><br><span class="line">        user.setName(&quot;zzh&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line"> </span><br><span class="line">        UserVo f1 = new UserVo();</span><br><span class="line">        f1.setName(&quot;jj&quot;);</span><br><span class="line">        f1.setAge(17);</span><br><span class="line">        UserVo f2 = new UserVo();</span><br><span class="line">        f2.setName(&quot;qq&quot;);</span><br><span class="line">        f2.setAge(19);</span><br><span class="line"> </span><br><span class="line">        List&lt;UserVo&gt; friends = new ArrayList&lt;UserVo&gt;();</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line">        user.setFriends(friends);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void writeJson()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            String str = Gson.class.newInstance().toJson(user);//一行就可以搞定！！！</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InstantiationException | IllegalAccessException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test public void readJson()</span><br><span class="line">    &#123;</span><br><span class="line">        String serString = &quot;&#123;\&quot;name\&quot;:\&quot;zzh\&quot;,\&quot;age\&quot;:18,\&quot;friends\&quot;:[&#123;\&quot;name\&quot;:\&quot;jj\&quot;,\&quot;age\&quot;:17&#125;,&#123;\&quot;name\&quot;:\&quot;qq\&quot;,\&quot;age\&quot;:19&#125;]&#125;&quot;;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            UserVo userVo = Gson.class.newInstance().fromJson(serString, UserVo.class);</span><br><span class="line">            System.out.println(userVo.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (JsonSyntaxException | InstantiationException | IllegalAccessException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化大小：81</p>
<blockquote>
<p>Gson和Jackson的区别是：如果你的应用经常会处理大的JSON文件，那么Jackson应该是你的菜。GSON在大文件上表现得相当吃力。如果你主要是处理小文件请求，比如某个微服务或者分布式架构的初始化，那么GSON当是首选。Jackson在小文件上的表现则不如人意。</p>
</blockquote>
<h2 id="阿里巴巴的FastJson"><a href="#阿里巴巴的FastJson" class="headerlink" title="阿里巴巴的FastJson"></a>阿里巴巴的FastJson</h2><p>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，<code>能够直接跑在JDK上</code>。<br>FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package serialize.json;</span><br><span class="line"> </span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"> </span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line"> </span><br><span class="line">import serialize.UserVo;</span><br><span class="line"> </span><br><span class="line">public class FastJsonTest</span><br><span class="line">&#123;</span><br><span class="line">    private UserVo user = null;</span><br><span class="line"> </span><br><span class="line">    @Before</span><br><span class="line">    public void init()</span><br><span class="line">    &#123;</span><br><span class="line">        user = new UserVo();</span><br><span class="line">        user.setName(&quot;zzh&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line"> </span><br><span class="line">        UserVo f1 = new UserVo();</span><br><span class="line">        f1.setName(&quot;jj&quot;);</span><br><span class="line">        f1.setAge(17);</span><br><span class="line">        UserVo f2 = new UserVo();</span><br><span class="line">        f2.setName(&quot;qq&quot;);</span><br><span class="line">        f2.setAge(19);</span><br><span class="line"> </span><br><span class="line">        List&lt;UserVo&gt; friends = new ArrayList&lt;UserVo&gt;();</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line">        user.setFriends(friends);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test public void writeJson()</span><br><span class="line">    &#123;</span><br><span class="line">        String str = JSON.toJSONString(user);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test public void readJson()</span><br><span class="line">    &#123;</span><br><span class="line">        String serString = &quot;&#123;\&quot;name\&quot;:\&quot;zzh\&quot;,\&quot;age\&quot;:18,\&quot;friends\&quot;:[&#123;\&quot;name\&quot;:\&quot;jj\&quot;,\&quot;age\&quot;:17&#125;,&#123;\&quot;name\&quot;:\&quot;qq\&quot;,\&quot;age\&quot;:19&#125;]&#125;&quot;;</span><br><span class="line">        UserVo userVo = JSON.parseObject(serString,UserVo.class);</span><br><span class="line">        System.out.println(userVo.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果只是功能要求，没有性能要求，可以使用google的Gson，如果有性能上面的要求可以使用Gson将bean转换json确保数据的正确，使用FastJson将Json转换Bean。</p>
</blockquote>
<h1 id="Google工具protoBuf"><a href="#Google工具protoBuf" class="headerlink" title="Google工具protoBuf"></a>Google工具protoBuf</h1><p>protocol buffers 是google内部得一种传输协议，目前项目已经开源。它定义了一种紧凑得可扩展得<code>二进制协议格式，适合网络传输，并且针对多个语言有不同得版本可供选择</code>。<br>protoBuf优点：1.性能好，效率高；2.代码生成机制，数据解析类自动生成；3.支持向前兼容和向后兼容；4.支持多种编程语言；5.字节数很小，适合网络传输节省io。缺点：1.应用不够广；2.二进制格式导致可读性差；3.缺乏自描述；<br>protoBuf是需要编译工具的，这里用的是window的系统。需要下载proto.exe和protobuf-java-2.4.1.jar；<br>1、将proto.exe放在当前工程目录下，然后编辑.proto文件，命名为UserVo.proto,如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package serialize.protobuf;</span><br><span class="line"> </span><br><span class="line">option java_package = &quot;serialize.protobuf&quot;;</span><br><span class="line">option java_outer_classname=&quot;UserVoProtos&quot;;</span><br><span class="line"> </span><br><span class="line">message UserVo</span><br><span class="line">&#123;</span><br><span class="line">    optional string name = 1;</span><br><span class="line">    optional int32 age = 2;</span><br><span class="line">    repeated serialize.protobuf.UserVo friends = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在命令行中利用protoc工具生成builder类<br>3、看到生成了<code>UserVoProtos.java</code>，由于这个java文件有1千行左右，篇幅限制不便罗列。<br>4、序列化和反序列化测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package serialize.protobuf;</span><br><span class="line"> </span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"> </span><br><span class="line">import com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"> </span><br><span class="line">public class ProtoBufTest</span><br><span class="line">&#123;</span><br><span class="line">    UserVoProtos.UserVo.Builder user = null;</span><br><span class="line"> </span><br><span class="line">    @Before public void init()</span><br><span class="line">    &#123;</span><br><span class="line">        user = UserVoProtos.UserVo.newBuilder();</span><br><span class="line">        user.setName(&quot;zzh&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line"> </span><br><span class="line">        UserVoProtos.UserVo.Builder f1 = UserVoProtos.UserVo.newBuilder();</span><br><span class="line">        f1.setName(&quot;jj&quot;);</span><br><span class="line">        f1.setAge(17);</span><br><span class="line"> </span><br><span class="line">        UserVoProtos.UserVo.Builder f2 = UserVoProtos.UserVo.newBuilder();</span><br><span class="line">        f2.setName(&quot;qq&quot;);</span><br><span class="line">        f2.setAge(19);</span><br><span class="line"> </span><br><span class="line">        user.addFriends(f1);</span><br><span class="line">        user.addFriends(f2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test public void doSeri()</span><br><span class="line">    &#123;</span><br><span class="line">        UserVoProtos.UserVo vo = user.build();</span><br><span class="line">        byte[] v = vo.toByteArray();</span><br><span class="line">        for(byte b:v)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(&quot;%02X &quot;,b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(v.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Test public void doDeSeri()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] v = new byte[]&#123;0x0A, 0x03, 0x7A, 0x7A, 0x68, 0x10, 0x12, 0x1A, 0x06, 0x0A, 0x02, 0x6A, 0x6A, 0x10, 0x11, 0x1A, 0x06, 0x0A, 0x02, 0x71, 0x71, 0x10, 0x13&#125;;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            UserVoProtos.UserVo uvo = UserVoProtos.UserVo.parseFrom(v);</span><br><span class="line">            System.out.println(uvo.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InvalidProtocolBufferException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化大小：23<br>工作机制：proto文件是对数据的一个描述，包括字段名称，类型，字节中的位置。<br>protoc工具读取proto文件生成对应builder代码的类库。protoc xxxxx –java_out&#x3D;xxxxxx 生成java类库。<br>builder类根据自己的算法把数据序列化成字节流，或者把字节流根据反射的原理反序列化成对象</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Java的接口和抽象类</title>
    <url>/2017/04/20/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br><code>abstract void fun();</code></p>
<p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以<code>不能用抽象类创建对象</code>。</p>
<p>下面要注意一个问题：在《Java编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说<code>抽象类不一定必须含有抽象方法</code>。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧，不必去深究为什么。</p>
<p>从这里可以看出，抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。<code>对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了</code>。</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：<br>1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象；<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。</p>
<p>接口中可以含有 变量和方法。但是要注意，<code>接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）</code>，并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p>
<p>允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><h2 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h2><p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h2 id="设计层面上的区别"><a href="#设计层面上的区别" class="headerlink" title="设计层面上的区别"></a>设计层面上的区别</h2><p>1）<code>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象</code>。<br>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<code>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系</code>。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<h2 id="设计层面不同"><a href="#设计层面不同" class="headerlink" title="设计层面不同"></a>设计层面不同</h2><p><code>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计</code>。<br>什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说<code>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动</code>。</p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class Door &#123;</span><br><span class="line">    public abstract void open();</span><br><span class="line">    public abstract void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Door &#123;</span><br><span class="line">    public abstract void open();</span><br><span class="line">    public abstract void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：<br>1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；<br>2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>
<p>从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Alram &#123;</span><br><span class="line">    void alarm();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abstract class Door &#123;</span><br><span class="line">    void open();</span><br><span class="line">    void close();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class AlarmDoor extends Door implements Alarm &#123;</span><br><span class="line">    void oepn() &#123;</span><br><span class="line">      //....</span><br><span class="line">    &#125;</span><br><span class="line">    void close() &#123;</span><br><span class="line">      //....</span><br><span class="line">    &#125;</span><br><span class="line">    void alarm() &#123;</span><br><span class="line">      //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>深入分析Synchronised实现原理</title>
    <url>/2017/04/18/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronised%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h1><p>Java中的每一个对象都可以作为锁，而在Synchronized实现同步的几种方式中分别为：<br>普通同步方法：锁是当前实例对象<br>静态同步方法：锁是当前类的Class对象<br>同步方法块：锁是Synchronized括号里配置的对象</p>
<p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。<br>Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p>
<blockquote>
<p>尝试获取对象的锁，即尝试通过CAS指令将对象的对象头中mark word字段（成为锁的对象的这个字段此时会存储锁信息）指向线程栈帧上的Monitor Record<br>CAS：COMPARE AND SET。赋值时首先比较该值有没有变化，在没有变化的情况下才进行赋值。</p>
</blockquote>
<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p><code>synchronized使用的锁是存放在Java对象头里面，具体位置是对象头里面的MarkWord</code>，MarkWord里默认数据是存储对象的HashCode等信息，但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式</p>
<blockquote>
<p>当对象成为锁（被锁住）后，对象头里的mark word字段就会存储Monitor信息，Monitor信息可以理解为锁信息</p>
</blockquote>
<h1 id="Monitor-Record（锁记录）"><a href="#Monitor-Record（锁记录）" class="headerlink" title="Monitor Record（锁记录）"></a>Monitor Record（锁记录）</h1><p>每个线程都会有自己的虚拟机栈。每执行一个方法对应一个栈帧入栈。栈帧上有一部分空间用来存储monitor record。当执行加锁方法时，线程间会竞争锁对象。竞争成功的线程，它的栈帧上的monitor record会与锁对象关联，方式是锁对象的对象头的MarkWord中的LockWord指向monitor record的起始地址，同时monitor record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用</p>
<p>Monitor Recoder字段：</p>
<ul>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li>
<li>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li>Nest:用来实现重入锁的计数。</li>
<li>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ul>
<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>Java SE1.6里锁一共有四种状态，<code>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</code>，它会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p>
<blockquote>
<p>每种类型对应的锁对象的对象头中的mark word字段内容不同</p>
</blockquote>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p>
<p>加锁：当一个线程访问同步块并获取锁时，会在对象头和monitor record里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程（此时会引发竞争，偏向锁会升级为轻量级锁）。</p>
<p>解锁：偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程</p>
<p>优缺点：<br>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。<br>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</p>
<p>使用场景：适用于只有一个线程访问同步块场景。</p>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>引入背景：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</p>
<p>加锁：<br>（1）当对象处于无锁状态时（RecordWord值为HashCode，状态位为001），线程首先从自己的可用moniter record列表中取得一个空闲的moniter record，初始Nest和Owner值分别被预先设置为1和该线程自己的标识，一旦monitor record准备好然后我们通过CAS原子指令安装该monitor record的起始地址到对象头的LockWord字段，如果存在其他线程竞争锁的情况而调用CAS失败，则只需要简单的回到monitorenter重新开始获取锁的过程即可。</p>
<p>（2）对象已经被膨胀同时Owner中保存的线程标识为获取锁的线程自己，这就是重入（reentrant）锁的情况，只需要简单的将Nest加1即可。不需要任何原子操作，效率非常高。</p>
<p>（3）对象已膨胀但Owner的值为NULL，当一个锁上存在阻塞或等待的线程同时锁的前一个拥有者刚释放锁时会出现这种状态，此时多个线程通过CAS原子指令在多线程竞争状态下试图将Owner设置为自己的标识来获得锁，竞争失败的线程在则会进入到第四种情况（4）的执行路径。</p>
<p>（4）对象处于膨胀状态同时Owner不为NULL(被锁住)，在调用操作系统的重量级的互斥锁之前先自旋一定的次数，当达到一定的次数时如果仍然没有成功获得锁，则开始准备进入阻塞状态，首先将rfThis的值原子性的加1，由于在加1的过程中可能会被其他线程破坏Object和monitor record之间的关联，所以在原子性加1后需要再进行一次比较以确保LockWord的值没有被改变，当发现被改变后则要重新monitorenter过程。同时再一次观察Owner是否为NULL，如果是则调用CAS参与竞争锁，锁竞争失败则进入到阻塞状态。</p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争</p>
<p>优缺点：<br>竞争的线程不会阻塞，提高了程序的响应速度<br>如果始终得不到锁竞争的线程使用自旋会消耗CPU</p>
<p>使用场景：追求响应时间，同步块执行速度非常快</p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>优缺点：<br>线程竞争不使用自旋，不会消耗CPU。<br>线程阻塞，响应时间缓慢。</p>
<p>使用场景：追求吞吐量。同步块执行速度较长。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解List实现类的原理</title>
    <url>/2017/04/20/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><blockquote>
<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。<br>按数组下标访问元素—get(i)&#x2F;set(i,e) 的性能很高，这是数组的基本优势。<br>直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
</blockquote>
<p>ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。</p>
<p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><blockquote>
<p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。<br>按下标访问元素—get(i)&#x2F;set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。<br>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。</p>
</blockquote>
<p>添加删除操作会判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n&#x2F;2)。</p>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>线程中断详解</title>
    <url>/2021/04/30/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>原文：<br><a href="https://blog.csdn.net/xinxiaoyong100440105/article/details/80931705">https://blog.csdn.net/xinxiaoyong100440105/article/details/80931705</a></p>
<h1 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h1><p>线程的thread.interrupt()方法是中断线程，将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。</p>
<h1 id="判断线程是否被中断"><a href="#判断线程是否被中断" class="headerlink" title="判断线程是否被中断"></a>判断线程是否被中断</h1><p>判断某个线程是否已被发送过中断请求，请使用Thread.currentThread().isInterrupted()方法（因为它将线程中断标示位设置为true后，不会立刻清除中断标示位，即不会将中断标设置为false），而不要使用thread.interrupted()（该方法调用后会将中断标示位清除，即重新设置为false）方法来判断，下面是线程在循环中时的中断方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do)&#123;</span><br><span class="line">    do more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h1><p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I&#x2F;O 操作方法后可进入阻塞状态），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I&#x2F;O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false。抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。</p>
<p>注意，synchronized在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断。与synchronized功能相似的reentrantLock.lock()方法也是一样，它也不可中断的，即如果发生死锁，那么reentrantLock.lock()方法无法终止，如果调用时被阻塞，则它一直阻塞到它获取到锁为止。但是如果调用带超时的tryLock方法reentrantLock.tryLock(long timeout, TimeUnit unit)，那么如果线程在等待时被中断，将抛出一个InterruptedException异常，这是一个非常有用的特性，因为它允许程序打破死锁。你也可以调用reentrantLock.lockInterruptibly()方法，它就相当于一个超时设为无限的tryLock方法。</p>
<p>没有任何语言方面的需求一个被中断的线程应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断。某些线程非常重要，以至于它们应该不理会中断，而是在处理完抛出的异常之后继续执行，但是更普遍的情况是，一个线程将把中断看作一个终止请求，这种线程的run方法遵循如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        /*</span><br><span class="line">         * 不管循环里是否调用过线程阻塞的方法如sleep、join、wait，这里还是需要加上</span><br><span class="line">         * !Thread.currentThread().isInterrupted()条件，虽然抛出异常后退出了循环，显</span><br><span class="line">         * 得用阻塞的情况下是多余的，但如果调用了阻塞方法但没有阻塞时，这样会更安全、更及时。</span><br><span class="line">         */</span><br><span class="line">        while (!Thread.currentThread().isInterrupted()&amp;&amp; more work to do) &#123;</span><br><span class="line">            do more work </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        //线程在wait或sleep期间被中断了</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //线程结束前做一些清理工作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="底层中断异常处理方式"><a href="#底层中断异常处理方式" class="headerlink" title="底层中断异常处理方式"></a>底层中断异常处理方式</h1><p>不要在你的底层代码里捕获InterruptedException异常后不处理，会处理不当，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void mySubTask()&#123;</span><br><span class="line">    ...</span><br><span class="line">    try&#123;</span><br><span class="line">        sleep(delay);</span><br><span class="line">    &#125;catch(InterruptedException e)&#123;&#125;//不要这样做</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不知道抛InterruptedException异常后如何处理，那么你有如下好的建议处理方式：<br>1、在catch子句中，调用Thread.currentThread.interrupt()来设置中断状态（因为抛出异常后中断标示会被清除），让外界通过判断Thread.currentThread().isInterrupted()标示来决定是否终止线程还是继续下去，应该这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void mySubTask() &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        sleep(delay);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、或者，更好的做法就是，不使用try来捕获这样的异常，让方法直接抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void mySubTask() throws InterruptedException &#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈HashMap线程不安全的体现</title>
    <url>/2017/04/20/blog_article/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/%E8%B0%88%E8%B0%88HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%93%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="resize死循环"><a href="#resize死循环" class="headerlink" title="resize死循环"></a>resize死循环</h1><p>我们都知道HashMap初始容量大小为16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概看下transfer：<br>1、对索引数组中的元素遍历<br>2、对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。<br>3、循环2，直到链表节点全部转移<br>4、循环1，直到所有索引数组全部转移<br>经过这几步，我们会发现<code>转移的时候是逆序的。假如转移前链表顺序是1-&gt;2-&gt;3，那么转移后就会变成3-&gt;2-&gt;1</code>。这时候就有点头绪了，<code>死锁问题不就是因为1-&gt;2的同时2-&gt;1造成的吗？</code>所以，HashMap 的死锁问题就出在这个transfer()函数上。</p>
<h2 id="单线程-rehash-详细演示"><a href="#单线程-rehash-详细演示" class="headerlink" title="单线程 rehash 详细演示"></a>单线程 rehash 详细演示</h2><p>单线程情况下，rehash 不会出现任何问题：<br>假设hash算法就是最简单的 key mod table.length（也就是数组的长度）。<br>最上面的是old hash 表，其中的Hash表的 size &#x3D; 2, 所以 key &#x3D; 3, 7, 5，在 mod 2以后碰撞发生在 table[1]<br>接下来的三个步骤是 Hash表 resize 到4，并将所有的 &lt;key,value&gt; 重新rehash到新 Hash 表的过程</p>
<h2 id="多线程-rehash-详细演示"><a href="#多线程-rehash-详细演示" class="headerlink" title="多线程 rehash 详细演示"></a>多线程 rehash 详细演示</h2><p>为了思路更清晰，我们只将关键代码展示出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(null != e) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、Entry&lt;K,V&gt; next &#x3D; e.next;——因为是单链表，如果要转移头指针，一定要保存下一个结点，不然转移后链表就丢了<br>2、e.next &#x3D; newTable[i];——e 要插入到链表的头部，所以要先用 e.next 指向新的 Hash 表第一个元素（为什么不加到新链表最后？因为复杂度是 O（N））<br>3、newTable[i] &#x3D; e;——现在新 Hash 表的头指针仍然指向 e 没转移前的第一个元素，所以需要将新 Hash 表的头指针指向 e<br>4、e &#x3D; next——转移 e 的下一个结点</p>
<p>假设这里有两个线程同时执行了put()操作，并进入了transfer()环节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(null != e) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; //线程1执行到这里被调度挂起了</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在的状态为：<br>从上面的图我们可以看到，因为线程1的 e 指向了 key(3)，而 next 指向了 key(7)，在线程2 rehash 后，就指向了线程2 rehash 后的链表。</p>
<p>然后线程1被唤醒了：<br>1、执行e.next &#x3D; newTable[i]，于是 key(3)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next &#x3D; null，<br>2、执行newTable[i] &#x3D; e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(3)。好了，e 处理完毕。<br>3、执行e &#x3D; next，将 e 指向 next，所以新的 e 是 key(7)</p>
<p>然后该执行 key(3)的 next 节点 key(7)了:<br>1、现在的 e 节点是 key(7)，首先执行Entry&lt;K,V&gt; next &#x3D; e.next,那么 next 就是 key(3)了<br>2、执行e.next &#x3D; newTable[i]，于是key(7) 的 next 就成了 key(3)<br>3、执行newTable[i] &#x3D; e，那么线程1的新 Hash 表第一个元素变成了 key(7)<br>4、执行e &#x3D; next，将 e 指向 next，所以新的 e 是 key(3)</p>
<p>这时候的状态图为：</p>
<p>然后又该执行 key(7)的 next 节点 key(3)了：<br>1、现在的 e 节点是 key(3)，首先执行Entry&lt;K,V&gt; next &#x3D; e.next,那么 next 就是 null<br>2、执行e.next &#x3D; newTable[i]，于是key(3) 的 next 就成了 key(7)<br>3、执行newTable[i] &#x3D; e，那么线程1的新 Hash 表第一个元素变成了 key(3)<br>4、执行e &#x3D; next，将 e 指向 next，所以新的 e 是 key(7)<br>这时候的状态如图所示：<br>很明显，环形链表出现了！！当然，现在还没有事情，因为下一个节点是 null，所以transfer()就完成了，等put()的其余过程搞定后，HashMap 的底层实现就是线程1的新 Hash 表了。</p>
<blockquote>
<p>多线程情况下，当多个线程rehash时，每个线程都会扩容并将原来的Entry放到新的数组里。然而，多个线程共享HashMap中的Entry，但又自己维护自己的链表数组，而且rehash会造成存储的是原来链表的逆，所以会导致环形链表的出现！</p>
</blockquote>
]]></content>
      <categories>
        <category>好文转载</category>
      </categories>
  </entry>
  <entry>
    <title>Spring好用的工具类</title>
    <url>/2022/04/18/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/Spring%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>1、org.springframework.core.io.support.PropertiesLoaderUtils#loadAllProperties(java.lang.String, java.lang.ClassLoader)</p>
<ul>
<li>org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#getHandlerMappings</li>
</ul>
<p>2、org.springframework.util.CollectionUtils#mergePropertiesIntoMap</p>
<ul>
<li>org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#getHandlerMappings</li>
</ul>
<p>3、org.springframework.beans.BeanUtils#instantiateClass(java.lang.Class<T>)</p>
<ul>
<li>org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#resolve</li>
</ul>
<p>4、org.springframework.util.ClassUtils#getMethodCountForName</p>
<ul>
<li>org.springframework.beans.factory.support.AbstractBeanDefinition#prepareMethodOverride</li>
</ul>
<p>5、org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods</p>
<ul>
<li>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getTypeForFactoryMethod</li>
</ul>
<p>6、org.springframework.util.ReflectionUtils#getAllDeclaredMethods</p>
<p>7、org.springframework.beans.BeanUtils#isSimpleProperty</p>
<ul>
<li>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#unsatisfiedNonSimpleProperties</li>
</ul>
<p>8、org.springframework.beans.factory.support.AbstractBeanFactory#containsBean</p>
<ul>
<li>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByName</li>
</ul>
<p>9、org.springframework.beans.factory.BeanFactoryUtils#beanNamesForTypeIncludingAncestors(org.springframework.beans.factory.ListableBeanFactory, java.lang.Class&lt;?&gt;, boolean, boolean)</p>
<ul>
<li>org.springframework.beans.factory.support.DefaultListableBeanFactory#findAutowireCandidates</li>
</ul>
<p>10、org.springframework.util.LinkedMultiValueMap</p>
<ul>
<li>org.springframework.core.io.support.SpringFactoriesLoader#loadSpringFactories</li>
</ul>
<p>11、org.springframework.core.io.support.PropertiesLoaderUtils#loadProperties(org.springframework.core.io.Resource)</p>
<ul>
<li>org.springframework.core.io.support.SpringFactoriesLoader#loadSpringFactories</li>
</ul>
<p>12、org.springframework.util.StringUtils#commaDelimitedListToStringArray</p>
<ul>
<li>org.springframework.core.io.support.SpringFactoriesLoader#loadSpringFactories</li>
</ul>
<p>13、org.springframework.util.ReflectionUtils#accessibleConstructor</p>
<ul>
<li>org.springframework.core.io.support.SpringFactoriesLoader#instantiateFactory</li>
</ul>
<p>14、org.springframework.core.annotation.AnnotationUtils#getAnnotation(java.lang.reflect.AnnotatedElement, java.lang.Class<A>)</p>
<ul>
<li>org.springframework.core.annotation.AnnotationAwareOrderComparator#findOrder</li>
</ul>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
  </entry>
  <entry>
    <title>redis实践</title>
    <url>/2022/11/21/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/redis%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>登录官网，redis.io，找到 mac 方式安装。推荐 Homebrew</p>
<p>安装后的 redis 路径：&#x2F;opt&#x2F;homebrew&#x2F;Cellar&#x2F;redis&#x2F;7.0.5<br>配置文件路径：&#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf</p>
<p>启动 redis 服务：redis-server<br>登录 redis 客户端命令行：redis-cli</p>
<ul>
<li>关闭 redis：shutdown</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li>set K V</li>
<li>get K V</li>
<li>mset K1 V1 K2 V2</li>
<li>mget K1 K2</li>
<li>getset K V<ul>
<li>先 get 旧值，然后 set</li>
</ul>
</li>
<li>setnx K V<ul>
<li>不存在 K，才执行 set</li>
</ul>
</li>
<li>STRLEN K<ul>
<li>获取 K 对应 V 的字符串长度</li>
</ul>
</li>
<li>append K V<ul>
<li>K 对应的 Value 后面增加字符串，没有 Value 则新增的字符串作为 Value</li>
</ul>
</li>
<li>incr K<ul>
<li>K 的 value+1，如果之前没有 set，K 的 value 执行后为 1</li>
</ul>
</li>
<li>incrby K V<ul>
<li>K 的 value+V，value 必须为数字，V 可以任意</li>
</ul>
</li>
<li>decr K</li>
<li>decrby K V</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>存储的 value 类型是一个 List。Redis 中的 List 数据结构本质是通过双向链表实现的</p>
<ul>
<li>lpush K V1 V2 V3<ul>
<li>从左侧 push，因此实际存储的顺序为 V3 V2 V1</li>
</ul>
</li>
<li>rpush K V1 V2 V3</li>
<li>lpop K {count}<ul>
<li>从左侧 pop，count 表示 pop 的个数</li>
</ul>
</li>
<li>rpop K {count}</li>
<li>blpop K {timeoutSeconds}<ul>
<li>如果 pop 失败会一直阻塞指定秒数，直到 pop 成功</li>
</ul>
</li>
<li>brpop K {timeoutSeconds}</li>
<li>rpoplpush K K1<ul>
<li>从 K 列表的右侧 pop，左侧 push 到 K1 列表</li>
</ul>
</li>
<li>brpoplpush K K1 {timeoutSeconds}</li>
<li>lrange K {start} {end}<ul>
<li>获取指定范围内的元素。start&#x3D;0 表示起始位置，end&#x3D;-1 表示终止位置</li>
</ul>
</li>
<li>llen K<ul>
<li>K 列表的长度</li>
</ul>
</li>
<li>lindex K {index}<ul>
<li>获取指定索引上的元素</li>
</ul>
</li>
<li>linsert K before|after {element} {newElement}<ul>
<li>在指定元素前或后插入新元素</li>
</ul>
</li>
<li>lset K {index} {newElement}<ul>
<li>指定索引处设置新元素</li>
</ul>
</li>
<li>ltrim K {start} {end}<ul>
<li>裁剪列表，只保留 start 下标到 end 下标区间的元素</li>
</ul>
</li>
<li>lrem K {count} {element}<ul>
<li>从左侧开始删除指定个数的某个元素</li>
</ul>
</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>存储的 value 类型是一个 Set。redis 的 set 数据类型底层基于 HashSet</p>
<ul>
<li>sadd K V1 V2 V3</li>
<li>smembers K<ul>
<li>获取集合的所有元素</li>
</ul>
</li>
<li>srem K {element}<ul>
<li>删除指定元素</li>
</ul>
</li>
<li>smove K1 K2 {element}<ul>
<li>把元素从 K1 集合移动到 K2 集合</li>
</ul>
</li>
<li>scard K<ul>
<li>获取集合中的元素数量</li>
</ul>
</li>
<li>sismember K {element}<ul>
<li>判断元素是否在集合里，返回 1 表示存在，0 表示不存在</li>
</ul>
</li>
<li>srandmember K<ul>
<li>从集合里随机获取一个元素</li>
</ul>
</li>
<li>spop K {count}<ul>
<li>随机从集合中移除指定数量的元素</li>
</ul>
</li>
<li>sinter K1 K2<ul>
<li>返回 K1 和 K2 的交集</li>
</ul>
</li>
<li>sunion K1 K2<ul>
<li>返回 K1 和 K2 的并集</li>
</ul>
</li>
<li>sdiff K1 K2<ul>
<li>返回只在 K1 里的元素</li>
</ul>
</li>
<li>sinterstore K3 K1 K2<ul>
<li>集合 K1 和 K2 的交集存储到 K3</li>
</ul>
</li>
<li>sunionstore K3 K1 K2</li>
<li>sdiffstore K3 K1 K2</li>
</ul>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>存储的 value 类型是一个 zet。zset 简单理解就是通过权重实现排序的集合</p>
<ul>
<li>zadd K {score1} V1 {score2} V2<ul>
<li>添加带权重的元素</li>
</ul>
</li>
<li>zrem K {element}</li>
<li>zrange K {start} {end} withscores<ul>
<li>获取排序后的指定下标区间内的集合元素，排序默认按 score 升序</li>
</ul>
</li>
<li>zrevrange K {start} {end}<ul>
<li>获取逆序排序后的指定下标区间内的集合元素</li>
</ul>
</li>
<li>zrank K {element}<ul>
<li>获取元素排序后的下标，默认升序</li>
</ul>
</li>
<li>zrevrank K {element}</li>
<li>zrangebyscore K {minScore} {maxScore}<ul>
<li>获取权重范围内排序的所有元素</li>
</ul>
</li>
<li>zrangebylex K [a (z<ul>
<li>返回在首字母区间内排序的所有元素，”[“表示包含，”(“表示不包含。</li>
</ul>
</li>
<li>zrevrangebyscore K {maxScore} {minScore}</li>
<li>zcount K {minScore} {maxScore}</li>
<li>zlexcount K [a (z</li>
<li>zremrangebyrank K {start} {end}<ul>
<li>从集合移除开始到结束下标范围内的元素</li>
</ul>
</li>
<li>zremrangebyscore K {minScore} {maxScore}<ul>
<li>从集合移除权重范围内的元素</li>
</ul>
</li>
<li>zremrangebylex K [a (z</li>
<li>zunionstore K3 {zsetCounts} {zset1} {zset2} …<ul>
<li>取并集把结果存储到新的 zset，相同元素的权重会相加</li>
</ul>
</li>
<li>zinterstore K3 {zsetCounts} {zset1} {zset2} …<ul>
<li>取交集把结果存储到新的 zset，相同元素的权重会相加</li>
</ul>
</li>
<li>zpopmax K<ul>
<li>pop 权重最大的元素</li>
</ul>
</li>
<li>zpopmin K</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>存储的 value 类型是一个 hashMap。</p>
<ul>
<li>hset K {key1} {value1} {key2} {value2} …</li>
<li>hget K {key1}</li>
<li>hmget K {key1} {key2} …</li>
<li>hsetnx K {key1} {value1}</li>
<li>hincrby K {key1} {incrment}</li>
<li>hstrlen K {key1}</li>
<li>hexists K {key1}<ul>
<li>返回 1 表示存在，0 表示不存在</li>
</ul>
</li>
<li>hdel K {key1}</li>
<li>hlen K</li>
<li>hgetall K</li>
<li>hkeys K</li>
<li>hvals K</li>
</ul>
<h2 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h2><p>经纬度相关操作</p>
<ul>
<li>geoadd K {经度} {纬度} {member}<ul>
<li>添加地理位置，例如：geoadd china 115.7 39.4 beijing</li>
</ul>
</li>
<li>geopos K {member}<ul>
<li>读取经纬度</li>
</ul>
</li>
<li>geodist K {member1} {member2} {M&#x2F;KM}<ul>
<li>计算两地的距离</li>
</ul>
</li>
<li>georadiusbymember K {member} {distance} {M&#x2F;KM}<ul>
<li>查询距离某地指定距离范围内的所有地点</li>
</ul>
</li>
</ul>
<h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><p>bitmap 本质也是 String 类型的数据结构，使用 bitmap 可以对 String 底层的比特位置 0 或 1。因此他有两个特定：非常省存储空间、适合大数据量二值统计<br>因为 redis 中 String 最大长度 512M，因此 bitmap 最多能存储 2^32 个 bit</p>
<ul>
<li>setbit K {offset} {0&#x2F;1}</li>
<li>getbit K {offset}</li>
<li>bitcount K<ul>
<li>统计 bit 为 1 的个数</li>
</ul>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h2><p>rdb 持久化，指生成二进制 rdb 文件来存储内存中的 snapshot 数据</p>
<ul>
<li>优点：压缩效率高、数据恢复快</li>
<li>缺点：无法做到实时（秒级）持久化、可读性差<ul>
<li>redis 默认按一定持久化策略定期执行</li>
</ul>
</li>
</ul>
<p>查询 rdb 文件路径命令：config get dir</p>
<h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><p>执行 bgsave 命令会触发 rdb 持久化</p>
<ul>
<li>fork 子进程，后台执行 snapshot 持久化，不阻塞 redis 主线程。持久化结束后子进程退出<ul>
<li>持久化过程：将当前时刻内存中的数据（snapshot 数据）压缩成二进制 rdb 文件，然后替代（如果存在）原 rdb 文件</li>
</ul>
</li>
<li>如果执行命令：flushdb 后再执行 bgsave，因为 flushdb 会清空内存 snapshot，所以持久化后的 rdb 文件没有数据</li>
</ul>
<p>bgsave 使用 COW 的思想减少内存使用。COW（copy on write）是一种简单的读写分离思想，只有在写操作时才会复制一份数据，原数据继续接收读请求，在复制的空间写完后替代原内存空间（修改指针），在读多写少的场景可以显著提高并发度和内存利用率</p>
<ul>
<li>由此可知，COW 保证的是最终一致性而非强一致性</li>
</ul>
<p>借鉴 COW 方式，fork 的子进程并没有自己的物理内存空间，而是和主进程共用一份内存空间。只有当主进程有写操作时，才会复制一份写操作对应的内存页到子进程，主进程可以继续处理写操作。所以极端情况下，bgsave 期间如果没有写操作，是不会发生内存复制的，能提高性能和内存利用率</p>
<ul>
<li>由此可知，bgsave 不会阻塞主线程，可以继续处理读写操作，但 bgsave 开始后新写入内存的增量数据不会被持久化到 rdb 文件</li>
</ul>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>执行 save 命令也会触发 rdb 持久化，和 bgsave 的区别是他不会 fork 子进程，而是直接阻塞主线程直到持久化结束</p>
<p>redis.conf 配置文件里指定了 redis 默认的 rdb 持久化策略，满足策略会自动触发执行 save 命令：</p>
<ul>
<li>After 3600 seconds (an hour) if at least 1 change was performed</li>
<li>After 300 seconds (5 minutes) if at least 100 changes were performed</li>
<li>After 60 seconds if at least 10000 changes were performed</li>
</ul>
<p>如果修改这个策略，放开注释<code># save 3600 1 300 100 60 10000</code>，并修改参数</p>
<p>上面的持久化策略针对的是 redis 运行态，在 redis 关闭、主从复制阶段也会持久化：</p>
<ul>
<li>redis-server 端执行 shuntdown 阶段（CTRL+C 后），会将最后的 snapshot 持久化为 rdb 文件保存到磁盘</li>
<li>主从复制阶段会生成 rdb 文件</li>
</ul>
<p>RDB 文件的载入工作是在服务器启动时自动执行的，所以 Redis 并没有专门用于载入 RDB 文件的命令</p>
<h2 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h2><p>rdb 最大的问题是时效性差，宕机丢失的数据比较多，aof 提供了一种近实时的持久化方案</p>
<p>aof（append only file）会把客户端发送的命令追加（append）到 aof 文件，重启 redis 后，aof 文件里的命令会被重新执行一遍来重建数据</p>
<ul>
<li>aof 默认是关闭的，改 redis.conf 的 appendonly，置为 yes 来开启 aof</li>
<li>如果存在 aof 文件，会优先使用 aof 来重建数据，即优先级高于 rdb</li>
</ul>
<p>aof 刷盘的频率由 redis.conf 的 appendfsync 值控制，redis 提供三种策略：</p>
<ul>
<li>always，每次执行完客户端命令，都会执行刷盘操作。实时性最好，但效率不高</li>
<li>everysec，每隔 1 秒执行一次刷盘操作，1 秒内的命令都暂存在内核缓冲区。实时性和效率的折中，redis 默认使用这种策略</li>
<li>no，由操作系统控制刷盘时机，只有当内核缓冲区积累了一定的数据才执行。效率最高，实时性最差，宕机丢的数据最多</li>
</ul>
<p>当启用 aof，关闭 redis 服务器时会强制执行一次刷盘</p>
<p>aof 会记录每条客户端命令，如果不加优化，aof 文件过大会对服务器造成影响，因此有了 aof 重写<br>所谓 aof 重写，指 redis 启动一个子进程，把当前时刻的内存数据库快照生成对应的 redis 命令，写到一个新的 aof 文件里</p>
<ul>
<li>如果 aof 重写期间有新的写指令，会双写到原 aof 文件和新 aof 文件的内核缓冲区，等 aof 重写完成了，再刷盘到新 aof 文件里，然后替代原来的 aof 文件，这就保证了重写 aof 文件依然有很高的时效性，且假设重写失败，原 aof 文件也不会丢指令</li>
</ul>
<p>redis 会在满足一定条件时触发 aof 重写，该条件可以在 redis.conf 里配置，例如下面默认配置，当新写入的内容达到了 100%原 aof 文件大小，且 aof 文件已经达到 64mb，才会触发 aof 重写</p>
<ul>
<li>auto-aof-rewrite-percentage 100</li>
<li>auto-aof-rewrite-min-size 64mb</li>
</ul>
<p>aof 文件路径在配置文件里指定，根路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir /opt/homebrew/var/db/redis/</span><br></pre></td></tr></table></figure>

<p>子路径和 aof 文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># For convenience, Redis stores all persistent append-only files in a dedicated</span><br><span class="line"># directory. The name of the directory is determined by the appenddirname</span><br><span class="line"># configuration parameter.</span><br><span class="line"></span><br><span class="line">appenddirname &quot;appendonlydir&quot;</span><br></pre></td></tr></table></figure>

<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>redis 主从同步分为同步和命令传播两个阶段</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>从服务器在初次复制或断线重连时发送 psync 同步请求给主服务器，主服务器会决定执行全量同步还是增量同步</p>
<p>执行全量同步的过程：<br>主服务器执行 bgsave 生成 rdb 快照，然后发送到从服务器。快照后面的命令会缓存到内核缓冲区，从服务器使用 rdb 重建数据后，主服务器将缓冲区的命令发送到从服务器，等从服务器执行完毕后（这期间主服务器短暂不执行写命令），主从数据完成同步，数据达到一致</p>
<p>可以看到全量同步非常消耗主服务器性能和 IO 资源，因此只会在下面这几种情况才会执行：</p>
<ul>
<li>请求的主服务器 id 并非当前服务器 id。这会发生在主服务器变更了或者从服务器初次连接时</li>
<li>从服务器携带的 offset+1 对应的命令不在主服务器内核缓冲区中<ul>
<li>主服务器会用内核缓冲区保存最近的一些命令，缓冲区是一个先进先出的队列</li>
<li>offset 是命令在缓冲区里的字节位置下标，如果 offset+1 对应的指令不在缓冲区里，说明从服务器缺失的指令已经超过了缓冲区存储的，所以需要重新执行全量同步</li>
</ul>
</li>
</ul>
<p>如果 psync 请求的主服务器 id 为当前服务器，且 offset+1 在内核缓冲区中，执行增量同步，主服务器只会把从 offset+1 开始的命令发送给从服务器即可。从服务器收到并执行命令后，会保存命令最后一个字节的 offset，下次发起 psync 时传入</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>主从完成全量同步后，从服务器会每秒给主服务器发送心跳包，携带从服务器已经同步到的最新命令字节 offset。主服务器如果发现内核缓冲区有大于该 offset 的命令，就把增量命令发给从服务器，即命令传播</p>
<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>redis 使用哨兵机制检测主服务器和从服务器的在线状态，并在主服务器下线后选举一个从服务器作为新的主服务器</p>
<p>为了保证哨兵服务器的高可用，redis 也会组哨兵集群，每个哨兵都会通过发布订阅模式，向主服务器发布自己的 ip 和端口号（主服务器 ip 和端口在哨兵的 conf 配置文件里），并通过订阅拿到其他哨兵服务器的 ip 和端口号，建立和其他哨兵的连接</p>
<p>每个哨兵不断地用 ping 命令看主服务器有没有下线，如果主服务器在「配置时间」内没有正常响应，那当前哨兵就「主观」认为该主服务器下线了，它会给其他哨兵发送请求，让其他哨兵判断是否主服务器下线了。如果「足够多」（还是看配置）的哨兵认为该主服务器已经下线，那就认为「客观下线」，「哨兵」之间会选出一个「领头」，由「领头哨兵」重新选主，一般选从服务器中 offset 最大的（同步的数据最接近原主服务器）</p>
<p>重新选主不可避免的会造成数据丢失，原因有二：</p>
<ul>
<li>主从同步延时</li>
<li>发生脑裂（主服务器没下线，还在继续提供服务，则从认为它下线到新的主服务器正式工作前的这段时间的数据会丢失）</li>
</ul>
<h1 id="单机搭建主从和哨兵集群"><a href="#单机搭建主从和哨兵集群" class="headerlink" title="单机搭建主从和哨兵集群"></a>单机搭建主从和哨兵集群</h1><h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>复制多份 redis.conf，然后做这些修改：</p>
<ul>
<li>修改默认 6379 端口，每份 redis.confi 配置的端口号不同即可。目的是给每个 redis 服务器进程分配独立的端口号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 9001</span><br></pre></td></tr></table></figure>

<ul>
<li>修改绑定的 ip，默认绑定本机 127.0.0.1。如果想其他 ip 或者本机的其他进程能连上该 redis 服务器，需要把本机 ip 和其他要建连的 ip 加上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">bind &#123;ip1&#125; &#123;ip2&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>redis.conf 默认开启保护模式：<code>protected-mode yes</code>，此时主服务器必须设置登录密码<ul>
<li>设置密码后，客户端登录需要<code>-a 123456</code>来指定密码</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从服务器的 redis.conf 配置主服务器的密码：<code>masterauth 123456</code></p>
</li>
<li><p>从服务器的 redis.conf 配置主服务器的 ip 和端口号：<code>replicaof &#123;ip&#125; 9001</code></p>
</li>
<li><p>修改 rdb 和 aof 文件名，便于区分</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfilename &quot;appendonly-9001.aof&quot;</span><br><span class="line">dbfilename dump-9001.rdb</span><br></pre></td></tr></table></figure>

<p>登录客户端，输入命令<code>info replication</code>，可查看主从信息</p>
<h2 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h2><p>复制多份 redis-sentinel.conf，然后做这些修改：</p>
<ul>
<li>修改端口号，同上</li>
<li><code>daemonize yes</code>，后台运行</li>
<li><code>pidfile /var/run/redis-sentinel-9101.pid</code>，指定后台运行的 pid 文件名，不同哨兵节点的 pid 文件名不同</li>
<li><code>sentinel monitor mymaster &#123;ip&#125; &#123;port&#125; &#123;认为主服务器断连的哨兵数目阈值，达到阈值就认为主服务器断连&#125;</code>，主服务器 ip 和端口号</li>
<li><code>sentinel down-after-milliseconds mymaster 1000</code>，主服务器断连时长达到该值认为断连，默认 30s，测试可以改为 1s</li>
<li><code>sentinel parallel-syncs mymaster 1</code>，重新选主后，同时最多有多少个从服务器对主服务器进行数据同步，默认是 1，即串行同步</li>
<li><code>sentinel failover-timeout mymaster 5000</code>，完成故障转移（从发现 master 挂了到新的 master 开始提供服务）的时间阈值，超过这个时间认为失败，默认 3 分钟，测试可以改为 5s</li>
<li><code>sentinel auth-pass mymaster 123456</code>，设置访问主从服务器需要的密码，集群中主从服务器的密码需要设置成一样的</li>
</ul>
<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>为了解决单机内存容量限制，redis 采用哈希槽方式构建 redis 分片集群。哈希槽方式使得扩缩容对每个节点的数据影响相对较小，因为缩容时，原节点数据会均分到其他节点，扩容时，每个节点的一小部分数据迁移到新节点。如果使用一致性哈希算法，扩缩容对相邻节点的数据影响很大，不符合 redis 的高可用理念</p>
<p>在实际应用中哈希槽分片有两种具体实现</p>
<h2 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h2><ul>
<li>将 16384 个哈希槽分配（默认均分）到所有 redis 主服务器</li>
<li>redis 主服务器之间互相通信，每个节点都知道哈希槽在整个 redis 集群的分布情况（无中心化设计）</li>
<li>客户端路由：客户端本地也会存储哈希槽在 redis 集群的分布情况。每次发起请求，先对 key 做哈希，然后向持有该槽的 redis 服务器直接发起请求（客户端直连服务器）</li>
<li>扩缩容时进行数据迁移，迁移期间如果收到操作受影响数据的命令，会返回新的节点地址给客户端。如果数据迁移完毕，还会让客户端更新本地路由<ul>
<li>迁移期间，原数据节点不执行命令，新节点要等数据迁移完后才执行命令，所以 redis cluster 模式是同步迁移的，即迁移期间会影响数据读写</li>
</ul>
</li>
</ul>
<h2 id="codis"><a href="#codis" class="headerlink" title="codis"></a>codis</h2><ul>
<li>将 1024 个哈希槽分配（默认均分）到所有 redis 主服务器</li>
<li>使用 zk 维护节点和哈希槽的分布情况（中心化设计）</li>
<li>服务端路由：codis proxy 本地缓存 zk 的节点路由数据，对客户端请求做路由。客户端连接的是 codis proxy</li>
<li>扩缩容时支持数据异步迁移，即数据迁移过程中，原节点依然能处理受影响数据的读请求，但写请求会路由到新节点，且要等到迁移完成后才能执行</li>
</ul>
<h2 id="单机搭建-redis-cluster"><a href="#单机搭建-redis-cluster" class="headerlink" title="单机搭建 redis cluster"></a>单机搭建 redis cluster</h2><p>复制多份 redis.conf，并做如下配置：</p>
<ul>
<li><code># bind 127.0.0.1 ::1</code></li>
<li><code>protected-mode no</code></li>
<li><code>cluster-enabled yes</code></li>
<li><code>cluster-node-timeout 15000</code></li>
<li><code>daemonize yes</code></li>
</ul>
<p>启动每个 redis.conf 对应的 redis 服务器实例：redis-server xxx.conf</p>
<p>创建 redis cluster 集群：redis-cli –cluster create –cluster-replicas 1 {ip:port1} {ip:port2} {ip:port3} {ip:port4} {ip:port5} {ip:port6}</p>
<ul>
<li>1 表示从节点个数</li>
<li>根据节点（ip:port）个数和每个主节点的从节点个数来创建 cluster，例如上面的配置，会创建 3 个主节点，每个主节点各 1 个从节点<ul>
<li>redis cluster 最低配置 6 个节点：3 个主节点和 3 个从节点</li>
</ul>
</li>
<li>如果创建失败，清空<code>/opt/homebrew/var/db/redis</code>目录下的所有数据，该目录存放 aof、rdb 文件</li>
</ul>
<p>客户端按集群模式登录 redis 服务器时，需要增加<code>-c</code><br>输入命令<code>cluster info</code>，可查看集群信息</p>
<h2 id="springboot-连接-redis-cluster"><a href="#springboot-连接-redis-cluster" class="headerlink" title="springboot 连接 redis cluster"></a>springboot 连接 redis cluster</h2><p>引入 redis 依赖和 test 组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>yml 配置 redis cluster 连接信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    cluster:</span><br><span class="line">      nodes: ip:port, ip:port, ... # 这里只要配置集群里每个主节点的ip和端口号</span><br><span class="line">#    host: localhost</span><br><span class="line">#    port: 6379</span><br><span class="line">#    database: 0</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest(classes = &#123;App.class&#125;)</span><br><span class="line">public class RedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void demo1() &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;hername&quot;, &quot;jay&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试用例后，可以观察 aof 的修改时间，就知道写操作路由到哪个节点了</p>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
  </entry>
  <entry>
    <title>【探索】next主题高级定制</title>
    <url>/2017/02/28/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E3%80%90%E6%8E%A2%E7%B4%A2%E3%80%91NexT%E4%B8%BB%E9%A2%98%E9%AB%98%E7%BA%A7%E5%AE%9A%E5%88%B6/</url>
    <content><![CDATA[<p>在探讨NexT主题前，先介绍一下Hexo博客站点的配置文件。</p>
<h1 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h1><blockquote>
<p>_config.yml</p>
</blockquote>
<p>该文件提供如下配置功能：</p>
<blockquote>
<p>站点基本信息</p>
</blockquote>
<p>title和subtitle会显示在首页顶部<br>language默认是英文，这里设为中文，使得页面元素均以中文显示<br>next&#x2F;languages&#x2F;路径下定义了多个语言对应的翻译文件，修改zh-Hans.yml，可以定制页面组件的中文文案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Forwarddc&#x27;s Blog</span><br><span class="line">subtitle: 西米大人的部落格</span><br><span class="line">description: description here</span><br><span class="line">keywords:</span><br><span class="line">author: Forwarddc</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br><span class="line">emai: email here</span><br></pre></td></tr></table></figure>

<blockquote>
<p>域名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: http://dcbupt.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing index.html from permalinks</span><br></pre></td></tr></table></figure>

<blockquote>
<p>菜单栏</p>
</blockquote>
<p>包括“分类”、“标签”等子目录配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br></pre></td></tr></table></figure>

<p>要想为博文分类、打标，且在categories、tags页能看到分类后的博文列表，需要编辑每篇博文的schema，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">categories: 折腾</span><br><span class="line">date: 2017-02-28 14:09</span><br><span class="line">description: &#x27;&lt;blockquote class=&quot;blockquote-center&quot;&gt;next主题浅析与个性化定制&lt;/blockquote&gt;&#x27;</span><br><span class="line">status: public</span><br><span class="line">tags:</span><br><span class="line">  - 前端</span><br><span class="line">  - 测试</span><br><span class="line">title: 【探索】next主题源码调研</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>另，以categories分类页配置为例，还需要创建对应的索引页<br>type <code>hexo new page &quot;categories&quot;</code>，这会创建source&#x2F;categories&#x2F;index.md，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<blockquote>
<p>分页配置</p>
</blockquote>
<p>首页配置分页pageSize为5（展示5篇文章），按时间倒序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 5</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure>
<p>子路径分页配置，展示10篇文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指定博客使用主题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<blockquote>
<p>部署站点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">      type: git</span><br><span class="line">      repository: https://github.com/dcbupt/dcbupt.github.io.git</span><br><span class="line">      branch: master</span><br><span class="line">      message: &#x27;Daily updated：&#123;&#123;now(&quot;YYYY-MM-DD HH:mm:ss&quot;)&#125;&#125; by Forwarddc personal PC&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>站内搜索</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># local search</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  content: true</span><br></pre></td></tr></table></figure>


<h1 id="NexT主题的目录结构"><a href="#NexT主题的目录结构" class="headerlink" title="NexT主题的目录结构"></a>NexT主题的目录结构</h1><p>原文链接：<a href="https://blog.csdn.net/sunshine940326/article/details/69933696">https://blog.csdn.net/sunshine940326/article/details/69933696</a><br>直接拿过来了，写的挺不错的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── .github            #git信息</span><br><span class="line">├── languages          #多语言</span><br><span class="line">|   ├── default.yml    #默认语言</span><br><span class="line">|   └── zh-Hans.yml      #简体中文</span><br><span class="line">|   └── zh-tw.yml      #繁体中文</span><br><span class="line">├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</span><br><span class="line">|   ├── _custom        #可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── _header.swig    #头部样式</span><br><span class="line">|   |   ├── _sidebar.swig   #侧边栏样式</span><br><span class="line">|   ├── _macro        #可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── post.swig    #文章模板</span><br><span class="line">|   |   ├── reward.swig    #打赏模板</span><br><span class="line">|   |   ├── sidebar.swig   #侧边栏模板</span><br><span class="line">|   ├── _partial       #局部的布局</span><br><span class="line">|   |   ├── head       #头部模板</span><br><span class="line">|   |   ├── search     #搜索模板</span><br><span class="line">|   |   ├── share      #分享模板</span><br><span class="line">|   ├── _script        #局部的布局</span><br><span class="line">|   ├── _third-party   #第三方模板</span><br><span class="line">|   ├── _layout.swig   #主页面模板</span><br><span class="line">|   ├── index.swig     #主页面模板</span><br><span class="line">|   ├── page           #页面模板</span><br><span class="line">|   └── tag.swig       #tag模板</span><br><span class="line">├── scripts            #script源码</span><br><span class="line">|   ├── tags           #tags的script源码</span><br><span class="line">|   ├── marge.js       #页面模板</span><br><span class="line">├── source             #源码</span><br><span class="line">|   ├── css            #css源码</span><br><span class="line">|   |   ├── _common    #*.styl基础css</span><br><span class="line">|   |   ├── _custom    #*.styl局部css</span><br><span class="line">|   |   └── _mixins    #mixins的css</span><br><span class="line">|   ├── fonts          #字体</span><br><span class="line">|   ├── images         #图片</span><br><span class="line">|   ├── uploads        #添加的文件</span><br><span class="line">|   └── js             #javascript源代码</span><br><span class="line">├── _config.yml        #主题配置文件</span><br><span class="line">└── README.md          #用GitHub的都知道</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>


<h1 id="next主题的配置文件"><a href="#next主题的配置文件" class="headerlink" title="next主题的配置文件"></a>next主题的配置文件</h1><blockquote>
<p>themes&#x2F;next&#x2F;_config.yml</p>
</blockquote>
<blockquote>
<p>菜单栏</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字体</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  # enable: false</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span><br><span class="line">  # host:</span><br><span class="line">  host: https://fonts.cat.net</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: xx`. Use `px` as unit.</span><br><span class="line"></span><br><span class="line">  # Global font settings used on &lt;body&gt; element.</span><br><span class="line">  # 全局字体，应用在 body 元素上</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Microsoft YaHei</span><br><span class="line">    size: 14</span><br><span class="line"></span><br><span class="line">  # Font settings for Headlines (h1, h2, h3, h4, h5, h6).</span><br><span class="line">  # Fallback to `global` font settings.</span><br><span class="line">  # 标题字体 (h1, h2, h3, h4, h5, h6)</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto Slab</span><br><span class="line">  #   size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts.</span><br><span class="line">  # Fallback to `global` font settings.</span><br><span class="line">  # 文章字体</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family: Microsoft YaHei</span><br><span class="line"></span><br><span class="line">  # Font settings for Logo.</span><br><span class="line">  # Fallback to `global` font settings.</span><br><span class="line">  # Logo 字体</span><br><span class="line">  logo:</span><br><span class="line">    external: true</span><br><span class="line">    family: Lobster Two</span><br><span class="line">    size: 24</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  # 代码字体，应用于 code 以及代码块</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto Mono</span><br><span class="line">  #   size:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本地搜索</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>


<h1 id="博文schema"><a href="#博文schema" class="headerlink" title="博文schema"></a>博文schema</h1><blockquote>
<p>scaffolds&#x2F;post.md</p>
</blockquote>
<p>该文件负责定义每篇博文的schema。<br>hexo new的md博文会自动带上这里定义好的schema<br>tags用于打标签，categories用于给博文分类，description用于在首页展示博文的概要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">categories: &#123;&#123; categories &#125;&#125;</span><br><span class="line">description: &#123;&#123; description &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<h1 id="布局layout"><a href="#布局layout" class="headerlink" title="布局layout"></a>布局layout</h1><h2 id="根布局"><a href="#根布局" class="headerlink" title="根布局"></a>根布局</h2><blockquote>
<p>themes&#x2F;next&#x2F;layout&#x2F;_layout.swig<br>适用于每个页面的布局模板</p>
</blockquote>
<blockquote>
<p>head，页面最顶部</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &#123;% include &#x27;_partials/head.swig&#x27; %&#125;</span><br><span class="line">  &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">  &#123;% include &#x27;_third-party/analytics/index.swig&#x27; %&#125;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>header，正文上面</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;header-inner&quot;&gt; &#123;%- include &#x27;_partials/header.swig&#x27; %&#125; &lt;/div&gt;</span><br><span class="line">    &lt;/header&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main，正文</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;main id=&quot;main&quot; class=&quot;main&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;main-inner&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;content-wrap&quot;&gt;</span><br><span class="line">          &lt;div id=&quot;content&quot; class=&quot;content&quot;&gt;</span><br><span class="line">            &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &#123;% include &#x27;_third-party/duoshuo-hot-articles.swig&#x27; %&#125;</span><br><span class="line">          &#123;% include &#x27;_partials/comments.swig&#x27; %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#123;% if theme.sidebar.display !== &#x27;remove&#x27; %&#125;</span><br><span class="line">          &#123;% block sidebar %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/main&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>footer，底部</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;footer id=&quot;footer&quot; class=&quot;footer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;footer-inner&quot;&gt;</span><br><span class="line">        &#123;% include &#x27;_partials/footer.swig&#x27; %&#125;</span><br><span class="line">        &#123;% include &#x27;_third-party/analytics/analytics-with-widget.swig&#x27; %&#125;</span><br><span class="line">        &#123;% block footer %&#125;&#123;% endblock %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<h3 id="增加页面特效"><a href="#增加页面特效" class="headerlink" title="增加页面特效"></a>增加页面特效</h3><blockquote>
<p>在next主题的根布局文件中，引入对应特效的js。<br>js路径：themes&#x2F;next&#x2F;source&#x2F;js&#x2F;src&#x2F;</p>
</blockquote>
<blockquote>
<p>页面点击小红心</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>js下载地址：<a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/love.js">https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/love.js</a>  </p>
<blockquote>
<p>背景动画</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>js下载地址：<a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/particle.js">https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/particle.js</a></p>
<h2 id="header顶部"><a href="#header顶部" class="headerlink" title="header顶部"></a>header顶部</h2><blockquote>
<p> theme&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;header.swig<br>这个文件用来模式页面顶部header的布局</p>
</blockquote>
<h3 id="增加页面特效-1"><a href="#增加页面特效-1" class="headerlink" title="增加页面特效"></a>增加页面特效</h3><blockquote>
<p>页面顶部，增加特效<code>优秀的人，不是不合群，而是他们合群的人里面没有你</code>样式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;p class=&quot;site-subtitle&quot;&gt;&#123;&#123; config.subtitle &#125;&#125;&lt;/p&gt;       </span><br><span class="line">    &lt;blockquote class=&quot;blockquote-center&quot;&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="body"><a href="#body" class="headerlink" title="body"></a>body</h2><blockquote>
<p>theme&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;post.swig<br>这个文件用来描述页面body的布局</p>
</blockquote>
<p>Index页 or 博文页，标题下方展示<code>发表于xxx|更新于xxx|分类于xxx</code>的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;post-time&quot;&gt;</span><br><span class="line">            &#123;% if theme.post_meta.created_at %&#125;</span><br><span class="line">              &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">                &lt;i class=&quot;fa fa-calendar-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">              &lt;/span&gt;</span><br><span class="line">              &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">                &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;post.posted&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">              &#123;% endif %&#125;</span><br><span class="line">              &lt;time title=&quot;&#123;&#123; __(&#x27;post.created&#x27;) &#125;&#125;&quot; itemprop=&quot;dateCreated datePublished&quot; datetime=&quot;&#123;&#123; moment(post.date).format() &#125;&#125;&quot;&gt;</span><br><span class="line">                &#123;&#123; date(post.date, config.date_format) &#125;&#125;</span><br><span class="line">              &lt;/time&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>默认next配置文件，是不会在标题下方展示<code>更新于xxx</code>，可以修改配置文件，<code>updated_at: true</code>使其展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Post meta display settings</span><br><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at: true</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure>

<p>如果是index页，展示description、<code>阅读全文</code>的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if is_index %&#125;</span><br><span class="line">        &#123;% if post.description and theme.excerpt_description %&#125;</span><br><span class="line">          &#123;&#123; post.description &#125;&#125;</span><br><span class="line">          &lt;!--noindex--&gt;</span><br><span class="line">          &lt;div class=&quot;post-button text-center&quot;&gt;</span><br><span class="line">            &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;</span><br><span class="line">              &#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure>

<h3 id="增加每篇文章阅读量统计"><a href="#增加每篇文章阅读量统计" class="headerlink" title="增加每篇文章阅读量统计"></a>增加每篇文章阅读量统计</h3><blockquote>
<p>文章标题下方，展示阅读量<br>参考：<a href="https://blog.csdn.net/weixin_39345384/article/details/80787998">https://blog.csdn.net/weixin_39345384/article/details/80787998</a></p>
</blockquote>
<p>追文章标题下方展示<code>发布于xxx</code>的代码，发现next主题可以支持文章阅读量的配置<br>1、去leancloud申请一个应用：<a href="https://leancloud.cn/dashboard/login.html#/signin">https://leancloud.cn/dashboard/login.html#/signin</a><br>2、修改next配置文件，开启阅读量统计，填入应用的appid和appKey</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id: #&lt;app_id&gt;</span><br><span class="line">  app_key: #&lt;app_key&gt;</span><br></pre></td></tr></table></figure>
<p>3、leancloud为应用创建一张用于存储阅读量的表，命名为Counter<br>4、自己博客的域名绑定到应用的web安全设置域名中（防止其他域名拿到app信息）</p>
<h3 id="增加页面特效-2"><a href="#增加页面特效-2" class="headerlink" title="增加页面特效"></a>增加页面特效</h3><blockquote>
<p>在每篇博文的末尾，增加特效<code>完</code>样式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &#123;&#123; post.content &#125;&#125;</span><br><span class="line">    &lt;blockquote class=&quot;blockquote-center&quot;&gt;完&lt;/blockquote&gt;</span><br><span class="line">&#123;% endif  %&#125;</span><br></pre></td></tr></table></figure>



<h1 id="添加本地搜索功能"><a href="#添加本地搜索功能" class="headerlink" title="添加本地搜索功能"></a>添加本地搜索功能</h1><p>1、在本地博客路径下：<code>npm install hexo-generator-searchdb --save</code><br>2、在站点配置文件_config.yml里添加search字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>3、修改next主题的_config.yml，将local_search改为<code>true</code></p>
<h1 id="字数统计功能"><a href="#字数统计功能" class="headerlink" title="字数统计功能"></a>字数统计功能</h1><p>1、安装wordcount插件 <code>npm install hexo-wordcount --save</code><br>2、修改NexT的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure>

<h1 id="隐藏博文"><a href="#隐藏博文" class="headerlink" title="隐藏博文"></a>隐藏博文</h1><p><a href="https://github.com/prinsss/hexo-hide-posts/blob/master/README_ZH.md">https://github.com/prinsss/hexo-hide-posts/blob/master/README_ZH.md</a></p>
<h1 id="加密访问"><a href="#加密访问" class="headerlink" title="加密访问"></a>加密访问</h1><p><code>npm install --save hexo-blog-encrypt</code></p>
<p>博文的meta中增加：<code>password: xxx</code></p>
<h1 id="主页只展示指定类目下的博文"><a href="#主页只展示指定类目下的博文" class="headerlink" title="主页只展示指定类目下的博文"></a>主页只展示指定类目下的博文</h1><p><a href="https://github.com/Jamling/hexo-generator-index2/blob/master/README_zh.md">https://github.com/Jamling/hexo-generator-index2/blob/master/README_zh.md</a></p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>打开<code>themes/next/source/css/_custom/</code>下的<code>custom.styl</code>,向里面加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 文章边框</span><br><span class="line">.post &#123;</span><br><span class="line">  // height: 300px;</span><br><span class="line">  margin-top: 0px;</span><br><span class="line">  margin-bottom: 60px;</span><br><span class="line">  padding: 20px 40px;</span><br><span class="line">  box-shadow: 0 0 25px rgba(202, 203, 203, .5);</span><br><span class="line">  -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">  -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  background-color: #f9f9f9;</span><br><span class="line">  //background-color: #f3f9f1;</span><br><span class="line">  //background-color: #edd1d8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章末尾分割线</span><br><span class="line">.posts-expand .post-eof &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 80px auto 60px;</span><br><span class="line">  width: 0px;</span><br><span class="line">  height: 0px;</span><br><span class="line">  background: #555;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 阅读全文按钮</span><br><span class="line">.post-button &#123;</span><br><span class="line">  margin-top: 90px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码边框</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0 30px 0;</span><br><span class="line">    padding: 1px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 段落边距</span><br><span class="line">p &#123;</span><br><span class="line">  margin: 0 0 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调整文章的行宽，修改：<code>themes/next/source/css/_variables/base.styl</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$content-desktop-large          = 1150px</span><br></pre></td></tr></table></figure>


<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p>NexT主题优化：<br><a href="https://www.jianshu.com/p/3ff20be8574c">https://www.jianshu.com/p/3ff20be8574c</a></p>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】hexo + NexT搭建个人博客</title>
    <url>/2017/02/26/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91hexo%20+%20NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>特别感谢Neveryu，遵循他的博文我成功搭建起了自己的hexo + NexT博客<br>  这篇博文仅记录我的搭建过程，不对细节做过多探究，如需深究，请参见Neveryu的博文<br>  <a href="https://neveryu.github.io/2016/09/03/hexo-next-one/">https://neveryu.github.io/2016/09/03/hexo-next-one/</a><br>  <a href="https://neveryu.github.io/2016/09/30/hexo-next-two/">https://neveryu.github.io/2016/09/30/hexo-next-two/</a></p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>hexo是一个开源的博客框架，基于node.js</li>
<li>NexT是hexo框架的一个流行的主题</li>
</ul>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul>
<li>安装<code>git</code> &amp;&amp; <code>Node.js</code><br>因为我已经在windows上安装了git，所以只需要安装Node.js</li>
</ul>
<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><ul>
<li>安装nvm（node version management）<br>下载地址 <code>https://github.com/coreybutler/nvm-windows/releases</code> 选择nvm-setup.zip</li>
<li>使用nvm方式安装node.js<br>type <code>nvm install latest</code> 验证安装成功 type  <code>node -v</code><blockquote>
<p>安装nvm的时候会让你选择nvm和你之后要装的nodejs的路径，这两个路径会被添加到path<br>install nodejs后，需要<code>nvm use $&#123;nodejs-version&#125;</code>，否则可能node和npm指令不能用</p>
</blockquote>
</li>
</ul>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul>
<li>hexo是基于node.js的开源框架，所以可以使用npm方式安装。<blockquote>
<p>nvm安装node.js，npm安装项目</p>
</blockquote>
<p>  type <code>npm install -g hexo-cli</code></p>
</li>
</ul>
<h1 id="使用hexo搭建本地博客"><a href="#使用hexo搭建本地博客" class="headerlink" title="使用hexo搭建本地博客"></a>使用hexo搭建本地博客</h1><ul>
<li><p>在本地博客根路径下，type <code>hexo init</code> 完成hexo初始化</p>
</li>
<li><p>type <code>hexo g</code> 实现“source&#x2F;_post&#x2F;”路径下所有.md和.html文件cp到public文件夹下（没有则会创建）</p>
</li>
<li><p>type <code>hexo s --debug</code> 启动hexo</p>
<blockquote>
<p>此时你应该能在 <code>localhost:4000</code> 中看到你的hexo博客</p>
</blockquote>
</li>
</ul>
<p>如果你安装了FoxitReader,port:4000会被占用，可以type <code>hexo s -p 5000 --debug</code></p>
<h1 id="使用NexT主题"><a href="#使用NexT主题" class="headerlink" title="使用NexT主题"></a>使用NexT主题</h1><ul>
<li>NexT主题在git上开源，在本地博客根目录下可以直接clone, type<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></li>
<li>启用NexT主题：编辑<code>_config.yml</code>，将theme字段的值改为<code>next</code></li>
</ul>
<h1 id="本地调试三部曲"><a href="#本地调试三部曲" class="headerlink" title="本地调试三部曲"></a>本地调试三部曲</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s -p 5000 --debug</span><br></pre></td></tr></table></figure>
<ul>
<li>这三个命令的组合适用于你增删了新的md博文</li>
<li>如果你只是对已经publish的博文进行修改，只需要修改本地md文件，刷新localhost即可生效</li>
<li>md编辑器使用的是vs code</li>
</ul>
<h1 id="部署本地hexo博客到GitPage"><a href="#部署本地hexo博客到GitPage" class="headerlink" title="部署本地hexo博客到GitPage"></a>部署本地hexo博客到GitPage</h1><ul>
<li>首先需要在GitHub上新建一个repo，名字为：dcbupt.github.io</li>
<li>配置本地的git全局信息<ul>
<li><code>git config --global user.name &quot;username&quot;</code><br><code>git config --global user.email &quot;yourEmail&quot;</code></li>
</ul>
</li>
<li>安装hexo的git部署工具<ul>
<li><code>npm install hexo-deployer-git --save</code></li>
</ul>
</li>
<li>修改_config.yml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://dcbupt.github.io</span><br><span class="line">deploy:</span><br><span class="line">      type: git</span><br><span class="line">      repository: https://github.com/dcbupt/dcbupt.github.io.git</span><br><span class="line">      branch: master</span><br><span class="line">      message: &#x27;Daily updated：&#123;&#123;now(&quot;YYYY-MM-DD HH:mm:ss&quot;)&#125;&#125; by Forwarddc personal PC&#x27;</span><br></pre></td></tr></table></figure></li>
<li>hexo部署三部曲<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h1 id="用hexo-new写博文"><a href="#用hexo-new写博文" class="headerlink" title="用hexo new写博文"></a>用hexo new写博文</h1><code>hexo new YrArticle</code>命令默认是跟post，即会在 source&#x2F;_posts&#x2F; 下创建YrArticle.md</li>
</ul>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>git梳理</title>
    <url>/2017/03/27/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8github/</url>
    <content><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><blockquote>
<p>用于本地和远程仓库的授权、验签</p>
</blockquote>
<p>type <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code> ，这会在本地创建.ssh目录，并在该目录下生成本地SSH公钥和私钥<br>在github远程仓库的SSH KEY里添加本地公钥（登陆github,选择settings-ssh key)，用于本地对远程仓库发起push操作的验签，以及本地拉取远程仓库代码操作的授权<br>单台机器（MAC地址唯一）只需要生成一次SSH KEY，即可完成与特定git账号下的git服务端加密、验签</p>
<h1 id="git全局配置"><a href="#git全局配置" class="headerlink" title="git全局配置"></a>git全局配置</h1><p>git config –global user.emai …<br>git config –global user.name “…”<br>可以用git config –list查看全局global信息。</p>
<h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><p><code>git init</code> 会在当前文件夹创建本地仓库</p>
<h1 id="本地关联远程仓库"><a href="#本地关联远程仓库" class="headerlink" title="本地关联远程仓库"></a>本地关联远程仓库</h1><p><code>git remote add origin git@github.com:dcbupt/java.git</code><br>origin指代远程仓库<br>删除远程仓库：<code>git remote rm origin</code><br>查看本地关联的远程仓库：<code>git remote -v</code></p>
<h1 id="本地仓库的三个空间"><a href="#本地仓库的三个空间" class="headerlink" title="本地仓库的三个空间"></a>本地仓库的三个空间</h1><p>首先，本地文件夹下还没add的文件存在于<code>工作区空间</code><br>add后的文件位于<code>暂存区空间 </code><br>commit后的文件位于<code>分支空间</code>。</p>
<h2 id="commit-id"><a href="#commit-id" class="headerlink" title="commit id"></a>commit id</h2><p>每次commit，git会分配一个唯一的commit id。分支空间里有一个HEAD指针唯一指向最新一次的commit。<br>可以理解为：HEAD &#x3D; the newest commit id。<br>HEAD^指向上一次commit的commit id。</p>
<h1 id="推送-amp-拉取"><a href="#推送-amp-拉取" class="headerlink" title="推送 &amp; 拉取"></a>推送 &amp; 拉取</h1><p>拉取：<code>git pull 远程仓库名 远程分支名：本地分支名</code><br>例子：<code>git pull origin master:master</code><br>推送：<code>git push 远程仓库名 本地分支名：远程分支名</code> </p>
<h1 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h1><p>作用是指定本地的一些文件和文件夹不属于git版本控制的范围内</p>
<h1 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a>git常用指令</h1><p><code>git status</code>的作用是检查这三个空间的状态。它的逻辑是：工作空间里出现的新文件或者被修改过的文件必须移动到暂存空间，暂存空间的文件必须移动到分支空间。<br><code>git reset --hard HEAD^</code> 的作用是让HEAD指针指向前一个commit id。效果是你最近一次commit对文件所做的修改失效，该文件回退到上上次提交后的状态。<br><code>git log --pretty=oneline</code>的作用是查看所有commit id和commit内容。最上面的一个ID就是最近一次的commit id，也是HEAD指向的ID。注意如果你改变了HEAD指针，例如让HEAD指向前一个commit id，则最新一次的commit就消失了，git log也查不到。<br><code>git reflog</code>的作用是记录每一次HEAD变更所做的操作，即使因为执行<code>git reset --hard ...</code>而被淹没的commit id也能在这里查到。<br><code>git reset --hard commit id</code>的作用是让本地回退到某一次commit提交后的状态。结合reflog可以自由进行版本回退。<br><code>git reset file</code>的作用是你add到暂存空间的文件撤回到工作空间。一般是你对文件做了修改后add，但你不满意还想继续修改于是就取回到工作空间。但前提是还没有commit到分支空间，一旦文件被commit，则文件不会存在于暂存空间。<br><code>git checkout file</code>的作用是对工作空间里的文件做的修改执行撤销，一般是你对文件修改后不满意想重新修改，于是撤销掉以前所有的修改。如果你add了，那么 checkout返回给你的是暂存区的文件，如果你没有add，那么checkout返回给你的是上一次你commit进分支空间的文件。 如果你在工作空间误操作rm了文件，依然可以git checkout file来实现恢复文件，原理同上。<br><code>git rm file</code>会删除工作空间和分支空间的这个文件，接下来你需要commit一下才最终完成这次delete操作。<br><code>git rm --cached file</code>可以删除暂存区的文件。<br><code>git rm+git commit -am</code>如果本地有很多文件需要删除，同时也要删除分支空间里对应的文件，那么git rm+git commit会比较麻烦，这时可以用git rm+git commit -am的方式，因为git commit -m不会向分支空间提交rm的修改，需要参数-am。 </p>
<h1 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h1><p>首先，在一个git init的目录下是可以创建多个分支的。默认的是master分支。<br>git checkout -b dcddc创建并切换到了dcddc分支。<br>相当于git branch dcddc + git checkout dcddc<br><code>理解HEAD指针在多分支里的作用</code><br>其实HEAD指针不是指向commit的，HEAD指针指向当前分支，当前分支指向commit。所以你切换到了其他分支后，head分支就指向当前分支， 你的commit操作只发生在当前分支上，当你checkout回另一个分支后，HEAD又指向那个分支，而那个分支指向的commit并不是另一分支指 向的commit，所以你可以在dcddc下写代码并commit进度，等完工后再合并master分支和dcddc分支，这样master分支也就追上了dcddc分支的进度，然后你再push到github就OK了。<br>合并分支的操作：git merge dcddc （在master )<br>删除dcddc分支：git branch -d dcddc</p>
<h1 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h1><blockquote>
<p>使用场景</p>
</blockquote>
<p>开发一个新需求，基于master拉出一个新分支a，然后fetch并checkout到本地。<br>开发期间，有些其他的需求陆续上线，因此master有新的merge commit，因此分支a与master<code>分叉</code>了。<br>为了保持分支a与master的同步性，需要不定期将master的新commit合并到分支a，此时rebase就能发挥作用了。<br><code>rebase主要用来跟上游同步</code></p>
<p>与merge的区别：</p>
<ul>
<li>rebase后，自己的commit依然会顶到commit history的顶部（待验证）</li>
<li>rebase可能会需要多次解conflict，merge只会解一次（因此建议保持每周都rebase的习惯）</li>
</ul>
<p>用法：<br><code>git checkout a</code><br><code>git rebase origin master</code></p>
<p>原理：<br><code>git rebase</code>会把a分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git&#x2F;rebase”目录中),然后把a分支更新为最新的master分支，最后把保存的这些补丁应用到a分支上。<br>因此，在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:<br><code>git rebase --continue</code><br>这样git会继续应用(apply)余下的补丁。<br>在任何时候，你可以用–abort参数来终止rebase的行动，并且a分支会回到rebase开始前的状态。<br><code>git rebase --abort</code></p>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
  </entry>
  <entry>
    <title>如何抗住高并发</title>
    <url>/2021/06/17/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E5%A6%82%E4%BD%95%E6%89%9B%E4%BD%8F%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h1><h2 id="拆分演进"><a href="#拆分演进" class="headerlink" title="拆分演进"></a>拆分演进</h2><ul>
<li>单机部署<ul>
<li>系统所有模块部署在一台服务器，包括应用服务、缓存、数据库、文件存储等</li>
</ul>
</li>
<li>各自独立<ul>
<li>每个模块独立部署，能显著提高各自的性能</li>
</ul>
</li>
<li>微服务-集群化-分布式<ul>
<li>将系统拆分为更小粒度的微服务，每个微服务部署到集群上，由负载均衡服务器负责将流量分发到各应用服务器，提升服务的并发处理能力</li>
<li>消息队列、缓存、数据库、应用服务都集群化部署，系统升级为分布式架构</li>
</ul>
</li>
<li>多集群-异地部署<ul>
<li>在分布式架构的基础上，通过在多个地区部署部署多个集群，当用户访问时，通过 DNS 解析并根据用户地理位置就近分派请求到特定集群</li>
</ul>
</li>
</ul>
<h2 id="拆分维度"><a href="#拆分维度" class="headerlink" title="拆分维度"></a>拆分维度</h2><p>可从系统，功能和读写纬度将大的系统进行拆分</p>
<ul>
<li>系统维度<ul>
<li>将一个大系统拆分为多个小系统，比如将电商系统拆分为商品系统，购物车系统，订单系统，优惠券系统等</li>
</ul>
</li>
<li>功能维度<ul>
<li>微服务化。对拆分出的一个小系统根据功能再拆分，如优惠券系统，还可拆分为建券系统，领券系统，用券系统等</li>
</ul>
</li>
<li>读写维度<ul>
<li>根据读写比例进行拆分，如商品系统，读的需求量比写的多很多，若将读写揉在一起，会相互影响。因此可将商品系统拆分为商品读服务，商品写服务</li>
</ul>
</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="cache-aside"><a href="#cache-aside" class="headerlink" title="cache aside"></a>cache aside</h3><p>解决的问题：缓存和 DB 的数据一致性问题</p>
<p>更新数据：</p>
<ul>
<li>在更新完数据库后删除缓存，而不是更新数据到缓存<ul>
<li>为什么不更新而是删除缓存？因为在写多读少场景中，每次写入后需要额外计算缓存数据并更新，但实际查询 qps 很低，产生了很多无用的计算成本。这种设计的本质是 lazy 懒加载思想，只有在用到（读）的时候才计算</li>
</ul>
</li>
</ul>
<p>读取数据时：</p>
<ul>
<li>先读取缓存数据，如未命中缓存，则读取数据库，并写入缓存</li>
</ul>
<h2 id="缓存典型问题"><a href="#缓存典型问题" class="headerlink" title="缓存典型问题"></a>缓存典型问题</h2><h3 id="雪崩、击穿"><a href="#雪崩、击穿" class="headerlink" title="雪崩、击穿"></a>雪崩、击穿</h3><p>雪崩：大量缓存数据同时失效或 Redis 宕机造成大量请求直接访问数据库<br>击穿：热点数据过期，大量请求直接访问数据库。可以认为缓存击穿是缓存雪崩的一个子集。</p>
<p>大量缓存数据同时失效的解决方案：</p>
<ul>
<li>缓存有效期增加随机值，降低大量缓存数据同时过期的概率</li>
<li>互斥锁降低并发。当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值<ul>
<li>同样适合缓存击穿</li>
</ul>
</li>
<li>后台更新缓存。如果缓存值为空，向消息队列发条消息，消费者查询缓存，仍为空则查数据库更新缓存。本质还是降低并发。该方案也适用于缓存预热<ul>
<li>同样适合缓存击穿</li>
</ul>
</li>
</ul>
<p>Redis 宕机的解决方案：</p>
<ul>
<li>服务熔断。直接返回错误，保证数据库正常。等 Redis 恢复后再继续服务</li>
<li>服务限流。只将少部分请求发送到数据库进行处理。等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制</li>
</ul>
<h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><p>穿透：当缓存和数据库中都没有数据时，高并发下无法构建缓存数据，大量请求直接访问数据库，即认为缓存被穿透了。一般发生缓存穿透是由于数据被误删除或者被黑客恶意攻击</p>
<p>解决方案：</p>
<ul>
<li>缓存空值<ul>
<li>当多个客户端请求一条不存在的数据时，为防止多次无效的数据库访问，在第一个客户端访问时可以将这个空值也缓存起来，之后其他客户端请求时，会命中缓存中的空值，降低数据库压力</li>
</ul>
</li>
<li>布隆过滤器<ul>
<li>写入数据时，更新布隆过滤器。查询数据时，先查询布隆过滤器是否存在，若不存在，直接返回空，若存在，再去查询数据库</li>
<li>布隆过滤器原理：对一个 key 进行 k 个 hash 算法获取 k 个值，在比特数组中将这 k 个值散列后设定为 1，然后查的时候如果特定的这几个位置都为 1，那么布隆过滤器判断该 key 存在</li>
<li>布隆过滤器发生哈希冲突时可能会误判，判定为存在实际不存在。但如果判定不存在，则一定不存在</li>
<li>Redis 的 bitmap 只支持 2^32 大小，对应到内存也就是 512MB，误判率万分之一，可以放下 2 亿左右的数据，性能高，空间占用率及小，省去了大量无效的数据库连接</li>
<li>除了用于解决缓存穿透，布隆过滤器另一个用途是用来去重。查数据库来判断 exists 的操作，在高 qps 场景中可以使用布隆过滤器，减轻 db 压力</li>
</ul>
</li>
</ul>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><h2 id="降级分类"><a href="#降级分类" class="headerlink" title="降级分类"></a>降级分类</h2><ul>
<li><p>功能降级</p>
<ul>
<li>如电商平台的推荐功能，可以提升销量和转化，但不是购物的核心流程，在系统压力大时可以降级为默认的内容</li>
</ul>
</li>
<li><p>服务降级</p>
<ul>
<li>如在流量高峰时只更新缓存，不更新数据库，把要写入数据库的数据放到消息队列，在流量高峰过后，把消息队列中的数据更新到数据库</li>
</ul>
</li>
</ul>
<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流也是服务降级的一种方式</p>
<p>限流算法请参考我的另一篇文章：系统学习流控技术。</p>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2017/04/18/blog_article/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式用于匹配字符串。通配符*是bash提供的接口，并非正则表达式！<br>支持正则表达式的工具：vi\grep\awk\sed</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>示例：<code>dmesg | grep -n -A3 -B2 --color=auto &#39;eth&#39;</code><br>-A3即 after3，-B2即before 2，会将匹配行前两行和后三行也显示出来。<br>-n添加行号，–color&#x3D;auto会高亮匹配字符串</p>
<p>有些grep参数例如-n –color&#x3D;auto是很常用的，如果不想每次都敲一遍，到~&#x2F;.bashrc中增加别名即可：<br><code>alias grep=&#39;grep -n --color=auto&#39;</code>，再使其生效：<code>source ~/.bashrc</code></p>
<p>如果你想获取<code>不包含匹配</code>的结果，使用：<code>grep -vn &#39;the&#39; test.txt</code></p>
<p>如果你想匹配时忽略<code>大小写</code>，使用<code>grep -in &#39;the&#39; test.txt</code></p>
<p>如果要匹配<code>集合内的单个字符</code>，使用：<code>grep -n &#39;t[ae]st&#39; test.txt </code></p>
<blockquote>
<p>[]内可以是一个集合，也可以是用<code>-</code>连接的范围，但[]只占一个字符</p>
</blockquote>
<p>如果要匹配<code>开头不包含某个字符的字符串</code>，使用：<code>grep -n &#39;[^g]oo&#39; test.txt</code></p>
<p>如果要匹配<code>开头不包含小写字母的字符串</code>，使用：<code>grep -n &#39;[^a-z]oo&#39; test.txt</code></p>
<p>如果要匹配<code>以小写字母开头的字符串</code>，使用：<code>grep -n &#39;^[a-z]&#39; test.txt</code></p>
<blockquote>
<p><code>^</code>放到[]外面表示开头，放到[]里表示不包含</p>
</blockquote>
<p>如果要匹配<code>以指定字符结尾的字符串</code>，使用：<code>grep -n &#39;\.$&#39; test.txt </code></p>
<blockquote>
<p><code>$</code>的含义：linux的断行符是$，即$一定出现在行尾，同理<code>^</code>一定出现在行首<br>因为小数点具有其他含义，所以要转义</p>
</blockquote>
<p>如果要<code>过滤空行</code>，使用：<code>grep -vn &#39;^$&#39; test.txt</code></p>
<p>如果要匹配<code>两个任意字符</code>，使用：<code>grep -n &#39;..&#39; test.txt</code></p>
<p>如果要匹配<code>包含任意个（一个或一个以上）连续字符o的字符串</code>，使用：<code>grep -n &#39;oo*&#39; test.txt</code></p>
<blockquote>
<p><code>.</code>表示任意一个字符（非空，但可以是空格符），<code>*</code>表示匹配前一个出现的字符任意次（可以为0次）</p>
</blockquote>
<p>如果要匹配<code>包含指定连续个数的字符o的字符串</code>，使用：<br><code>grep -n &#39;o\&#123;2\&#125;&#39; test.txt</code>  匹配包含连续两个o的字符串<br><code>grep -n &#39;o\&#123;2,5\&#125;&#39; test.txt</code>   匹配包含连续2到5字o的字符串<br><code>grep -n &#39;o\&#123;2,\&#125;&#39; test.txt</code>    匹配包含大于等于连续两个o的字符串</p>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>如果要<code>删除指定第三行到最后一行</code>，使用：<code>nl /etc/passwd | sed &#39;3,$d&#39;</code></p>
<p>如果要在<code>指定行后增加内容</code>，使用：<code>nl /etc/passwd | sed &#39;2a yourText&#39;</code></p>
<blockquote>
<p>如果在指定行前增加内容，使用<code>2i</code>替代<code>2a</code><br>如果增加多行内容，每行内容用<code>\</code>分割</p>
</blockquote>
<p>如果要<code>用新的内容取代指定（多）行的内容</code>，使用：<code>nl /etc/passwd | sed &#39;2,5c yourText&#39;</code></p>
]]></content>
      <categories>
        <category>工程技术</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/10/blog_article/%E7%94%9F%E6%B4%BB/log/</url>
    <content><![CDATA[<p>1、github配置hosts</p>
<p>140.82.114.3 github.com<br>151.101.1.194 github.global.ssl.fastly.net<br>140.82.113.10 nodeload.github.com<br>140.82.112.6 api.github.com<br>140.82.112.10 codeload.github.com</p>
<p>这几个ip经常变，获取最新ip：<br><a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></p>
<p>到桌面，COMMAND+SHIFT+G，前往文件夹&#x2F;etc<br>复制出hosts文件，修改，然后替换&#x2F;etc&#x2F;hosts文件即可</p>
<p>2、nvm、node、hexo本地都已经安装，bin路径：&#x2F;usr&#x2F;local&#x2F;bin<br>hexo指令要添加到环境变量，这样就能在vs code的terminal里直接执行hexo命令。<br>方法：<br>vim &#x2F;etc&#x2F;profile<br>PATH添加上面的bin路径，用‘:’分割</p>
<p>&#x2F;etc&#x2F;profile在~&#x2F;.zshrc里已经source了，所以立即生效</p>
<p>3、vs code找不到git命令的解决办法：<br>首选项-设置-输入git.path-在settings.json中编辑-git.path添加本地git命令地址<br>git命令地址查询：which git</p>
]]></content>
  </entry>
  <entry>
    <title>如何挑选钻戒</title>
    <url>/2020/04/20/blog_article/%E7%94%9F%E6%B4%BB/%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E9%92%BB%E6%88%92/</url>
    <content><![CDATA[<p>钻戒的组成：</p>
<ul>
<li>钻石</li>
<li>戒托</li>
<li>品牌</li>
</ul>
<p>钻戒证书：GIA</p>
<p>1克拉以上有GIA大证，不足1克拉有GIA小证</p>
<p>GIA证书第一行的数字是钻石的身份证，钻石腰部也有相同的数字，称为腰码。腰码和证书上的数字需要对得上</p>
<p>接下来几行是钻石的4C标准：</p>
<ul>
<li>克拉<ul>
<li>1克拉&#x3D;0.2克</li>
<li>预算有限，1克拉和95分推荐95分，因为肉眼看一样大，价格差距大（克拉溢价）</li>
</ul>
</li>
<li>颜色等级<ul>
<li>颜色越白价格越高</li>
<li>I之后不要买，肉眼可见的黄</li>
<li>DE价格贵</li>
<li>推荐FGH这三个</li>
</ul>
</li>
<li>净度<ul>
<li>最不重要</li>
<li>50分以上的钻石，vs2-vvs1之间</li>
<li>50分以下，不低于SI1</li>
</ul>
</li>
<li>切工<ul>
<li>决定钻石是否好看</li>
<li>圆形钻石三个标准：切割比例、抛光性、对称性。最好选择3ex表示3个标准都是excellent</li>
<li>异形的钻石两个标准：抛光性、对称性。最好2ex</li>
<li>圆形比异形贵</li>
</ul>
</li>
</ul>
<p>切工和颜色最重要</p>
<p>倒数第二排需要为none，表示没有荧光（不会雾蒙蒙的）</p>
<p>无奶无咖无绿（证书不会写，行话）</p>
<p>钻石价格表 </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>图</title>
    <url>/2017/04/02/blog_article/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h1><p>图的节点数为V，边数为E，构造一个节点数组adj[V]，节点id为数组下标，每个节点的数据结构里维护一个邻接表（链表），链表保存和其连接的节点id。用一个Graph的类来封装这个节点数组。<br>对于无向图，连接a-b，则a和b的邻接表都有彼此的id<br>对于有向图，连接a-&gt;b，则a的邻接表有b，b的邻接表没有a</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>对于图：1-2，1-3，1-4，2-5，2-6 … …<br>1作为起始节点，访问1的邻接表（2-3-4），每次访问到的元素（234），都作为新的起始节点开始递归。<br>终止条件：当访问完节点的邻接表里的每个邻居或者该节点被访问过<br>可能会出现一个节点在DFS递归中多次被访问到，所以通过一个boolean[V]数组表示该节点是否已经被访问过了，被访问过的节点不会再被递归</p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>对于图：1-2，1-3，1-4，2-5，2-6 … …<br>如果以1作为起始节点，访问1的邻接表（2-3-4），将1的邻居234加入到一个queue里，然后queue做出队操作，出队的每一个元素，访问邻接表，将邻居节点入队。队列为空返回。<br>用一个int[V]数组表示到节点的上一跳节点ID。通过该数组将回溯的结果push到Stack可以得到从起始节点到邻居的最短路径<br>也要维护一个boolean数组判断当前访问的元素是否已经被访问过，如果是，则不入队</p>
<h1 id="DFS查找连通分量"><a href="#DFS查找连通分量" class="headerlink" title="DFS查找连通分量"></a>DFS查找连通分量</h1><p>用一个int[V]保存节点所属连通分量的id，保证用DFS搜索到的节点，与起始节点有相同的连通分量id，该id表示当前是第几个连通分量。<br>遍历节点时，判断当前节点是否被访问了，如果是，跳过DFS搜索</p>
<h1 id="DFS判断二分图"><a href="#DFS判断二分图" class="headerlink" title="DFS判断二分图"></a>DFS判断二分图</h1><p>二分图就是图中的节点划分为两派A、B，两派内部的节点中两两互不相连，A派的节点只会和B派的节点相连。<br>根据上面的性质，二分图中的每个链接都来自不同的派，如果将A派统一着色，B派统一着色，那么一条连接的两个端点颜色必然不同！<br>借鉴这种思想，DFS时可以判断图是否是二分图。<br>用一个boolean[V]表示两节点的颜色，如果DFS到节点1时，查找1的邻接表（2，3，4），然后递归节点2之前将链接两端的节点反色，<code>boolean[1] = !boolean[2]</code><br>因为1和234链接，所以234是一派，假设23链接，就打破了二分图的定义<br>因为是DFS所以2会先访问到3，当2访问3时，boolean[2] &#x3D; !boolean[3]<br>当1访问3时，尽管3已经被visit，还是会判断3的颜色，这时会发现boolean[1]和boolean[3]同色，就说明不是二分图了！<br>即，在DFS时，如果当前节点没有visit，递归前将其反色后递归。如果当前节点已经visit了，判断其和自己的颜色是否一致，如果一致说明不是二分图。</p>
<h1 id="DFS判断有环图"><a href="#DFS判断有环图" class="headerlink" title="DFS判断有环图"></a>DFS判断有环图</h1><p>1、无向图：<br>DFS时，每次递归都携带起始节点id，如果递归过程中，节点a的邻居节点b被visit了，但b不是起始节点，说明：从起始节点出发有到b的至少两条路径，所以是有环图。<br>2、有向图：<br>对图中的每个节点作为起始节点，调用V次DFS。每次DFS，除了用boolean[]标识已经visit的节点，在第一次递归前，用另一个boolean A[V]数组，将A[起始节点设为true。当DFS的过程中碰到节点j已经被visit，且A[j]为true，说明j节点就是起始节点，则存在环。如果DFS结束仍然没有遇到环，则说明到起始节点不存在环，重新置A[起始节点]为false，继续对后面的节点做DFS。<br>感觉这种方式比较麻烦，还不如在DFS时加一个参数表示起始节点，碰到邻居节点已经被访问，就拿其id和起始节点id比较。</p>
<h1 id="符号图"><a href="#符号图" class="headerlink" title="符号图"></a>符号图</h1><p>图的应用，其节点往往是一个字符串。用一个TreeMap&lt;String ,Integer&gt;来保存每个节点。对于每个节点，在Graph类中用其索引来表示，所以对于每个节点依然可以创建邻接表。<br>因为图的操作用index表示单词，所以如果需要得到单词，可以创建一个String[]，用index作为索引存储单词。</p>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>如果需要查找单词a在图中到另一个单词b的最短路径，先构造符号图，再对单词a用BFS，如果单词b在BFS访问的节点集里，返回最短路径。<br>因为BFS是按跳数访问邻居的，所以适合查找最短路径。<br>BFS时，用一个int[V]的数组保存节点i的上一跳，对于到b的最短路径，回溯int[b]直到a即可。</p>
<h1 id="有向图的前序、后序、逆后序遍历"><a href="#有向图的前序、后序、逆后序遍历" class="headerlink" title="有向图的前序、后序、逆后序遍历"></a>有向图的前序、后序、逆后序遍历</h1><p>前序遍历就是DFS的调用顺序，在对当前节点DFS向后递归前，将节点入队<br>后序遍历就是节点完成DFS的顺序，如果节点完成了DFS（其邻居节点都已经向下DFS返回了），才将该节点入队<br>逆后序是后序的逆序，用一个Stack保存后序入队的节点即可</p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>对于有向无环图，拓扑排序满足如下条件：<br>如果有向图存在路径i-&gt;j，那么i在拓扑排序中一定在j的前面<br><code>拓扑排序就是有向图的逆后序</code>：因为逆后序的意思是，完成DFS的节点的逆序。所以如果逆后序里，i在j的前面说明节点j完成了DFS后节点i才完成。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2017/03/22/blog_article/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h1><h2 id="键索引记数法"><a href="#键索引记数法" class="headerlink" title="键索引记数法"></a>键索引记数法</h2><p>将String[]分成R组，统计每组字符串个数，由此计算出每组的首个字符串在排序后的位置后，即可得到每个字符串排序后的下标。</p>
<blockquote>
<p>该方法有一个特点：排序后，同一组内的字符串排序前的相对位置不变，正是这一点使得其可以用于低位优先字符串排序</p>
</blockquote>
<h2 id="低位优先的字符串排序"><a href="#低位优先的字符串排序" class="headerlink" title="低位优先的字符串排序"></a>低位优先的字符串排序</h2><p>前提条件：<code>每个字符串等长</code><br>所谓低位优先，就是从右往左排序，先排最右边的</p>
<blockquote>
<p>假设字符串长度W，从右往左，根据字符串当前位置的字符作为组号分成R组，使用键索引记数法完成W次排序即可得到这样有序的数组：<br>优先比较最左边元素，最左边元素相同，比较后面的元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LSD &#123;</span><br><span class="line">	public LSD() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void sort(String[] a, int W) &#123;</span><br><span class="line">		// 通过前W个字符将a[]排序</span><br><span class="line">		int N = a.length;</span><br><span class="line">		String aux[] = new String[N];</span><br><span class="line">		int R = 256;// ASCII字符集的字符数量，8位的ASCII字符集</span><br><span class="line">		for (int d = W - 1; d &gt;= 0; d--) &#123;</span><br><span class="line">			int count[] = new int[R + 1];</span><br><span class="line"></span><br><span class="line">			// 统计频率</span><br><span class="line">			for (int i = 0; i &lt; N; i++)</span><br><span class="line">				count[a[i].charAt(d) + 1]++;</span><br><span class="line">			// 将频率转换为索引</span><br><span class="line">			for (int r = 0; r &lt; R; r++)</span><br><span class="line">				count[r + 1] += count[r];</span><br><span class="line">			// 将元素分类</span><br><span class="line">			for (int i = 0; i &lt; N; i++)</span><br><span class="line">				aux[count[a[i].charAt(d)]++] = a[i];</span><br><span class="line">			// 回写</span><br><span class="line">			for (int i = 0; i &lt; N; i++)</span><br><span class="line">				a[i] = aux[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String a[] = &#123; &quot;4PGC938&quot;, &quot;2IYE230&quot;, &quot;3CIO720&quot;, &quot;1ICK750&quot;, &quot;1OHV845&quot; &#125;;</span><br><span class="line">		int W = 7;</span><br><span class="line">		sort(a, W);</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高位优先的字符串排序"><a href="#高位优先的字符串排序" class="headerlink" title="高位优先的字符串排序"></a>高位优先的字符串排序</h2><p>这种排序适合排序不同长度的字符串</p>
<blockquote>
<p>首先从每个字符串最左边的第一个字符作为分组标志，使用键索引记数法处理完成排序，之后针对排序后的每一个分组，对后面的字符 递归进行一样的操作</p>
</blockquote>
<p>类似快排的思想，但是这里的递归不是把数组分成两部分递归，而是R部分递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Number_5;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * P462 算法5.2 高位优先的字符串排序（从左向右，字符串长度不一定相同）</span><br><span class="line"> * 对于含大量等值键的子数组排序会比较慢且不适合很长字符串</span><br><span class="line"> * </span><br><span class="line"> * @author he</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MSD &#123;</span><br><span class="line">	private static int R = 256;// 8为ASCII表中的字符数量</span><br><span class="line">	private static final int M = 15;// 小数组的切分</span><br><span class="line">	private static String aux[];// 辅助数组</span><br><span class="line"></span><br><span class="line">	public MSD() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int charAt(String s, int d) &#123;</span><br><span class="line">		if (d &lt; s.length())</span><br><span class="line">			return s.charAt(d);</span><br><span class="line">		else &#123;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void sort(String a[]) &#123;</span><br><span class="line">		int N = a.length;</span><br><span class="line">		aux = new String[N];</span><br><span class="line">		sort(a, 0, N - 1, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void sort(String a[], int lo, int hi, int d) &#123;</span><br><span class="line">		// 对于小于一定长度的数组进行插入排序</span><br><span class="line">		if (hi &lt;= lo + M) &#123;</span><br><span class="line">			insertion(a, lo, hi, d);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int count[] = new int[R + 2];// count[0]不保存东西，count[1]保存的是长度不大于d的字符串数量</span><br><span class="line">		// 计算每个字符串位置d处的字符出现的频率</span><br><span class="line">		for (int i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">			int t = charAt(a[i], d);</span><br><span class="line">			count[t + 2]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 转换为索引</span><br><span class="line">		for (int r = 0; r &lt; R + 1; r++)</span><br><span class="line">			count[r + 1] += count[r];</span><br><span class="line"></span><br><span class="line">		// 分类</span><br><span class="line">		for (int i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">			int t = charAt(a[i], d);</span><br><span class="line">			aux[count[t + 1]++] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i = lo; i &lt;= hi; i++)</span><br><span class="line">			a[i] = aux[i - lo];</span><br><span class="line"></span><br><span class="line">		// 递归每个子字符串组</span><br><span class="line">		for (int r = 0; r &lt; R; r++)</span><br><span class="line">			sort(a, lo + count[r], lo + count[r + 1] - 1, d + 1);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 对字符串组插入排序</span><br><span class="line">	private static void insertion(String a[], int lo, int hi, int d) &#123;</span><br><span class="line">		for (int i = lo; i &lt;= hi; i++)</span><br><span class="line">			for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j - 1], d); j--)</span><br><span class="line">				exch(a, j, j - 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static boolean less(String w, String v, int d) &#123;</span><br><span class="line">		for (int i = d; i &lt; Math.min(w.length(), v.length()); i++) &#123;</span><br><span class="line">			if (w.charAt(i) &lt; v.charAt(i))</span><br><span class="line">				return true;</span><br><span class="line">			if (w.charAt(i) &gt; v.charAt(i)) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return w.length() &lt; v.length();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void exch(String a[], int i, int j) &#123;</span><br><span class="line">		String temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[] a = &#123; &quot;by&quot;, &quot;are&quot;, &quot;seashells&quot;, &quot;seashells&quot;, &quot;sells&quot; &#125;;</span><br><span class="line">		sort(a);</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三向字符串快速排序"><a href="#三向字符串快速排序" class="headerlink" title="三向字符串快速排序"></a>三向字符串快速排序</h2><p>高位优先的字符串排序时，每次根据字符串当前字符的不同，分成R组，而三向排序只分为三组。大于指定字符的，等于指定字符的，小于指定字符的。<br>只有等于指定字符的，继续向后递归。<br>不等于指定字符的，继续在当前字符位置递归。</p>
<blockquote>
<p>适合于String[]中重复字符串密集的情况</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * P469 算法5.3 三向字符串快速排序 适合含有大量等值键、有较长公共前缀的键、取值范围较小的键和小数组</span><br><span class="line"> */</span><br><span class="line">public class Quick3string &#123;</span><br><span class="line"></span><br><span class="line">	private static final int M = 0;// 切分数组的大小</span><br><span class="line"></span><br><span class="line">	public Quick3string() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int chatAt(String s, int d) &#123;</span><br><span class="line">		if (d &lt; s.length())</span><br><span class="line">			return s.charAt(d);</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void sort(String a[]) &#123;</span><br><span class="line">		StdRandom.shuffle(a);// 消除对输入的依赖</span><br><span class="line">		sort(a, 0, a.length - 1, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void sort(String a[], int lo, int hi, int d) &#123;</span><br><span class="line">		// 对于小数组使用插入排序</span><br><span class="line">		if (hi &lt;= lo + M) &#123;</span><br><span class="line">			Insterion(a, lo, hi, d);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 以String[]第d个字符作为Key做一次快排切分</span><br><span class="line">		int lt = lo, gt = hi, i = lo + 1;</span><br><span class="line">		int v = chatAt(a[lo], d);</span><br><span class="line"></span><br><span class="line">		while (i &lt;= gt) &#123;</span><br><span class="line">			int t = chatAt(a[i], d);</span><br><span class="line">			if (t &lt; v)</span><br><span class="line">				exch(a, lt++, i++);</span><br><span class="line">			else if (t &gt; v)</span><br><span class="line">				exch(a, i, gt--);</span><br><span class="line">			else</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 递归，先排序小于string[lo]的字符串，再排序等于String[lo]的字符串，最后排序大于string[lo]的字符串</span><br><span class="line">		sort(a, lo, lt - 1, d);		// 递归小于string[lo]的Strings的第d位</span><br><span class="line">		if (v &gt; 0)</span><br><span class="line">			sort(a, lt, gt, d + 1);		// 第d位等于String[lo]的Strings递归下一位</span><br><span class="line">		sort(a, gt + 1, hi, d);		// 递归大于string[lo]的Strings的第d位</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 插入排序</span><br><span class="line">	private static void Insterion(String a[], int lo, int hi, int d) &#123;</span><br><span class="line">		for (int i = lo; i &lt;= hi; i++)</span><br><span class="line">			for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1], d); j--)</span><br><span class="line">				exch(a, j, j - 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static boolean less(String s, String v, int d) &#123;</span><br><span class="line">		for (int i = d; i &lt; Math.min(s.length(), v.length()); i++) &#123;</span><br><span class="line">			if (s.charAt(i) &lt; v.charAt(i))</span><br><span class="line">				return true;</span><br><span class="line">			if (s.charAt(i) &gt; v.charAt(i))</span><br><span class="line">				return false;</span><br><span class="line">		&#125;</span><br><span class="line">		return s.length() &lt; v.length();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void exch(String a[], int i, int j) &#123;</span><br><span class="line">		String temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String a[] = &#123; &quot;com.cnn&quot;, &quot;edu.uva.cs&quot;, &quot;edu.uva.cs&quot;, &quot;com.google&quot; &#125;;</span><br><span class="line">		sort(a);</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h1><h2 id="单词查找树"><a href="#单词查找树" class="headerlink" title="单词查找树"></a>单词查找树</h2><p>1、树的每个节点维护：<br>node[]，node数组的下标索引代表单词的一个字符<br>一个泛型变量val，当前节点表示的字符是单词末尾字符时非空<br>2、单词查找树的root节点不存在val</p>
<blockquote>
<p>无论是增加单词还是查找单词还是匹配单词，从根节点出发，不断查找非空next[i]或创建next[i]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TrieST&lt;Value&gt; &#123;</span><br><span class="line">	private static final int R = 256;// 字母表的大小，8位的ASCII表中元素个数</span><br><span class="line">	private Node root;// 单词查找树的根结点,root.val==null</span><br><span class="line">	private int N;// 查找树中键的数量</span><br><span class="line"></span><br><span class="line">	public TrieST() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class Node &#123;</span><br><span class="line">		private Object val;// 键对应的值</span><br><span class="line">		private Node next[] = new Node[R];// 保存指向其他Node对象的引用</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void put(String key, Value val) &#123;</span><br><span class="line">		root = put(root, key, val, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 把key中的第d个字符添加到单词查找树中</span><br><span class="line">	private Node put(Node x, String key, Value val, int d) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			x = new Node();</span><br><span class="line">		// 将值保存到键的最后一个字符所在结点</span><br><span class="line">		if (d == key.length()) &#123;</span><br><span class="line">			if (x.val == null)</span><br><span class="line">				N++;</span><br><span class="line">			x.val = val;</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line">		char c = key.charAt(d);// 找到d个字符对应的子单词查找树</span><br><span class="line">		x.next[c] = put(x.next[c], key, val, d + 1);</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public Value get(String key) &#123;</span><br><span class="line">		Node x = get(root, key, 0);</span><br><span class="line">		if (x == null)</span><br><span class="line">			return null;</span><br><span class="line">		return (Value) x.val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 单词查找树找到key，返回该key的最后一个字符所对应的node</span><br><span class="line">	private Node get(Node x, String key, int d) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return null;</span><br><span class="line">		if (d == key.length())</span><br><span class="line">			return x;</span><br><span class="line">		char c = key.charAt(d);// 找到d个字符所对应的子单词查找树</span><br><span class="line">		return get(x.next[c], key, d + 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 返回单词查找树中所有的键</span><br><span class="line">	 */</span><br><span class="line">	public Iterable&lt;String&gt; keys() &#123;</span><br><span class="line">		return keysWithPrefix(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回所有以pre为前缀的键 比如单词查找树中有“shells”,pre为&quot;shel&quot;则返回shells</span><br><span class="line">	 */</span><br><span class="line">	public Iterable&lt;String&gt; keysWithPrefix(String pre) &#123;</span><br><span class="line">		Queue&lt;String&gt; q = new Queue&lt;String&gt;();</span><br><span class="line">		collect(get(root, pre, 0), pre, q);</span><br><span class="line">		return q;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 匹配以pre为前缀的键</span><br><span class="line">	private void collect(Node x, String pre, Queue&lt;String&gt; q) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return;</span><br><span class="line">		if (x.val != null)</span><br><span class="line">			q.enqueue(pre);		// 找到单词，入队</span><br><span class="line">		for (char c = 0; c &lt; R; c++)</span><br><span class="line">			collect(x.next[c], pre + c, q);		// 递归找当前节点之后的分支中存在的单词</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 所有和pat匹配的键，其中“.”表示能够匹配任意字符 比如单词查找树中有“shells”,pre为&quot;shel..&quot;则返回shells</span><br><span class="line">	 */</span><br><span class="line">	public Iterable&lt;String&gt; keysThatMath(String pat) &#123;</span><br><span class="line">		Queue&lt;String&gt; q = new Queue&lt;String&gt;();</span><br><span class="line">		collect(root, &quot;&quot;, pat, q);</span><br><span class="line">		if (q.size() == 0)</span><br><span class="line">			throw new RuntimeException(&quot;未找到匹配项&quot;);</span><br><span class="line">		return q;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param pre:已经匹配了的字符串</span><br><span class="line">	 * 将匹配pat模式的字符串加到q</span><br><span class="line">	 */</span><br><span class="line">	private void collect(Node x, String pre, String pat, Queue&lt;String&gt; q) &#123;</span><br><span class="line">		if (x == null)		// 未匹配到</span><br><span class="line">			return;</span><br><span class="line">		int d = pre.length();</span><br><span class="line">		if (d == pat.length() &amp;&amp; x.val != null)</span><br><span class="line">			q.enqueue(pre);		// 将匹配pat成功的字符串入队，不ret吗？</span><br><span class="line">		if (d == pat.length())		// 未匹配到</span><br><span class="line">			return;</span><br><span class="line">		char next = pat.charAt(d);</span><br><span class="line">		for (char c = 0; c &lt; R; c++)</span><br><span class="line">			if (next == &#x27;.&#x27; || next == c)</span><br><span class="line">				collect(x.next[c], pre + c, pat, q);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回s的前缀中最长的键,比如单词查找树中有&quot;she&quot;，则s=&quot;shell&quot;，返回&quot;she&quot;</span><br><span class="line">	 */</span><br><span class="line">	public String longestPrefixOf(String s) &#123;</span><br><span class="line">		int length = search(root, s, 0, 0);// 单词查找树中与s匹配的key的最大长度</span><br><span class="line">		return s.substring(0, length);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 记录查找与s相关的路径上所找到的最长键的长度</span><br><span class="line">	private int search(Node x, String s, int d, int length) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return length;		// 返回之前匹配的key的长度</span><br><span class="line">		if (x.val != null)</span><br><span class="line">			length = d;		// 更新长度</span><br><span class="line">		if (d == s.length())		// 单词查找树中包含s</span><br><span class="line">			return length;		// 如果单词树存在包含key的单词，返回key的长度</span><br><span class="line"></span><br><span class="line">		char c = s.charAt(d);</span><br><span class="line">		return search(x.next[c], s, d + 1, length);		// 继续查找后面的节点</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void delete(String key) &#123;</span><br><span class="line">		root = delete(root, key, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node delete(Node x, String key, int d) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return null;</span><br><span class="line">		if (d == key.length())</span><br><span class="line">			x.val = null;		// 匹配到要删除的键</span><br><span class="line">		else &#123;</span><br><span class="line">			char c = key.charAt(d);</span><br><span class="line">			x.next[c] = delete(x.next[c], key, d + 1);		// 继续查找后面的节点</span><br><span class="line">		&#125;</span><br><span class="line">		if (x.val != null)		// key路径上存在子key，不删除节点</span><br><span class="line">			return x;</span><br><span class="line">		for (char c = 0; c &lt; R; c++)		// 删除key路径上的节点存在向下分支，不删除节点</span><br><span class="line">			if (x.next[c] != null)</span><br><span class="line">				return x;</span><br><span class="line">		return null;		// 当前节点的val为null且不存在向下的分支，删除节点</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int size() &#123;</span><br><span class="line">		return N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三向单词查找树"><a href="#三向单词查找树" class="headerlink" title="三向单词查找树"></a>三向单词查找树</h2><p>单词查找树是将节点维护的node数组下标隐式代表字符，组成树<br>三向单词查找树，每个节点不维护包含所有字符下标的节点数组，只维护三个节点：left，mid，right<br>同时包含一个char表示当前节点代表的字符，如果当前字符等于char，访问mid，小于char，访问left，大于char，访问right<br>包含一个Value val，单词最后一个字符所代表节点的val非空，表示一个单词的完结</p>
<blockquote>
<p>三向的效果不需要维护所有字符个数的数组，只维护三个子节点，添加、查找单词都和当前节点的char比较来决定子节点的选择，而不是单词查找树通过当前字符作为索引查找节点数组。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TST&lt;Value&gt; &#123;</span><br><span class="line">	private Node root;		// 根结点</span><br><span class="line">	private int N;		//</span><br><span class="line"></span><br><span class="line">	private class Node &#123;</span><br><span class="line">		char c;		// 每个结点中保存的字符</span><br><span class="line">		Node left, mid, right;		// 每个节点只有左中右三个子节点</span><br><span class="line">		Value val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void put(String key, Value val) &#123;</span><br><span class="line">		root = put(root, key, val, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node put(Node x, String key, Value val, int d) &#123;</span><br><span class="line">		char c = key.charAt(d);</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			x = new Node();</span><br><span class="line">			x.c = c;		// 如果访问到空节点，以当前字符作为中间字符</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (c &lt; x.c)		// 未命中，根据比较当前节点的结果，key的当前字符不变，递归子节点</span><br><span class="line">			x.left = put(x.left, key, val, d);</span><br><span class="line">		else if (c &gt; x.c)</span><br><span class="line">			x.right = put(x.right, key, val, d);</span><br><span class="line">		else if (d &lt; key.length() - 1)		// 命中，但当前节点不是key最后一个字符</span><br><span class="line">			x.mid = put(x.mid, key, val, d + 1);		// 命中，移到key的下一个字符，递归子节点</span><br><span class="line">		else &#123;		// 当前节点就是key最后一个字符表示的节点</span><br><span class="line">			if (x.val == null)</span><br><span class="line">				N++;</span><br><span class="line">			x.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 在三向单词树中查找key</span><br><span class="line">	public Value get(String key) &#123;</span><br><span class="line">		if (key == null)</span><br><span class="line">			throw new NullPointerException();</span><br><span class="line">		if (key.length() == 0)</span><br><span class="line">			throw new IllegalArgumentException(&quot;key must have length &gt;= 1&quot;);</span><br><span class="line">		Node x = get(root, key, 0);</span><br><span class="line">		if (x == null)</span><br><span class="line">			return null;</span><br><span class="line">		return x.val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node get(Node x, String key, int d) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return null;</span><br><span class="line">		char c = key.charAt(d);</span><br><span class="line">		if (c &lt; x.c)		// 未命中，根据比较的结果访问子节点继续匹配当前字符</span><br><span class="line">			return get(x.left, key, d);</span><br><span class="line">		else if (c &gt; x.c)</span><br><span class="line">			return get(x.right, key, d);</span><br><span class="line">		else if (d &lt; key.length() - 1)</span><br><span class="line">			return get(x.mid, key, d + 1);		// 命中，匹配下一个字符</span><br><span class="line">		else</span><br><span class="line">			return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int size() &#123;</span><br><span class="line">		return N;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean contains(String key) &#123;</span><br><span class="line">		return get(key) != null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// s的子字符串表示的最长单词</span><br><span class="line">	public String longestPrefixOf(String s) &#123;</span><br><span class="line">		if (s == null || s.length() == 0)</span><br><span class="line">			return null;</span><br><span class="line">		int length = 0;</span><br><span class="line">		Node x = root;</span><br><span class="line">		int i = 0;</span><br><span class="line">		while (x != null &amp;&amp; i &lt; s.length()) &#123;</span><br><span class="line">			char c = s.charAt(i);</span><br><span class="line">			if (c &lt; x.c)</span><br><span class="line">				x = x.left;</span><br><span class="line">			else if (c &gt; x.c)</span><br><span class="line">				x = x.right;</span><br><span class="line">			else &#123;</span><br><span class="line">				// 命中</span><br><span class="line">				i++;</span><br><span class="line">				if (x.val != null)</span><br><span class="line">					length = i;		// 找到子s且是单词，记录单词长度</span><br><span class="line">				x = x.mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return s.substring(0, length);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Iterable&lt;String&gt; keys() &#123;</span><br><span class="line">		Queue&lt;String&gt; queue = new Queue&lt;String&gt;();</span><br><span class="line">		collect(root, new StringBuilder(), queue);</span><br><span class="line">		return queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 所有以s为前缀的键</span><br><span class="line">	public Iterable&lt;String&gt; keysWithPrefix(String prefix) &#123;</span><br><span class="line">		Queue&lt;String&gt; queue = new Queue&lt;String&gt;();</span><br><span class="line">		Node x = get(root, prefix, 0);</span><br><span class="line">		if (x == null)</span><br><span class="line">			return queue;</span><br><span class="line">		if (x.val != null)</span><br><span class="line">			queue.enqueue(prefix);</span><br><span class="line">		collect(x.mid, new StringBuilder(prefix), queue);</span><br><span class="line">		return queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void collect(Node x, StringBuilder prefix, Queue&lt;String&gt; queue) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return;</span><br><span class="line">		collect(x.left, prefix, queue);</span><br><span class="line">		if (x.val != null)</span><br><span class="line">			queue.enqueue(prefix.toString() + x.c);</span><br><span class="line">		collect(x.mid, prefix.append(x.c), queue);</span><br><span class="line">		prefix.deleteCharAt(prefix.length() - 1);// 将记录过的key删除，回溯到最初的首字母</span><br><span class="line">		collect(x.right, prefix, queue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 所有和s匹配的键(其中&quot;.&quot;能匹配任意字符)</span><br><span class="line">	public Iterable&lt;String&gt; keysThatMatch(String pattern) &#123;</span><br><span class="line">		Queue&lt;String&gt; queue = new Queue&lt;String&gt;();</span><br><span class="line">		collect(root, new StringBuilder(), 0, pattern, queue);</span><br><span class="line">		return queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void collect(Node x, StringBuilder prefix, int i, String pattern, Queue&lt;String&gt; queue) &#123;</span><br><span class="line">		if (x == null)</span><br><span class="line">			return;</span><br><span class="line">		char c = pattern.charAt(i);</span><br><span class="line">		if (c == &#x27;.&#x27; || c &lt; x.c)</span><br><span class="line">			collect(x.left, prefix, i, pattern, queue);</span><br><span class="line">		if (c == &#x27;.&#x27; || c == x.c) &#123;</span><br><span class="line">			if (i == pattern.length() - 1 &amp;&amp; x.val != null)</span><br><span class="line">				queue.enqueue(prefix.toString() + x.c);</span><br><span class="line">			if (i &lt; pattern.length() - 1) &#123;</span><br><span class="line">				collect(x.mid, prefix.append(x.c), i + 1, pattern, queue);</span><br><span class="line">				prefix.deleteCharAt(prefix.length() - 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (c == &#x27;.&#x27; || c &gt; x.c)</span><br><span class="line">			collect(x.right, prefix, i, pattern, queue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子字符串查找"><a href="#子字符串查找" class="headerlink" title="子字符串查找"></a>子字符串查找</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul>
<li><p>KMP的核心思想是要构造next数组。</p>
</li>
<li><p>next[i]的含义<br><code>target的第i个字符及其之前的字符组成的子字符串与从target头部开始匹配的字符个数</code></p>
</li>
<li><p>next数组的求法<br>初始化：next[0]&#x3D;next[1]&#x3D;0</p>
</li>
<li><p>next数组在字符串查找中，扮演了极其重要的角色。</p>
<ul>
<li>当target[i]和source[j]不匹配时，不需要完全回退到target[0]重新开始比较，通过查找next数组，可以知道source[j-1]处已经匹配了多少个target字符，所以source[j]可以从其后的target字符开始比较，无需回退source，大大减少了重复比较的次数。</li>
</ul>
</li>
<li><p>不用KMP的暴力比较，其时间复杂度是<br><code>O(source.length() * target.length())</code></p>
</li>
<li><p>KMP的时间复杂度是<br><code>O(source.length() + target.length())</code><br>此图帮助你理解KMP的思想：<br><img src="http://img.blog.csdn.net/20130924000026250"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int[] next;</span><br><span class="line">    public int strStr(String source, String target) &#123;</span><br><span class="line">        // 特殊情况处理</span><br><span class="line">        if(source == null || target == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // 预处理target字符串，得到next数组</span><br><span class="line">		kmpPreview(target);</span><br><span class="line">		</span><br><span class="line">		int sourceIndex = 0;</span><br><span class="line">		int targetIndex = 0;</span><br><span class="line">		while(sourceIndex != source.length()) &#123;	// 如果访问完了source还未找到匹配，则不包含target</span><br><span class="line">			//对应字符相等的处理</span><br><span class="line">			if(source.charAt(sourceIndex) == target.charAt(targetIndex)) &#123;</span><br><span class="line">				// target匹配成功</span><br><span class="line">				if(targetIndex == target.length()-1) &#123;</span><br><span class="line">					return sourceIndex - target.length() + 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					sourceIndex++;</span><br><span class="line">					targetIndex++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;	// 对应字符不等的处理</span><br><span class="line">				// 如果回退到target头部仍不相等，则放弃当前的进度，开始比较source的下一个字符</span><br><span class="line">				if (targetIndex == 0) &#123;</span><br><span class="line">					sourceIndex++;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// 对应字符不等的处理，由next数组回退target下标，依然和当前的source对应的字符比较，利用了之前比较的进度</span><br><span class="line">					targetIndex = next[targetIndex];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 不包含target</span><br><span class="line">		return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">	 * @intention:构造next数组。next[i]表示s的第i个字符及其之前的字符组成的子字符串，与从s头开始完全匹配的字符个数</span><br><span class="line">	 */</span><br><span class="line">	private void kmpPreview(String s) &#123;</span><br><span class="line">		next = new int[s.length()+1];</span><br><span class="line">		next[0] = 0;</span><br><span class="line">		next[1] = 0;</span><br><span class="line">		for(int i = 2; i &lt;= s.length(); i++) &#123;</span><br><span class="line">			if(s.charAt(i-1) == s.charAt(next[i-1])) &#123;</span><br><span class="line">				next[i] = next[i-1] + 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				next[i] = 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><p>pat按照从右往左与txt比较<br>当出现对应位不匹配时，使txt[i]与pat中与其相同的字符对齐<br>1、如果不存在或者pat与其相同的字符在pat当前比较字符的右边，则将pat往后移动一位<br>2、如果在左边，移动pat使之与txt[i]对齐<br>继续从右往左比较<br>如果比完了所有的pat，则找到匹配<br>如果pat移出了txt的右边界，则匹配失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BoyerMoore &#123;</span><br><span class="line">	private int right[];</span><br><span class="line">	private String pat;</span><br><span class="line"></span><br><span class="line">	public BoyerMoore(String pat) &#123;</span><br><span class="line">		this.pat = pat;</span><br><span class="line">		int R = 256;// 八位ASCII字符表对应的字符数量</span><br><span class="line">		int M = pat.length();</span><br><span class="line">		right = new int[R];</span><br><span class="line"></span><br><span class="line">		for (char c = 0; c &lt; R; c++)</span><br><span class="line">			right[c] = -1; // 文本中不包含在模式字符串中的字符的为-1，原因见skip=j-right[txt.charAt(i+j)]的注释</span><br><span class="line">		for (int j = 0; j &lt; M; j++)</span><br><span class="line">			right[pat.charAt(j)] = j;// 包含在模式字符串中的字符的值为它在模式中出现的最右位置,skip=j-right[txt.charAt(i+j)]会出现skip&lt;1的情况</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int search(String txt) &#123;</span><br><span class="line">		int i, N = txt.length();</span><br><span class="line">		int j, M = pat.length();</span><br><span class="line">		int skip; </span><br><span class="line">		for (i = 0; i &lt; N - M; i += skip) &#123;</span><br><span class="line">			skip = 0;</span><br><span class="line">			for (j = M - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">				if (txt.charAt(i + j) != pat.charAt(j)) &#123;</span><br><span class="line">					/**</span><br><span class="line">					 * skip为将txt当前字符与pat对齐时，pat需要移动的位数</span><br><span class="line">					 */</span><br><span class="line">					skip = j - right[txt.charAt(i + j)]; </span><br><span class="line">					/**</span><br><span class="line">					 * txt字符在pat当前字符的左边，只能将pat向后移一位</span><br><span class="line">					 */</span><br><span class="line">					if (skip &lt; 1)</span><br><span class="line">						skip = 1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (skip == 0)</span><br><span class="line">				return i; // 找到匹配</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		return N;// 未找到匹配</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h2><p>将pat转化为一个R进制的数，用除留余数法除以一个较大的素数Q取余得到pat的hash值<br>计算txt的前M（pat的长度）个字符的hash值<br>1、如果相等，认为匹配成功（当Q极大时，hash相等但不同字符串的概率极低）<br>2、如果不相等，减去最左边的字符代表的值（注意是R进制）加上下一个字符的值，再求hash值，重复之前的步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RabinKarp &#123;</span><br><span class="line">	private String pat;// 用于拉斯维加斯算法的check</span><br><span class="line">	private long patHash;// 模式字符串的散列值</span><br><span class="line">	private int M;// 模式字符串的长度</span><br><span class="line">	private long Q;// 一个很大的素数</span><br><span class="line">	private int R = 256;// 8为ASCII表的元素数量</span><br><span class="line">	private long RM;// R^(M-1)%Q</span><br><span class="line"></span><br><span class="line">	public RabinKarp(String pat) &#123;</span><br><span class="line">		this.pat = pat;</span><br><span class="line">		this.M = pat.length();</span><br><span class="line">		Q = longRandomPrime();</span><br><span class="line">		RM = 1;</span><br><span class="line">		// 计算R^(M-1)%Q</span><br><span class="line">		for (int i = 1; i &lt;= M - 1; i++)</span><br><span class="line">			RM = (R * RM) % Q;</span><br><span class="line">		patHash = hash(pat, M);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int search(String txt) &#123;</span><br><span class="line">		int N = txt.length();</span><br><span class="line">		long txtHash = hash(txt, M);// 获取文本前M个字符串的hash值</span><br><span class="line">		if (txtHash == patHash &amp;&amp; check(0)) // 一开始就命中</span><br><span class="line">			return 0;</span><br><span class="line">		// 文本字符开始右移并进行匹配</span><br><span class="line">		for (int i = M; i &lt; N; i++) &#123;</span><br><span class="line">			txtHash = (txtHash + Q - RM * txt.charAt(i - M) % Q) % Q;</span><br><span class="line">			txtHash = (txtHash * R + txt.charAt(i)) % Q;</span><br><span class="line"></span><br><span class="line">			/**</span><br><span class="line">			 * 上面两行等价于下面这一行代码，见书中图5.3.17 i&gt;=5的部分</span><br><span class="line">			 */</span><br><span class="line">			// txtHash=((txtHash+txt.charAt(i-M)*(Q-RM))*R+txt.charAt(i))%Q;</span><br><span class="line"></span><br><span class="line">			if (patHash == txtHash)</span><br><span class="line">				if (check(i - M + 1))</span><br><span class="line">					return i - M + 1;// 找到匹配</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		return N;// 未找到匹配</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 可蒙特算法</span><br><span class="line">	public boolean check(int i) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 拉斯维加斯算法</span><br><span class="line">	public boolean check(String txt, int i) &#123;</span><br><span class="line">		for (int j = 0; j &lt; M; j++) &#123;</span><br><span class="line">			if (txt.charAt(j + i) != pat.charAt(j))</span><br><span class="line">				return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 计算字符串的散列值，散列值为256进制的key值余Q</span><br><span class="line">	private long hash(String key, int M) &#123;</span><br><span class="line">		long h = 0;</span><br><span class="line">		for (int i = 0; i &lt; M; i++)</span><br><span class="line">			h = (R * h + key.charAt(i)) % Q;</span><br><span class="line">		return h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 返回31位的随机素数</span><br><span class="line">	private long longRandomPrime() &#123;</span><br><span class="line">		BigInteger prime = BigInteger.probablePrime(31, new Random());</span><br><span class="line">		return prime.longValue();// 转换为long类型</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2017/03/14/blog_article/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><blockquote>
<p>定义：一种可以添加元素和删除最大&#x2F;小元素的数据结构</p>
</blockquote>
<p>难点：</p>
<blockquote>
<p>如何高校地实现优先队列？使得删除最大&#x2F;小元素能在常数时间内完成？</p>
</blockquote>
<p>用二叉堆！</p>
<blockquote>
<p>二叉堆是一组能用堆有序的完全二叉树表示的数组。数组的下标即元素在二叉树中的位置。<br>堆有序：父节点大于&#x2F;小于子节点</p>
</blockquote>
<p>怎么实现？</p>
<blockquote>
<p>插入操作时，将元素插入到数组尾部，然后做上浮操作<br>删除最值时，先将数组最后一个元素与根元素（数组第一个元素）交换，删除根元素，再做下沉操作</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>对数级别的插入和删除最值</p>
</blockquote>
<p>JAVA中用二叉小顶堆实现的优先队列</p>
<blockquote>
<p><code>PriorityQueue</code> （卧槽，这直译过来不就是优先队列吗……被自己蠢哭）</p>
</blockquote>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>如果用数组表示堆：</p>
<ul>
<li>先从数组的中间位置开始，从后往前对每个元素做下沉操作，一遍下来数组就是一个堆有序数组</li>
<li>每次交换数组的首位元素后，将尾元素弹出（最值），然后对首元素做下沉操作。重复这个操作直到数组为空，即可完成对原数组的排序</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>一次遍历，找到从当前位置开始到末尾的最小元素，与当前节点交换即可</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>一次遍历，将当前节点放入从开头到当前节点范围内的正确的位置</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote>
<p>1、h &#x3D; a*n + 1；a和n可以自己设置<br>2、将数组分成h间隔的h个子数组，对子数组运用插入排序<br>3、如果h &gt;1，h &#x3D; h &#x2F; a；<br>4、重复2<br>当完成h&#x3D;1的排序后，排序完毕。h&#x3D;1当然就是和插入排序一致</p>
</blockquote>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote>
<p>0、当数组只含有一个元素，返回<br>1、将数组的左半边排序<br>2、将数组的右半边排序<br>3、将左半边与右半边原地归并</p>
</blockquote>
<p>显而易见用递归<br>原地归并就是从两个已排序数组排序。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>1、将基准元素（头元素）放入到正确的位置（左边的元素都小于等于它，右边的元素都大于它）<br>i. 变量i指向最左边下标，变量j指向最右边下标，变量x保存基准元素<br>ii. a[j]&gt;x，j–      a[j]&lt;x，a[i]&#x3D;a[j]<br>iii. a[i]&lt;x，i++     a[i]&gt;x，a[j]&#x3D;a[i]<br>重复ii和iii，直到i &gt;&#x3D; j<br>a[i]&#x3D;x</p>
<p>2、分治，递归左子数组和右子数组</p>
<p>显而易见用递归</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>查找</title>
    <url>/2017/03/10/blog_article/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p>JAVA中用Map实现查找，根据key查找value。下面介绍几种Map数据结构的实现</p>
</blockquote>
<h1 id="有序数组的二分查找"><a href="#有序数组的二分查找" class="headerlink" title="有序数组的二分查找"></a>有序数组的二分查找</h1><p>用key[]和value[]来保存Key-value，一对key-value的下标也相等<br>该实现的核心是rank(key)方法，该方法通过二分查找，找到key在key[]里的下标，如果不存在，返回key[]中比key小的key的数目。所以，rank方法返回的就是key在key[]中的下标（无论是已经存在了还是将要插入）<br>该实现在put，get，delete方法时，均会调用rank方法。而rank方法的时间复杂度因为用了二分，所以是<code>O(logN)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line">	private Key keys[];</span><br><span class="line">	private Value values[];</span><br><span class="line">	private int N = 0;// 元素数量</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public BinarySearchST(int capacity) &#123;</span><br><span class="line">		keys = (Key[]) new Comparable[capacity];</span><br><span class="line">		values = (Value[]) new Object[capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int size() &#123;</span><br><span class="line">		return N;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean isEmpty() &#123;</span><br><span class="line">		return N == 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 根据Key返回对应的Value</span><br><span class="line">	 */</span><br><span class="line">	public Value get(Key key) &#123;</span><br><span class="line">		if (key == null) &#123;</span><br><span class="line">			throw new RuntimeException(&quot;key can&#x27;t be null&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int i = rank(key);</span><br><span class="line">		if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) &#123;</span><br><span class="line">			return values[i];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 二分查找，如果命中，返回下标，如果未命中，返回小于该值的数目</span><br><span class="line">	 * keys[rank(key)]:大于等于key的最小值</span><br><span class="line">	 * keys[rank(key)-1]:小于等于key的最大值</span><br><span class="line">	 */</span><br><span class="line">	public int rank(Key key) &#123;</span><br><span class="line">		int lo = 0, hi = N - 1;</span><br><span class="line">		while (lo &lt;= hi) &#123;</span><br><span class="line">			int mid = lo + (hi - lo) / 2;</span><br><span class="line">			int t = key.compareTo(keys[mid]);</span><br><span class="line">			if (t &gt; 0) &#123;</span><br><span class="line">				lo = mid + 1;</span><br><span class="line">			&#125; else if (t &lt; 0) &#123;</span><br><span class="line">				hi = mid - 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 向符号表中添加键值对</span><br><span class="line">	 */</span><br><span class="line">	public void put(Key key, Value value) &#123;</span><br><span class="line">		if (key == null) &#123;</span><br><span class="line">			throw new RuntimeException(&quot;key can&#x27;t be null&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 命中，i为key的下标</span><br><span class="line">		// 未命中，i为key插入到数组后的下标</span><br><span class="line">		int i = rank(key);</span><br><span class="line">		</span><br><span class="line">		// 命中，已存在，更新</span><br><span class="line">		if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) &#123;</span><br><span class="line">			values[i] = value;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 未命中添加,此时是有序添加</span><br><span class="line">		for (int j = N; j &gt; i; j--) &#123;</span><br><span class="line">			keys[j] = keys[j - 1];</span><br><span class="line">			values[j] = values[j - 1];</span><br><span class="line">		&#125;</span><br><span class="line">		keys[i] = key;</span><br><span class="line">		values[i] = value;</span><br><span class="line">		N++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 根据key删除键值对 将该键后面的键前移</span><br><span class="line">	 */</span><br><span class="line">	public void delete(Key key) &#123;</span><br><span class="line">		if (key == null) &#123;</span><br><span class="line">			throw new RuntimeException(&quot;key can&#x27;t be null&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		int i = rank(key);</span><br><span class="line">		// 未命中</span><br><span class="line">		if (i == N || keys[i].compareTo(key) != 0) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 命中，key后面的元素前移</span><br><span class="line">		for (int j = i; j &lt; N - 1; j++) &#123;</span><br><span class="line">			keys[j] = keys[j + 1];</span><br><span class="line">			values[j] = values[j + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		// 最后一位留空</span><br><span class="line">		keys[N - 1] = null;</span><br><span class="line">		values[N - 1] = null;</span><br><span class="line">		N--;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 返回最小键</span><br><span class="line">	public Key min() &#123;</span><br><span class="line">		return keys[0];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Key max() &#123;</span><br><span class="line">		return keys[N - 1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 根据下标找key</span><br><span class="line">	 */</span><br><span class="line">	public Key select(int k) &#123;</span><br><span class="line">		return keys[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 大于等于该键的最小键</span><br><span class="line">	 */</span><br><span class="line">	public Key ceiling(Key key) &#123;</span><br><span class="line">		// key比Keys里的key都大！返回keys[N]应该是null！</span><br><span class="line">		int i = rank(key);</span><br><span class="line">		return keys[i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 小于等于该键的最大键</span><br><span class="line">	 */</span><br><span class="line">	public Key floor(Key key) &#123;</span><br><span class="line">		// 有该键</span><br><span class="line">		if (get(key) != null) &#123;</span><br><span class="line">			return keys[rank(key)];</span><br><span class="line">		&#125; else if (get(key) == null &amp;&amp; rank(key) != 0) &#123;// 不存在该键且rank(key)不再数组最左边</span><br><span class="line">			return keys[rank(key) - 1];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;	// key比keys里的key都小</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 迭代器的实现:返回一个将所有的Key都入队的Queue </span><br><span class="line">	 */</span><br><span class="line">	public Iterable&lt;Key&gt; key()&#123;</span><br><span class="line">		Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;();</span><br><span class="line">		for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">			queue.enqueue(keys[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		return queue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		BinarySearchST&lt;String, Integer&gt; st = new BinarySearchST&lt;String, Integer&gt;(10);</span><br><span class="line">		st.put(&quot;A&quot;, 3);</span><br><span class="line">		st.put(&quot;C&quot;, 2);</span><br><span class="line">		st.put(&quot;B&quot;, 1);</span><br><span class="line">		System.out.println(st.key());//A B C</span><br><span class="line">		System.out.println(st.get(&quot;B&quot;));</span><br><span class="line">		System.out.println(st.ceiling(&quot;D&quot;));// null</span><br><span class="line">		st.delete(&quot;A&quot;);</span><br><span class="line">		System.out.println(st.get(&quot;A&quot;));// null</span><br><span class="line">		System.out.println(st.floor(&quot;A&quot;));// null</span><br><span class="line">		System.out.println(st.key());// B C</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉树的实现都是采用递归，将每个操作的逻辑理顺，之后递归就可以了。<br>注意，有些方法例如put元素、删除元素，会对途经的节点产生影响，注意在递归返回的时候更新节点<br>向上向下取整的方法比较难理解：向上取整一定最后会访问左子树，如果左子树找到结果，返回结果，否则返回父节点<br>删除节点：删除节点的做法是用被删节点的右子树中最小的节点代替被删节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">	private Node root;// 根结点</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 结点类，用于储存键-值对、左右结点以及结点计数器 size(x)=size(x.left)+size(x.right)+1;</span><br><span class="line">	 * </span><br><span class="line">	 * @author he</span><br><span class="line">	 *</span><br><span class="line">	 */</span><br><span class="line">	private class Node &#123;</span><br><span class="line">		private Key key;// 键</span><br><span class="line">		private Value value;// 值</span><br><span class="line">		private Node left, right;// 指向左右子树的连接</span><br><span class="line">		private int N;// 以该结点为根的子树中的结点数</span><br><span class="line"></span><br><span class="line">		public Node(Key key, Value value, int N) &#123;</span><br><span class="line">			this.key = key;</span><br><span class="line">			this.value = value;</span><br><span class="line">			this.N = N;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int size() &#123;</span><br><span class="line">		return size(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private int size(Node x) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return x.N;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 根据键返回值</span><br><span class="line">	public Value get(Key key) &#123;</span><br><span class="line">		return get(root, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 递归遍历二叉查找树</span><br><span class="line">	private Value get(Node x, Key key) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int cmp = key.compareTo(x.key);</span><br><span class="line">		if (cmp &lt; 0) &#123;</span><br><span class="line">			return get(x.left, key);</span><br><span class="line">		&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">			return get(x.right, key);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return x.value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 添加键值对</span><br><span class="line">	public void put(Key key, Value value) &#123;</span><br><span class="line">		root = put(root, key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 始终返回的是根结点</span><br><span class="line">	private Node put(Node x, Key key, Value value) &#123;</span><br><span class="line">		// 如果key存在则更新，否则添加新结点</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return new Node(key, value, 1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int cmp = key.compareTo(x.key);</span><br><span class="line">		if (cmp &lt; 0) &#123;</span><br><span class="line">			x.left = put(x.left, key, value);</span><br><span class="line">		&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">			x.right = put(x.right, key, value);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			x.value = value;</span><br><span class="line">		&#125;</span><br><span class="line">		// 添加新节点后，更新该节点路径上的每个节点的子节点数</span><br><span class="line">		x.N = size(x.left) + size(x.right) + 1;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 返回最小键</span><br><span class="line">	public Key min() &#123;</span><br><span class="line">		return min(root).key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node min(Node x) &#123;</span><br><span class="line">		if (x.left == null) &#123;</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line">		return min(x.left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 返回最大键</span><br><span class="line">	public Key max() &#123;</span><br><span class="line">		return max(root).key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node max(Node x) &#123;</span><br><span class="line">		if (x.right == null) &#123;</span><br><span class="line">			return x;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return max(x.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 向下取整，小于等于key的最大键</span><br><span class="line">	public Key floor(Key key) &#123;</span><br><span class="line">		Node x = floor(root, key);</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return x.key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 如果key小于根节点则向下取整一定左子树中， 如果大于根结点，则可能在右子树中,如果没有右子数，则根结点就是满足条件的key</span><br><span class="line">	 */</span><br><span class="line">	private Node floor(Node x, Key key) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int cmp = key.compareTo(x.key);</span><br><span class="line">		// 如果root.key &gt; key，root = root.left</span><br><span class="line">		if (cmp &lt; 0) &#123;</span><br><span class="line">			return floor(x.left, key);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果root.key &lt;= key，root = root.right</span><br><span class="line">		Node t = floor(x.right, key);</span><br><span class="line">		// 如果右子节点为空，返回当前节点，否则递归右子节点的结果就是小于等于key的最大值</span><br><span class="line">		if (t != null) &#123;</span><br><span class="line">			return t;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 向上取整,大于等于key的最小键</span><br><span class="line">	public Key ceiling(Key key) &#123;</span><br><span class="line">		Node x = ceiling(root, key);</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return x.key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 求大于key的最小节点</span><br><span class="line">	 * 如果key4大于根结点3则向上取整一定在右子树中，如果key4小于根结点6，则结果可能在节点6的左子树（假设存在大于key4的子节点）</span><br><span class="line">	 * 所以递归左子树返回时，如果找到了（递归返回非空），则返回结果; 如果没找到返回空，则返回根节点6</span><br><span class="line">	 */</span><br><span class="line">	private Node ceiling(Node x, Key key) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		int cmp = key.compareTo(x.key);</span><br><span class="line">		if (cmp == 0) &#123;</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line">		// 结果肯定在右子数中</span><br><span class="line">		if (cmp &gt; 0) &#123;</span><br><span class="line">			return ceiling(x.right, key);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 结果可能在左子树中</span><br><span class="line">		Node t = ceiling(x.left, key);</span><br><span class="line">		// 左子树找到符合条件的结果，返回结果</span><br><span class="line">		if (t != null) &#123;</span><br><span class="line">			return t;</span><br><span class="line">		&#125; else &#123;	// 左子树没找到结果，返回根节点</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 根据索引查找键</span><br><span class="line">	public Key select(int k) &#123;</span><br><span class="line">		if (k &lt; 0 || k &gt;= size())</span><br><span class="line">			throw new IllegalArgumentException();</span><br><span class="line">		return select(root, k).key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 如果左子树的结点数t大于k，则递归地在左子树中查找排名为k的键； 如果t等于k，在返回根结点的键；</span><br><span class="line">	 * 如果t小于k，递归地在右子树中查找排名为（k-t-1）的键</span><br><span class="line">	 */</span><br><span class="line">	private Node select(Node x, int k) &#123;</span><br><span class="line">		// 返回排名为k的结点</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		int t = size(x.left);</span><br><span class="line">		if (t &gt; k) &#123;</span><br><span class="line">			return select(x.left, k);</span><br><span class="line">		&#125; else if (t &lt; k) &#123;</span><br><span class="line">			return select(x.right, k - t - 1);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 根据键返回下下标（排名）</span><br><span class="line">	public int rank(Key key) &#123;</span><br><span class="line">		return rank(root, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 如果给定的键和根结点的键相等，返回根节点左子树的结点总数t</span><br><span class="line">	 * 如果给定的键比根结点的键小,递归左子树计算；</span><br><span class="line">	 * 如果给定的键比根结点的键大，返回根结点左子树结点总数t+1+它在右子树的排名</span><br><span class="line">	 */</span><br><span class="line">	private int rank(Node x, Key key) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int cmp = key.compareTo(x.key);</span><br><span class="line">		if (cmp &lt; 0) &#123;</span><br><span class="line">			return rank(x.left, key);</span><br><span class="line">		&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">			return 1 + size(x.left) + rank(x.right, key);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return size(x.left);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 删除最小的结点</span><br><span class="line">	public void deleteMin() &#123;</span><br><span class="line">		root = deleteMin(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node deleteMin(Node x) &#123;</span><br><span class="line">		// 找到最小节点，返回其右子节点代替其原来的位置</span><br><span class="line">		if (x.left == null) &#123;</span><br><span class="line">			return x.right;</span><br><span class="line">		&#125;</span><br><span class="line">		// 更新最小节点路径上的节点的左子节点</span><br><span class="line">		x.left = deleteMin(x.left);</span><br><span class="line">		// 更新最小节点路径上的每个节点的子节点数</span><br><span class="line">		x.N = size(x.left) + size(x.right) + 1;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 删除最大的结点</span><br><span class="line">	public void deleteMax() &#123;</span><br><span class="line">		root = deleteMax(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Node deleteMax(Node x) &#123;</span><br><span class="line">		if (x.right == null) &#123;</span><br><span class="line">			return x.left;</span><br><span class="line">		&#125;</span><br><span class="line">		x.right = deleteMax(x.right);</span><br><span class="line">		x.N = size(x.left) + size(x.right) + 1;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 删除指定结点</span><br><span class="line">	public void delete(Key key) &#123;</span><br><span class="line">		root = delete(root, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 递归找到待删节点</span><br><span class="line">	 * 如果待删节点的子节点存在空节点，由非空的节点代替被删节点</span><br><span class="line">	 * 如果待删节点的子节点均不为空，则用大于被删节点的子节点中最小的节点代替被删节点</span><br><span class="line">	 * 更新被删节点路径上的节点</span><br><span class="line">	 */</span><br><span class="line">	private Node delete(Node x, Key key) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		int cmp = key.compareTo(x.key);</span><br><span class="line">		// key &lt; node.key，到左子数中继续查找</span><br><span class="line">		if (cmp &lt; 0) &#123;</span><br><span class="line">			// 更新被查找节点路径上的每个节点</span><br><span class="line">			x.left = delete(x.left, key);</span><br><span class="line">		&#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">			// 更新被查找节点路径上的每个节点</span><br><span class="line">			x.right = delete(x.right, key);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 如果被删节点只有一个子节点，该子节点代替其原来的位置（返回子节点）</span><br><span class="line">			if (x.right == null)</span><br><span class="line">				return x.left;</span><br><span class="line">			if (x.left == null)</span><br><span class="line">				return x.right;</span><br><span class="line">			</span><br><span class="line">			// 如果被删节点有两个子节点，比被删节点大的节点中的最小的那个节点代替被删节点的位置</span><br><span class="line">			Node t = x;</span><br><span class="line">			x = min(t.right);	// 找到比被删节点大的最小节点</span><br><span class="line">			x.right = deleteMin(t.right);	// 代替被删节点</span><br><span class="line">			x.left = t.left;	// 代替被删节点</span><br><span class="line">		&#125;</span><br><span class="line">		x.N = size(x.left) + size(x.right) + 1;		// 更新被删节点路径上的节点的的子节点数</span><br><span class="line">		return x;	// 返回更新后的节点</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 遍历树中所有的键,采用中序遍历--&gt;左-根-右</span><br><span class="line">	public Iterable&lt;Key&gt; keys() &#123;</span><br><span class="line">		return keys(min(), max());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 遍历指定范围内的键</span><br><span class="line">	public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123;</span><br><span class="line">		Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();</span><br><span class="line">		keys(root, queue, lo, hi);</span><br><span class="line">		return queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123;</span><br><span class="line">		if (x == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int cmplo = lo.compareTo(x.key);</span><br><span class="line">		int cmphi = hi.compareTo(x.key);</span><br><span class="line">		</span><br><span class="line">		// 如果根节点大于lo，递归左子数组</span><br><span class="line">		if (cmplo &lt; 0) &#123;</span><br><span class="line">			keys(x.left, queue, lo, hi);</span><br><span class="line">		&#125;</span><br><span class="line">		// 左子数组递归完毕，如果根节点在范围内，加入当前节点</span><br><span class="line">		if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) &#123;</span><br><span class="line">			queue.enqueue(x.key);</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果根节点小于hi，递归右子数组</span><br><span class="line">		if (cmphi &gt; 0) &#123;</span><br><span class="line">			keys(x.right, queue, lo, hi);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		BST&lt;String, Integer&gt; bst = new BST&lt;String, Integer&gt;();</span><br><span class="line">		bst.put(&quot;S&quot;, 0);</span><br><span class="line">		bst.put(&quot;E&quot;, 1);</span><br><span class="line">		bst.put(&quot;A&quot;, 2);</span><br><span class="line">		bst.put(&quot;C&quot;, 3);</span><br><span class="line">		bst.put(&quot;R&quot;, 4);</span><br><span class="line">		bst.put(&quot;X&quot;, 5);</span><br><span class="line">		bst.put(&quot;H&quot;, 6);</span><br><span class="line">		bst.put(&quot;M&quot;, 7);</span><br><span class="line">		System.out.println(bst.get(&quot;E&quot;));</span><br><span class="line">		bst.deleteMin();</span><br><span class="line">		System.out.println(bst.min());</span><br><span class="line">		System.out.println(bst.max());</span><br><span class="line">		System.out.println(bst.floor(&quot;G&quot;));</span><br><span class="line">		System.out.println(&quot;ceiling:&quot; + bst.ceiling(&quot;A&quot;));</span><br><span class="line">		System.out.println(bst.select(1));</span><br><span class="line">		System.out.println(bst.rank(&quot;S&quot;));</span><br><span class="line">		bst.deleteMin();</span><br><span class="line">		System.out.println(bst.select(0));</span><br><span class="line">		bst.deleteMax();</span><br><span class="line">		System.out.println(bst.select(bst.size() - 1));</span><br><span class="line">		bst.delete(&quot;X&quot;);</span><br><span class="line">		System.out.println(bst.get(&quot;X&quot;));</span><br><span class="line">		for (String s : bst.keys()) &#123;</span><br><span class="line">			System.out.print(s + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h1><p>二叉查找树每个节点都只有一个key，两个子节点<br>2-3查找树，每个节点有1或2个key，2或3个子节点。当有1个key时，有左右子节点；当有2个key时，有左中右三个子节点</p>
<blockquote>
<p>二叉查找树在顺序插入的时候，性能最差，因其已经变成了链表<br>但2-3查找树在最差的情况下，依然有较好的查找性能<br>其插入的原则是：保证节点最多有2个key，如果加入造成某个节点有3个key，将中间的节点弹到父节点，递归处理</p>
</blockquote>
<h1 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h1><blockquote>
<p>红黑树是2-3查找树的二叉版</p>
</blockquote>
<p>上面说到，2-3查找树在节点有2个key时，包含3个子节点，这一点不符合二叉树的定义<br>红黑树是二叉树，它是怎么对2-3查找树改造的呢？</p>
<blockquote>
<p>对于2-3查找树中存在2个key的节点，用一条红色链接将2个key分成2个节点，这里红色链接是左链接<br>链接指向的节点（较小的节点）定义为红色节点，其余节点为黑色节点</p>
</blockquote>
<p>因为2-3查找树是平衡树（叶子节点到根节点的距离相等），而2-3查找树中只有“3节点”的较小的key为红黑树中的红色节点，所以一个“3节点”包含一个红色节点一个黑色节点，又因为2-3查找树是平衡树，所以</p>
<blockquote>
<p>红黑树中，每条到叶子节点的路径上包含相同数目的黑色节点（就是红黑树转为2-3查找树后，根节点到叶子节点的节点数）</p>
</blockquote>
<p>如何向红黑树中插入元素呢？</p>
<blockquote>
<p>向红黑树中插入元素，与向查找二叉树插入元素的逻辑一致，只是因为加入了红黑节点的定义，所以需要分别讨论像”3节点”和”2节点”插入元素时的情况。<br><code>两者的相同点就是，在对红黑树插入元素时，均将节点当作是红节点！</code></p>
</blockquote>
<p>虽然红色链接是左链接，但在向红黑树添加元素的过程中，也有可能出现两条红色链接连在一起的情况，或者红色链接是右链接，<code>以下就对向“3节点”插入元素的三种情况，做讨论</code>：</p>
<ul>
<li>插入元素小于两个key<br>例如，对“3节点”（6，7），如果插入5，则成为（5，6，7），这时红黑树中的5、6均为红节点，但这不符合2-3查找树的定义，所以红黑树中不可能存在两个红节点连接。<br>对于这种情况，前面提到， 2-3查找树是通过上弹中间元素6来解决的。对于红黑树，对应的操作是对（6，7）这条红链接做<code>右旋</code>操作！<blockquote>
<p>右旋操作，会将左链接变为右链接，子节点为红节点，父节点的颜色与原来左链接的父节点颜色一致。</p>
</blockquote>
</li>
</ul>
<p>这会导致：5节点和7节点均为红节点</p>
<blockquote>
<p><code>如果一个父节点的子节点均为红节点，则将两个红节点置为黑节点，将父节点设为红色（父节点非根节点时）。原因是，6上弹后，将其左右两个节点变成了&quot;2节点&quot;，而父节点自己变成了&quot;3节点&quot;中的一员</code></p>
</blockquote>
<ul>
<li><p>插入元素大于两个key<br>如果新加入节点8比（6，7）都大呢？，看上去，6、7均是红色节点，但是8加入后，向上弹7构成了一个标准的二叉树，所以：</p>
<blockquote>
<p>这时，会产生两个红色子节点，所以将两个子节点均变为黑节点</p>
</blockquote>
</li>
<li><p>插入元素在两个key之间<br>如果新加入的节点是6.5，介于（6，7）之间呢？</p>
<blockquote>
<p>对红色链接（6，6.5）做<code>左旋</code>操作，这样红黑树出现了之前说的第一种情况，然后再按照第一种情况处理即可</p>
</blockquote>
</li>
</ul>
<p><b>可以将上述情况概括为：</b></p>
<blockquote>
<ul>
<li>如果出现两个左红色链接，做右旋（将上面的左链接变为右链接）后，将两个子节点变为黑节点</li>
</ul>
</blockquote>
<ul>
<li>如果出现一左红链接一右红链接（两个红链接<code>不是对应同一个根节点</code>），做左旋（将右链接变为左链接）后同上</li>
<li>如果两条红色链接位于同一个根节点，将两个子节点变为黑节点，父节点变为红节点<br><code>无论是左旋还是右旋，目的都是将弹上去的元素作为根节点！</code></li>
</ul>
<p><BR><code>对于向&quot;2节点&quot;插入元素，比较简单</code>：</p>
<ul>
<li>插入的元素是左子节点，那没毛病，标准的红链接，不用动</li>
<li>插入的元素是右子节点，做<code>左旋</code>操作即可</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法题思路总结</title>
    <url>/2017/03/11/blog_article/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>算法题，无外乎两类：<br>一类考对基本算法实现的掌握，另一类考运用算法解决实际问题。</p>
</blockquote>
<p>第一类：</p>
<blockquote>
<p><code>排序</code>：<br>快排、归并排序、堆排序怎么实现的？<br><code>查找</code>：<br>有序数组的二分查找、二叉查找树怎么实现的、红黑树是什么？<br><code>字符串</code>：<br>KMP会吗？</p>
</blockquote>
<p>鄙人不才，只能想到算法世界里的冰山一角。这些基本算法的实现过程中的思想，需要掌握！最好能用自己的话讲明白。</p>
<p>第二类：<br>运用数据结构解决实际问题。这种题目有两个考察点：</p>
<blockquote>
<p>1、找到一种解决问题的算法<br>2、实现这种算法，需要用到哪些数据结构？如果你是个JAVA程序员，这些数据结构你能灵活使用吗？</p>
</blockquote>
<p>有以上这种感触是在我做了一道扫描线的问题之后。这道题的算法不难，但是找到算法后，运用哪种数据结构呢？自己实现会很耗费时间，所以要做到这两点：</p>
<blockquote>
<p>1、熟练掌握常用数据结构的特点，比如堆是一种优先队列的实现你知道吗？<br>2、熟练掌握编程语言中，数据结构对应的实现是什么？比如你知道JAVA中用PriorityQueue实现了堆吗？</p>
</blockquote>
<p>如果你想更精通算法与数据结构，你还需要做到：<br><code>熟悉编程语言中对数据结构的实现采用了何种算法，性能怎么样</code></p>
<hr>
<p>路漫漫其修远兮~~~，所以接下来进入正题，介绍常用的解题思路</p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><blockquote>
<p>当我们求解一个问题时，如果能最大化利用我们当前获得的信息，得到当前情况下的最优解，那么当我们迭代完所有的已知条件后，最后的结果就是我们想要的。</p>
</blockquote>
<p>题目链接：<br><a href="https://dcbupt.github.io/2017/03/13/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%8A%A0%E6%B2%B9%E7%AB%99/">加油站</a><br><a href="https://dcbupt.github.io/2017/03/13/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">买卖股票的最佳时机II</a><br><a href="https://dcbupt.github.io/2017/03/11/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">买卖股票的最佳时机</a><br><a href="https://dcbupt.github.io/2017/03/11/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/">最大子数组</a><br><a href="https://dcbupt.github.io/2017/03/11/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%85%83%E7%B4%A0/">主元素</a></p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><blockquote>
<p>堆又名“优先队列”，可以加入元素（因为是队列），也可以返回最值（体现优先）<br>当你的解题思路中，需要：将元素加入队列中暂存、将队列中的最值元素取出来，可以考虑使用堆这种数据结构！</p>
</blockquote>
<p>题目链接：<br><a href="https://dcbupt.github.io/2017/03/26/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%AC%ACk%E4%B8%AA%E6%95%B0/">排序矩阵中从小到大第k个数</a><br><a href="https://dcbupt.github.io/2017/03/20/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0/">数据流中位数</a><br><a href="https://dcbupt.github.io/2017/03/19/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">滑动窗口的中位数</a><br><a href="https://dcbupt.github.io/2017/03/16/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93/">大楼轮廓</a><br><a href="https://dcbupt.github.io/2017/03/14/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">合并k个排序链表</a><br><a href="https://dcbupt.github.io/2017/02/28/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%B8%91%E6%95%B0II/">丑数II</a></p>
<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>题目链接：<br><a href="https://dcbupt.github.io/2017/03/27/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E8%B0%83%E6%95%B4%E4%BB%A3%E4%BB%B7/">最小调整代价</a><br><a href="https://dcbupt.github.io/2017/03/27/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98II/">背包问题II</a><br><a href="https://dcbupt.github.io/2017/03/27/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>题目链接：<br><a href="https://dcbupt.github.io/2017/03/26/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/">二叉树的所有路径</a><br><a href="https://dcbupt.github.io/2017/03/26/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">最近公公祖先</a><br><a href="https://dcbupt.github.io/2017/03/19/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/">二叉查找树迭代器</a><br><a href="https://dcbupt.github.io/2017/03/19/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/">删除二叉查找树的节点</a><br><a href="https://dcbupt.github.io/2017/03/02/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/">二叉查找树中搜索区间</a><br><a href="https://dcbupt.github.io/2017/03/31/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/">生成括号</a></p>
<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p><a href="https://dcbupt.github.io/2017/03/25/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%AE%9E%E7%8E%B0Trie/">实现Trie</a><br><a href="https://dcbupt.github.io/2017/03/30/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%BC%82%E6%88%96/">异或</a></p>
<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p><a href="https://dcbupt.github.io/2017/03/20/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/">翻转二叉树</a><br><a href="https://dcbupt.github.io/2017/03/20/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">二叉树的最大深度</a><br><a href="https://dcbupt.github.io/2017/03/14/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">合并k个排序链表</a><br><a href="https://dcbupt.github.io/2017/03/08/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">两个排序数组的中位数</a><br><a href="https://dcbupt.github.io/2017/02/28/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0/">第k大元素</a></p>
<h1 id="数学题"><a href="#数学题" class="headerlink" title="数学题"></a>数学题</h1><p><a href="https://dcbupt.github.io/2017/03/11/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E8%90%BD%E5%8D%95%E7%9A%84%E6%95%B0I%20II%20III/">落单的数 I II III</a><br><a href="https://dcbupt.github.io/2017/02/28/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/A-B%E9%97%AE%E9%A2%98/">A+B问题</a><br><a href="https://dcbupt.github.io/2017/02/28/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%B0%BE%E9%83%A8%E7%9A%84%E9%9B%B6/">尾部的零</a></p>
<h1 id="逻辑题"><a href="#逻辑题" class="headerlink" title="逻辑题"></a>逻辑题</h1><p><a href="https://dcbupt.github.io/2017/03/08/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">翻转字符串</a><br><a href="https://dcbupt.github.io/2017/03/07/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/">链表求和</a><br><a href="https://dcbupt.github.io/2017/03/06/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">两数之和</a><br><a href="https://dcbupt.github.io/2017/03/06/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%B8%A6%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%90%E9%9B%86/">带重复元素的子集</a><br><a href="https://dcbupt.github.io/2017/03/06/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86/">子集</a><br><a href="https://dcbupt.github.io/2017/03/06/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%B8%A6%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%88%97/">带重复元素的排列</a><br><a href="https://dcbupt.github.io/2017/03/04/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97/">全排列</a><br><a href="https://dcbupt.github.io/2017/03/02/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%B8%A6%E6%9C%80%E5%B0%8F%E5%80%BC%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/">带最小值操作的栈</a><br><a href="https://dcbupt.github.io/2017/03/01/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/">旋转字符串</a><br><a href="https://dcbupt.github.io/2017/03/01/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">二叉树的序列化和反序列化</a><br><a href="https://dcbupt.github.io/2017/02/28/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">合并排序数组</a><br><a href="https://dcbupt.github.io/2017/02/28/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97/">统计数字</a><br><a href="https://dcbupt.github.io/2017/04/07/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">按层打印二叉树</a><br><a href="https://dcbupt.github.io/2017/03/31/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%AC%A1%E6%95%B0%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%80%BC/">次数的期望值</a></p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><a href="https://dcbupt.github.io/2017/03/02/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/">字符串查找</a></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><a href="https://dcbupt.github.io/2017/03/31/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E6%89%93%E5%8D%B0[]%E5%AF%B9/">打印[]对</a><br><a href="https://dcbupt.github.io/2017/03/19/FarBox/Forwarddc/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/">二叉查找树迭代器</a></p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p><a href="">单词变换</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>递归与迭代的区别</title>
    <url>/2017/03/03/blog_article/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>写算法题解法的博客时，时常想用递归或者迭代来描述解法，但又觉得这两个好像是一个意思。<br>那是因为我混淆了这两个概念，其有联系，也有区别。</p>
</blockquote>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul>
<li>递归就是自己调用自己，但每次调用都会缩小解决问题的范围（体现在参数的变化）</li>
<li>递归必须有递归出口，及递归的终止条件。从终止条件处，再一步步回溯到最外层的调用，输出结果</li>
<li>递归的过程分两部分：从外层函数调用自己，这个过程是由外到内。碰到终止条件，由内层函数一步步return，这个过程由外到内。</li>
</ul>
<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><ul>
<li>递归的做法里一定包含迭代，但不能反过来说<ul>
<li>怎么理解：正如前面将递归分为两个过程，因为<code>迭代不会自己调自己</code>，所以不存在由外到内的过程，只包含由内到外的过程。即，迭代会不停调另一个函数，直到求出结果。<blockquote>
<p>所以说，递归有迭代的思想，但迭代没有递归的过程。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="递归与迭代的代码示例"><a href="#递归与迭代的代码示例" class="headerlink" title="递归与迭代的代码示例"></a>递归与迭代的代码示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这是递归  </span><br><span class="line">int funcA(int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    if(n &gt; 1)  </span><br><span class="line">       return n+funcA(n-1);  </span><br><span class="line">    else   </span><br><span class="line">       return 1;  </span><br><span class="line">&#125;  </span><br><span class="line">//这是迭代  </span><br><span class="line">int funcB(int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i,s=0;  </span><br><span class="line">    for(i=1;i&lt;n;i++)  </span><br><span class="line">       s+=i;  </span><br><span class="line">    return s;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>递归没什么好说的，自己调自己，碰到终止条件，在迭代出结果</li>
<li>迭代的代码其实可以理解为funcB一直在循环里<code>调另一个函数&#123;s+=i&#125;</code>，并通过for循环控制迭代次数。类比递归，区别是递归里的迭代，调的是自己，由最外层调用的参数控制迭代次数</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习AQS</title>
    <url>/2020/04/24/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0AQS/</url>
    <content><![CDATA[<h1 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h1><p>AbstractQueuedSynchronizer(AQS)是java并发编程基础，concurrent包下面的许多同步组件底层都是基于AQS，例如CountDownLatch、ReentrantLock、ReadWriteLock、Semaphare…</p>
<p>AQS通过一个FIFO队列(双向链表数据结构)，管理被阻塞的线程，同时具备阻塞park和唤醒unpark线程的能力</p>
<ul>
<li>park和unpark追进去发现是native方法，应该是通过底层操作系统接口来调度线程</li>
</ul>
<p>AQS定义一个<code>volatile int state</code>，代表共享资源，同步组件实现AQS提供的模板方法，使用这个变量来实现多线程对共享资源（锁）的竞争，达到线程间同步的功能</p>
<ul>
<li>例如可重入锁用state表示同一线程对锁的重入次数，CDL用state表示签到阈值，达到阈值后唤醒所有等待CDL的线程</li>
</ul>
<p>AQS与同步组件的关系图<br><img src="/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS.png"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h2><p>acquire是AQS提供的<code>独占模式获取锁</code>的入口</p>
<ul>
<li>首先执行tryAcquire方法（由具体的子类实现，判断线程是否能获取锁）。如果失败，表示该线程获取独占锁失败，如果成功，表示当前线程拿到了独占锁，可以继续执行加锁代码块。</li>
<li>获取独占锁失败后，调用addWaiter方法，将当前线程加入到等待队列尾部<ul>
<li>这里用到了<code>自旋CAS更新tail来保证并发时等待队列的线程安全，tail用volatile修饰保证可见性</code></li>
</ul>
</li>
<li>将队列中代表当前线程的node节点传递给acquireQueued方法，尝试再次获取独占锁。具体逻辑为：<ul>
<li>如果node节点的前驱节点是头结点，就再次尝试获取到锁（tryAcquire）</li>
<li>如果获取锁成功，将该节点设置为头结点（等待线程一定是头结点的后继节点，头结点表示获得了锁的线程），方法return，当前线程执行加锁代码块。<ul>
<li>如果线程在阻塞过程中被中断，只是设置线程中断标，在线程拿到锁继续执行时，让程序自己决定如何处理中断</li>
<li>注意，reentrantLock（AQS的同步组件）的lock方法不会在阻塞过程中抛出中断异常，所以一旦死锁无法通过中断来恢复线程。不过，tryLock(long timeout, TimeUnit unit)和lockInterruptibly方法都能使线程在阻塞过程中被中断时抛出中断异常</li>
</ul>
</li>
<li>如果获取失败，将当前节点的线程挂起</li>
<li><code>自旋这一过程，保证一旦当前线程恢复执行时可以立即尝试获取锁</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">     if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123; //for循环，直到队列构造成功</span><br><span class="line">            Node t = tail;</span><br><span class="line">            if (t == null) &#123; //第一次循环：队列为空，就构造一个节点设置为头结点</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;//第二次循环执行到这里 首先将node节点的前驱节点指向尾节点，然后CAS设置node节点为尾节点</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 自旋这一过程，保证一旦当前线程恢复执行时可以立即尝试获取锁</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // 如果node节点的前驱节点是头结点，就再次尝试获取到锁</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果获取失败，将当前节点的线程挂起</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                    interrupted |= parkAndCheckInterrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">            if (interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">            throw t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占模式获取锁小结：</p>
<ul>
<li>AQS的阻塞队列实际是双向链表实现的</li>
<li>tryAcquire直接拿到锁的线程，不会加入阻塞队列。否则，加入阻塞队列，线程阻塞</li>
<li>当持有锁的线程调用tryRelease释放锁成功后，会唤醒阻塞队列Head节点的后继节点线程，让它再次尝试tryAcquire获取锁</li>
<li>获取锁成功，则它成为Head节点，所以可以认为阻塞队列的Head节点代表的就是持有锁的线程</li>
</ul>
<h2 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h2><p>release是AQS提供的<code>独占模式释放锁</code>的入口。</p>
<ul>
<li>调用子类的tryRelease方法尝试释放独占锁<ul>
<li>如果失败，直接返回</li>
<li>如果成功。唤醒(unpark)等待队列头节点的后继节点对应的线程</li>
<li>唤醒后的线程会进入acquireQueued的自旋里尝试获取独占锁，参考上文<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>独占模式释放锁小结：</p>
<ul>
<li>释放锁时，会唤醒AQS阻塞队列上的后继节点线程，让它tryAcquire尝试获取独占锁</li>
</ul>
<h2 id="acquireShared方法"><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h2><p>acquireShared是AQS提供的<code>共享模式获取锁</code>的入口</p>
<ul>
<li>尝试获取共享锁<ul>
<li>如果成功，获取到共享锁，执行加锁代码块</li>
<li>如果失败（小于0）<ul>
<li>构建一个共享节点添加到等待队列。</li>
<li>当前节点是头结点的后继节点时，再次尝试获取共享锁。<ul>
<li>成功，在setHeadAndPropagate方法里做两件事。1、当前节点设为头节点。2、<code>唤醒当前节点的后继节点</code>。最后方法返回，线程执行加锁代码块。第2点是独占锁模式没有的，也是和独占锁模式的最大区别。因为独占锁任何时候只有一个线程获得锁，所以唤醒后继节点只有在当前线程释放锁时进行。但共享锁同时可以有多个线程获取锁，所以在获得共享锁后就可以唤醒后继节点。详细分析参考：<a href="https://segmentfault.com/a/1190000016447307">https://segmentfault.com/a/1190000016447307</a></li>
<li>如果获取失败，将当前节点的线程挂起。</li>
<li><code>自旋这一过程，保证一旦当前线程恢复执行时可以立即尝试获取锁</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">                    interrupted |= parkAndCheckInterrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">            throw t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享模式获取锁小结：</p>
<ul>
<li>和独占模式最大的区别就是，阻塞队列里的线程获取锁成功后，继续唤醒后继节点线程，因为共享模式锁是可以被多个线程共享的。独占模式没有这一步，只会在释放锁时唤醒后继节点线程，保证锁任何时候只被一个线程独占</li>
</ul>
<h2 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h2><p>releaseShared是AQS提供的<code>共享模式释放锁</code>的入口，和释放独占锁的逻辑一致，也是唤醒阻塞队列的后继节点线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">        if (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，AQS对独占锁模式和共享锁模式的实现方式，最大的区别就是<code>独占锁模式只有在线程释放锁后才唤醒后继线程，共享锁模式在线程拿到共享锁和释放共享锁时，都会唤醒后继线程，这么做的效果是唤醒线程的操作会递归向下传播，可以同时有多个线程被唤醒，拿到共享锁执行加锁代码块。独占锁只在锁释放时唤醒下一个阻塞线程，保证任何时候锁只被一个线程独占</code></p>
<h1 id="AQS的应用"><a href="#AQS的应用" class="headerlink" title="AQS的应用"></a>AQS的应用</h1><p>一些同步组件内部通过赋予AQS的state属性不同含义，实现了各自的AQS，达到线程间同步的功能</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是<code>可重入的独占锁</code>，又细分为<code>公平锁和非公平锁</code>，默认非公平锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock中的state表示锁被重入次数，每次重入成功+1</p>
<h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><ul>
<li>如果state&#x3D;0，说明独占锁未被占据<ul>
<li>对于公平锁，判断阻塞队列头结点是否存在后继节点且代表的线程不是当前线程，即是否有更早等待锁的其他线程<ul>
<li>如果没有，则state通过CAS置1，然后缓存当前线程作为独占线程，尝试获取独占锁成功</li>
<li>如果有，获取独占锁失败，已经有其他线程更早地等待锁，因此只能走AQS流程入队阻塞，乖乖排队等待被唤醒。这就是公平性的实现，因为AQS是FIFO队列，先到先得</li>
</ul>
</li>
<li>对于非公平锁，直接CAS尝试改state状态到1，成功则获取到锁，失败说明被其他线程抢先CAS State成功，锁被抢占，只能走AQS流程入队阻塞，乖乖排队等待被唤醒。这就是非公平性的实现</li>
</ul>
</li>
<li>如果state不为0，说明独占锁已被其他线程占据，判断是否就是当前线程<ul>
<li>如果是，则更新state来标识已重入次数，成功则获取到可重入锁。这就是可重入性的实现，通过判断当前持有锁的线程是否就是自己来决定是否尝试获取锁成功</li>
<li>如果不是，则无法获取锁，走AQS流程入队阻塞，等待被唤醒</li>
</ul>
</li>
</ul>
<p><code>因为state用volatile保证可见性，所以更新state无需加锁</code></p>
<p>公平锁tryAcquire</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁tryAcquire</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><ul>
<li>因为可重入性，所以先state自减<ul>
<li>当state&#x3D;0时，表示线程已经把可重入锁全部释放，则认为可以将独占锁释放，让下一个等待线程（阻塞队列头结点的后继节点）尝试获取锁</li>
<li>state !&#x3D; 0，说明还在重入中，不能释放锁<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c = getState() - releases;</span><br><span class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                free = true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>公平锁通过FIFO阻塞队列来实现，前面有阻塞的线程节点则只能乖乖去队尾排队。非公平锁尝试获取锁时，无需关心队列里有没有阻塞的线程节点，直接通过CAS修改state来尝试获取锁，成功就能直接抢到锁</li>
<li>通过判断持有锁的线程是否为当前线程来实现可重入性，每次重入成功则state+1，通过state表示重入次数。释放锁时state-1，减到0则可以唤醒后继阻塞的线程</li>
</ul>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是基于AQS共享锁的同步组件，功能类似签到器，state表示签到阈值，签到数达到阈值后，唤醒所有等待CDL的线程</p>
<p>CDL构造函数指定签到阈值，保存到AQS的state</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h3><p>线程执行完逻辑后，调用countDown方法签到，state减1，然后判断state是否减到0，如果是说明全部签到完成，释放共享锁，唤醒所有阻塞队列上的线程（共享锁的机制，上面介绍过，唤醒的线程会递归唤醒后继节点的线程）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层调用AQS的释放共享锁方法，CDL对tryReleaseShared的实现，其实就是每次将state-1，如果state减到0（调用次数达到计数阈值），则认为可以释放共享锁，唤醒所有等待CDL共享锁的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            // Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">                if (c == 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc = c - 1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h3><p>线程调用await方法，将等待在签到器上，直到其他线程全部签到完成才能获取到CDL锁继续执行任务。CDL使用共享锁的原因是等待CDL锁的线程可能有多个，当CDL签到完成后，希望唤醒所有的线程，即所有线程都获取到CDL锁</p>
<p>tryAcquireShared尝试获取共享锁的条件是state为0，即全部签到完成，如果不为0，说明还没全部签到，当前线程走AQS流程加入阻塞队列等待CDL锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习CQRS和EventSourcing</title>
    <url>/2020/05/21/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0CQRS%E5%92%8CEventSourcing/</url>
    <content><![CDATA[<h1 id="Event-Sourcing"><a href="#Event-Sourcing" class="headerlink" title="Event Sourcing"></a>Event Sourcing</h1><p>概括来说，Event Sourcing有别于CRUD直接操作数据源（DDD中称为聚合根或实例），只记录数据的状态变化(state event)，通过replay这些event可以得到最终的数据状态视图。它的优点是Complete Rebuild（重新生成状态视图）, Temporal Query（查询历史视图，类似Git查看某个版本数据视图）, Event Replay（新模块可重放event满足自身需求）。在event积累太多的情况下，从头开始replay的耗时将难以接受，可以在某个event发生的时候，将这个聚合对象的最新数据状态，写到一个表中，这个表可以叫做物化视图。在查询的时候，可以通过该物化视图去查询，而不用从头开始replay</p>
<p>它的一些优点：</p>
<ul>
<li>方便进行溯源与历史重现</li>
<li>性能<ul>
<li>在Event Sourcing模式下，事件数据的保存是一个一直新增的写表操作，没有更新。这在很多情况下都能够提供一个非常好的写的性能，让系统的接收事件的吞吐量可以很高。</li>
</ul>
</li>
<li>方便数据分析<ul>
<li>用了Event Sourcing模式，我们的数据就是事件，我们只需要在的事件监听方法里增加数据分析能力；或者将event直接发送到数据分析系统</li>
</ul>
</li>
</ul>
<h1 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h1><p>CQRS，是 Command Query Responsibility Segregation的缩写，也就是通常所说的读写隔离。CQRS的想法很朴素，在CRUD模式read&#x2F;write都是操作同一个数据源，CQRS把write的数据源和read的数据源分开。通过Command模块写到write库，write库的数据异步同步到read库，以供Query模块查询数据。CQRS的优点是数据库分离成了read库和write库，这样他们就可以各自scale了，不存在相互拖累的情况。分离之后，我们可以自行选择更适合的方案实现read库和write库，比如Apache Cassandra实现write库，Elasticsearch实现读库。</p>
<h1 id="Event-Sourcing-CQRS"><a href="#Event-Sourcing-CQRS" class="headerlink" title="Event Sourcing + CQRS"></a>Event Sourcing + CQRS</h1><p>Event Sourcing模式中，为了性能考虑，数据写入时只记录数据的状态变化，由另一个事件监听器异步处理，将聚合根的数据状态用物化视图的形式保存，可以用于数据的查询操作。也就是说，Event Sourcing自身就要求数据的更新与查询的流程隔离开来，通过事件来更新聚合根的数据状态，同时由另一个监听器处理相同的事件，来更新物化视图的数据。所以，Event Sourcing与CQRS有着天然的联系</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习DDD基础篇</title>
    <url>/2020/07/31/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0DDD%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>软件开发当前的问题现状：</p>
<ul>
<li>交付速度不够快</li>
<li>测试覆盖度不够，上线后容易出故障，质量难以保证</li>
</ul>
<p>原因：<br>随着软件的持续演进，系统复杂度成倍增加，造成技术债务越来越多，阻塞了开发效率也降低了交付质量</p>
<p>重构能解决吗？<br>重构有边界，边界内的重构无法影响到边界外的代码设计，且重构后的代码也容易被逐渐侵蚀。所以很难。</p>
<p>微服务、中台化能解决吗？<br>在不良的业务分析、架构设计基础上，推动中台化或微服务，往往会使矛盾凸显</p>
<p>云原生时代，软件性能、可靠性等已被底层接管。作为业务研发，实现软件高质量、快速交付的关键因素应该是：</p>
<ul>
<li>需求分析能力<ul>
<li>该阶段需要做到：业务引领的领域建模</li>
</ul>
</li>
<li>架构设计和实现能力<ul>
<li>该阶段需要做到：设计领域驱动的微服务架构 &amp; 契约导向的软件实现</li>
</ul>
</li>
</ul>
<h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><h2 id="领域模型的重要性"><a href="#领域模型的重要性" class="headerlink" title="领域模型的重要性"></a>领域模型的重要性</h2><p>领域模型是软件开发的核心载体<br>好的领域模型沉淀下来的是领域资产，能快速满足后续业务发展。领域资产越来越多，技术债务就会越来越少<br>领域模型反应的是对行业的<code>认知</code>，是一家企业的根本能力和竞争力。</p>
<h2 id="领域模型的基本概念"><a href="#领域模型的基本概念" class="headerlink" title="领域模型的基本概念"></a>领域模型的基本概念</h2><p>领域模型是概念模型，描述的是现实世界的实体和他们之间的关系，与软件实现无关，存在于问题空间，在需求分析阶段产生领域模型。<br>领域模型建立后，会贯穿软件开发始终，直接指导架构设计和实现</p>
<h2 id="领域模型的表示"><a href="#领域模型的表示" class="headerlink" title="领域模型的表示"></a>领域模型的表示</h2><p>类图是一种较好的领域模型表示方法。<br>每个类代表一种概念。<br>普通箭头表示一种可见关系。<br>空心菱形箭头表示一种包含关系，但生命周期不同。<br>实心菱形箭头表示一种包含关系，但生命周期相同。<br>三角箭头表示一种抽象与继承关系。</p>
<h2 id="领域模型的作用"><a href="#领域模型的作用" class="headerlink" title="领域模型的作用"></a>领域模型的作用</h2><p>好的领域模型应该具备以下三个作用。</p>
<ul>
<li>建立共识<ul>
<li>建立与业务人员对于需求、产品的共识。避免需求失焦而产生返工，甚至做错。</li>
<li>建立共识需要拉齐业务与开发，在协作空间（白板）里产生共识。</li>
<li>建立共识的目的就是统一语言。</li>
<li>建立共识衡量的方法：<code>任何在需求中出现的概念，都必须出现在领域模型中</code></li>
</ul>
</li>
<li>产生洞察<ul>
<li>产生洞察要相信业务人员的直觉</li>
<li>产生洞察要有分解和抽象的能力</li>
<li>产生洞察的领域模型才是企业真正的领域资产</li>
</ul>
</li>
<li>持续演进<ul>
<li>没有绝对正确的领域模型。随着认知的深入，领域模型需要持续演进</li>
<li>持续演进对领域模型的修改，也要相应修改代码和架构</li>
</ul>
</li>
</ul>
<h2 id="从需求分析到领域建模"><a href="#从需求分析到领域建模" class="headerlink" title="从需求分析到领域建模"></a>从需求分析到领域建模</h2><p>任何业务需求都可以拆分为三个组成部分，逐层展开分别是目标、操作流程、规则。<br>需求分析有很多方法论。</p>
<ul>
<li>用例分析：结构化的分析繁杂的业务场景。用例组成元素有执行者、交互、边界、前置后置条件、例外等。</li>
<li>事件风暴：事件+风暴。以领域事件（业务视角的重要事件）为主体构建业务场景的流程，用头脑风暴探索和发现可能的异常情况而衍生出的其他场景。</li>
</ul>
<p>事件风暴是一种很适合用来分析需求的方法论。<br>事件风暴中，需要我们先划分业务场景，然后针对一次完整的业务场景去定义其中产生的所有领域事件。<br>领域事件是由执行者执行了一些命令而产生的。因此一个领域事件必然会携带执行者和命令。</p>
<p>事件风暴的过程中，领域模型同步产出。<br>验证领域模型的方法：</p>
<ul>
<li>用例场景中的任何实体都应该出现在领域模型中</li>
<li>任何领域模型都应该有对应的用例场景</li>
</ul>
<h1 id="从领域模型到代码实现"><a href="#从领域模型到代码实现" class="headerlink" title="从领域模型到代码实现"></a>从领域模型到代码实现</h1><p>好的代码设计应该具备以下三点：</p>
<ul>
<li>易于理解</li>
<li>易于演进</li>
<li>低开发成本</li>
</ul>
<h2 id="实现域的核心概念"><a href="#实现域的核心概念" class="headerlink" title="实现域的核心概念"></a>实现域的核心概念</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>领域模型构建之后，首先要找出其中最重要的概念模型。一般来说，重要的概念模型有两个特定：</p>
<ul>
<li>与其他模型建立的关系更多</li>
<li>需要使用唯一标识符进行跟踪</li>
<li>随着业务进展，概念模型的状态和属性也会改变</li>
</ul>
<p>对于这种最重要的概念模型，在解空间（实现域）我们称它为<code>实体</code>，用唯一 id 来标识。</p>
<h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><p>领域模型中那些用来描述实体模型的概念，称为值对象。<br>值对象用来描述实体的特征，我们只关心值对象的属性，不关心它有没有唯一标识符。值对象的值相同，就认为相同，值不同，就认为不同。<br>引入值对象的原因是，在解空间需要将其和实体区分开，减少系统的复杂度</p>
<p>有时可以使用 id 作为一种特殊的值对象，代替实体的全部信息，例如用户 id。需要的时候再通过 id 查出实体信息</p>
<h3 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h3><p>领域模型中不包含任何数据的无状态的概念模型，例如一些业务处理过程和业务策略。这类概念模型称为领域服务。</p>
<h3 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h3><p>通过事件风暴进行需求分析，可以很容易得到领域事件。<br>领域事件表达了<code>系统中发生了什么</code>，它们源自于业务活动的结果<br>引入领域事件可以解耦业务间的复杂关系<br>领域事件里需要记录事件上下文，例如一些实体 id 等</p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>引入聚合有两个好处</p>
<ul>
<li>保证业务逻辑的完整性，减少出错的概率</li>
<li>明确划分业务边界</li>
</ul>
<p>聚合的概念：</p>
<ul>
<li>将实体对象和值对象划分为聚合，形成聚合根，并围绕聚合根定义边界</li>
<li>每个聚合根需要用实体来描述<ul>
<li>聚合根往往就是领域模型里的实体，围绕实体划分边界，保障对实体操作的业务完整性</li>
</ul>
</li>
<li>聚合根使用充血模式，执行边界内的业务行为，保障边界内的业务逻辑完整性</li>
<li>外部只能通过持有对聚合根的引用来执行聚合根边界内的业务行为，不能越过聚合根，直接持有聚合根内部的属性</li>
</ul>
<h3 id="划分聚合的原则"><a href="#划分聚合的原则" class="headerlink" title="划分聚合的原则"></a>划分聚合的原则</h3><p>生命周期一致性原则：</p>
<ul>
<li>聚合边界内的对象，和聚合根之间存在人身依附关系。即，聚合根消失，聚合根内的元素应该同时消失</li>
<li>如果聚合根需要依赖其他的实体对象，引用实体 id 作为值对象，不要直接依赖实体对象，因为实体对象间的生命周期是不同的<ul>
<li>聚合根只持有其他聚合根（实体）的 id，这样聚合根只能在充血模式下操作和自己生命周期一致的值对象保证业务完整性，无法操作其他聚合根。保证了业务边界清晰，也符合高内聚低耦合的设计原则</li>
</ul>
</li>
</ul>
<p>小聚合原则：</p>
<ul>
<li>在不破坏业务逻辑完整性的基础上，小聚合带来更大的灵活性</li>
<li>小聚合的聚合根可能并不是实体的概念，但也包含了一套完整的业务逻辑。将小聚合根作为值对象提供给更大边界的实体，相比于直接在实体里保证小聚合根内部的业务逻辑完整性更加灵活</li>
</ul>
<h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><p>使用工厂模式来构建聚合根，保障聚合根构造的业务完整性。也可以使用 Builder 模式</p>
<h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p>资源库是聚合根的仓储机制，外界只能通过资源库完成对聚合根的访问，也只有聚合根需要提供资源库访问方式。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>使用聚合根名称作为包名。包下是围绕这个聚合定义的所有 JAVA 类，例如一些描述值对象的类</p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>基于领域驱动的软件开发，系统架构一般由上到下分为这几层：接口层、应用层、领域层、基础设施层。<br>接口层：</p>
<ul>
<li>基于特性通信协议封装对外提供的接口服务。通信协议例如 Dubbo\HSF\Restful<br>应用层：</li>
<li>实现满足应用场景的外层服务，这部分的业务逻辑是经常变动的<br>领域层：</li>
<li>基于领域模型得到的实例、值对象、领域服务、领域事件集合。负责处理稳定的业务相关逻辑，应用层的接口需要依赖领域层的能力<br>基础设施层：</li>
<li>数据库、消息、缓存等中间件</li>
<li>通过防腐层模式包装的外部依赖服务</li>
</ul>
<p>建立高效的软件开发，应该以领域层为核心进行开发。领域层和其他层之间通过接口建立联系。因为领域层是最稳定也是最核心的业务抽象和实现。</p>
<h2 id="意图导向编程"><a href="#意图导向编程" class="headerlink" title="意图导向编程"></a>意图导向编程</h2><p>在开发阶段，编程的顺序应该是由外而内，即意图导向的编程。理由是：</p>
<ul>
<li>外层功能比底层实现方案具有更高的确定性</li>
<li>延迟决策到最后时刻，关键信息经常会自然显现</li>
<li>由外而内编程允许暂时忽略不重要的细节</li>
</ul>
<p>结合上面介绍的分层架构，我们在编码阶段应该先从应用层入口，围绕应用场景定义接口职责。然后再将职责分配到领域层相关的实体、领域服务、领域事件等。</p>
<h2 id="测试先行"><a href="#测试先行" class="headerlink" title="测试先行"></a>测试先行</h2><p>后置的自动化单元测试的弊端：</p>
<ul>
<li>上下文丢失<ul>
<li>编码后再写测试，很难回忆起编码时考虑到的所有 case，丢失上下文也就很难写出完备的测试用例</li>
</ul>
</li>
<li>情绪和动机<ul>
<li>编码完成后再补测试，情绪和动机上都会受影响</li>
</ul>
</li>
</ul>
<p>自动化测试 Case 应该是表达业务意图，在定义好满足业务需求的应用层接口后，在实现内部逻辑前就应该补上测试 Case，来检验接口的业务功能是否满足。</p>
<p>测试用例的本质不是对被测代码的白盒化测试，而是对接口职责的测试。这样能保证在重构后，测试用例依旧可用。<br>测试用例其实描述的是软件开发中的契约（接口的入参格式、出参格式、出参值）。测试先行，就是为了在实现具体的功能细节（与接口职责无关）前，定义契约。</p>
<p>因此，测试先行的收益包括：</p>
<ul>
<li>聚焦于接口职责，从测试用例就能读懂接口意图</li>
<li>在接口的内部功能实现前，就可以产出接口测试用例，避免丢失上下文</li>
<li>支持重构</li>
<li>持续建立对接口的信心</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="子域和限界上下文"><a href="#子域和限界上下文" class="headerlink" title="子域和限界上下文"></a>子域和限界上下文</h2><p>复杂的东西分而治之，各个击破，独立进化，易于复用。</p>
<p>领域划分需要围绕业务进行，而非技术实现！</p>
<p>核心域：提炼最有价值和最专业的概念到核心域，把核心变小，发现深层模型，打造核心竞争力<br>核心域需要能提炼出一句话来描述其职能，要足够内聚。</p>
<p>通用子域：简单理解为非核心域</p>
<p>拆分领域的方法论</p>
<ul>
<li>在业务流程中识别领域</li>
<li>在领域模型中识别领域</li>
</ul>
<p>限界上下文<br>比方：细胞膜隔离了细胞内的物质和细胞外的物质<br>限界上下文的边界和子域定义保持一致。在编码阶段维护住限界上下文是很有挑战的。最好的做法是用领域模型来守护限界上下文</p>
<p>如何识别限界上下文被破坏了？<br>一个子域的实现代码里，引入了其他域的领域服务。或者，一个领域模型里，引入了其他领域的概念模型</p>
<p>微服务很适合于保障限界上下文。即，通过进程来隔离，而非通过包来隔离（很容易被破坏）</p>
<p>划分领域需要保守一些，后续持续演进中可以再拆开细化。如果一开始就拆的太细，后续合并会很痛苦。</p>
<h1 id="领域资产"><a href="#领域资产" class="headerlink" title="领域资产"></a>领域资产</h1><p>好的领域资产一定是可以<code>被集成、被扩展、被信赖</code>的<br>如何才能做出好的领域资产呢？必须满足以下三点：</p>
<ul>
<li>合理划分子域</li>
<li>良好的契约描述资产能力和约束</li>
<li>持续演进</li>
</ul>
<h2 id="处理遗留资产"><a href="#处理遗留资产" class="headerlink" title="处理遗留资产"></a>处理遗留资产</h2><p>对于遗留资产（前人写的并不符合领域驱动设计的代码），首先还是要把它当做资产看待，因为它还提供正常的功能。对待遗留资产，有这些方法：</p>
<ul>
<li>防腐层<ul>
<li>不直接调用遗留资产的方法，依然调用新的领域模型中定义的方法，在方法内部调用遗留资产的方法，增加防腐层（适配器）来适配遗留资产</li>
</ul>
</li>
<li>在遗留资产上包装并暴露 api<ul>
<li>从遗留资产出发，进行领域分析，提炼出领域方法，内部适配遗留资产的方法，对外只暴露领域方法，并做好自动化测试</li>
<li>在这个基础上逐步重写遗留资产的方法，称为<code>绞杀者模式</code></li>
</ul>
</li>
</ul>
<h3 id="防腐层的设计"><a href="#防腐层的设计" class="headerlink" title="防腐层的设计"></a>防腐层的设计</h3><p>防腐层主要作用：</p>
<ul>
<li>在新的领域模型里兼容老的历史代码（遗留资产）</li>
<li>封装其他领域提供的接口</li>
</ul>
<p>1、使用门面模式，按新的领域模型需要，定义门面接口，实现上可能会调用多个遗留代码的接口来实现逻辑。</p>
<p>2、使用适配器模式，，提供适配器类，聚合门面类。它的作用是，对于调用门面类接口时，需要传入的一些遗留代码定义的参数，做一层新老模型的转义（适配）。新的领域模型里直接使用适配器类</p>
<ul>
<li>其实也可以直接把新老模型的转义适配放到门面类里，这样就只用一层门面类就能达到防腐层的作用</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习DDD实践篇</title>
    <url>/2023/03/31/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0DDD%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
    <content><![CDATA[<h1 id="事务脚本"><a href="#事务脚本" class="headerlink" title="事务脚本"></a>事务脚本</h1><p>将所有业务功能堆砌在一个大接口里，这样的代码也称为<code>事务脚本</code>，且存在以下问题：</p>
<p>× 可维护性（依赖变化时要改多少代码）</p>
<ul>
<li>DB 数据结构经常变</li>
<li>依赖框架、中间件升级或替换<ul>
<li>不满足依赖倒置，业务层依赖的还是具体实现</li>
</ul>
</li>
<li>三方服务不确定性，例如要接口签名变更、替换或直接断流了<ul>
<li>不满足依赖倒置，业务层依赖的还是具体实现</li>
</ul>
</li>
</ul>
<p>× 可扩展性（新需求要改多少代码）</p>
<ul>
<li>数据格式不兼容：接新的服务，新的数据结构，导致老代码逻辑不能复用</li>
<li>大量分支逻辑：大量的 if-else 语句带来多分支逻辑，造成分析代码非常困难，容易错过边界情况造成 bug</li>
</ul>
<p>× 可测性（新需求要增加的测试用例数乘以跑每个用例的时间）</p>
<ul>
<li>测试环境搭建困难（数据库、中间件、三方依赖）</li>
<li>运行时间长（启动 Spring、IO 密集型调用）</li>
<li>逻辑高度耦合，导致用例数目呈现指数级增长</li>
</ul>
<h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h1><blockquote>
<p>DDD 是一套服务于应用内部的架构设计思想，旨在为领域划分的微服务应用提供最大化的代码可读性、可维护性、可扩展性、可测试性</p>
</blockquote>
<p>可读性 &#x3D; 接口参数含义明确、接口实现只专注于最核心的业务逻辑编排<br>可维护性 &#x3D; 当依赖变化时，有多少代码需要随之改变<br>可扩展性 &#x3D; 做新需求或改逻辑时，需要新增&#x2F;修改多少代码<br>可测试性 &#x3D; 运行每个测试用例所花费的时间 * 每个需求所需要增加的测试用例数量</p>
<h1 id="DDD-的指导思想"><a href="#DDD-的指导思想" class="headerlink" title="DDD 的指导思想"></a>DDD 的指导思想</h1><h2 id="贫血模式-VS-充血模式"><a href="#贫血模式-VS-充血模式" class="headerlink" title="贫血模式 VS 充血模式"></a>贫血模式 VS 充血模式</h2><p>贫血模式的缺点：</p>
<ul>
<li>由于接口直接访问和修改对象的任意业务属性，无法保证对象的数据一致性，容易出 bug</li>
<li>大量重复的对象属性校验、计算逻辑，代码可复用性低</li>
</ul>
<p>为什么那么多贫血模式？</p>
<ul>
<li>面向数据模型编程的思维，所有的业务逻辑都只是对数据库的 CRUD</li>
<li>门槛低，写业务类似写脚本，瀑布式代码将各种逻辑铺满即可</li>
</ul>
<p>充血模式是怎么做的？</p>
<ul>
<li>对象的业务属性不能随意访问和修改，只能通过对象提供的行为方法来操作，每个行为方法都代表了一个业务领域知识，是一系列属性计算逻辑的聚合</li>
</ul>
<h2 id="数据模型-VS-领域模型"><a href="#数据模型-VS-领域模型" class="headerlink" title="数据模型 VS 领域模型"></a>数据模型 VS 领域模型</h2><p>数据模型指直接和数据库表结构映射的持久化 DO 对象，它的作用域只能在数据层</p>
<p>领域模型是能准确描述业务域核心概念的数据结构，在 DDD 中称为 Entity 实体，是业务逻辑的集中式体现</p>
<p>因此在业务逻辑层，我们应该避免直接使用贫血模式面向数据模型编程，而应该使用充血模式面向领域模型编程，这其实就是 DDD 领域驱动思想的最本质体现</p>
<p>面向领域模型编程的另一个好处是业务逻辑与数据存储的解耦，即使底层更换了数据库，表结构发生很大改变，也不会被业务逻辑层感知，当然中间还要有一层转化适配，这是防腐层和基础设施层做的事情</p>
<h1 id="DDD-的实践"><a href="#DDD-的实践" class="headerlink" title="DDD 的实践"></a>DDD 的实践</h1><h2 id="无处不在的-DP"><a href="#无处不在的-DP" class="headerlink" title="无处不在的 DP"></a>无处不在的 DP</h2><blockquote>
<p>DP 主要提升代码可读性、可测试性</p>
</blockquote>
<p>什么是 DP（DomainPrimitive，原始领域对象）</p>
<ul>
<li>是特定领域中，概念明确、职能清晰、无状态的“值对象”，是领域的最小组成部分<ul>
<li>所谓无状态，指属性一旦赋值不会再发生变化，可以认为 DP 中的数据都是静态的</li>
</ul>
</li>
</ul>
<p>使用 DP 能解决什么问题？</p>
<ul>
<li>避免接口中定义基本类型的出入参导致语义不清晰，使用 DP 类型取而代之<ul>
<li>应用层的业务接口、领域层接口和防腐层接口都可以使用 DP 作为参数</li>
</ul>
</li>
<li>避免业务接口的实现里耦合参数校验逻辑，转而在 DP 对象构造时完成参数校验</li>
<li>避免写出“胶水代码”，而是将其改造为 DP 对象内部的一个属性计算逻辑，通过 get 方法对外暴露<ul>
<li>业务方法中调用外部服务时，需要从参数中提取一部分属性，实现参数提取的代码称为胶水代码</li>
<li>在复杂度很高的业务接口中，会充斥大量胶水代码，影响代码可读性、增加接口单测复杂度</li>
</ul>
</li>
</ul>
<blockquote>
<p>其实这些问题的本质原因是我们习惯将业务接口实现为“事务脚本”，导致业务接口做了太多“非强相关”的事情。引入 DP 可以让业务接口只专注于最核心的业务逻辑编排，将其他的衍生逻辑提取到 DP 内部处理</p>
</blockquote>
<p>如何编写 DP</p>
<ul>
<li>深入思考 DP 在业务中的隐性属性，以成员变量的方式显性化定义在 DP 对象内部</li>
<li>构造函数里完成属性初始化和自检</li>
<li>使用充血模型实现无状态的业务行为<ul>
<li>业务行为指收敛在这个 DP 对象内部的业务计算逻辑</li>
<li>DP 对象也可以封装多个其他 DP 对象，实现更复杂的业务计算逻辑</li>
</ul>
</li>
</ul>
<p>常见的 DP 使用场景：</p>
<ul>
<li>有格式限制的 String：比如 Name，PhoneNumber，OrderNumber，ZipCode，Address 等</li>
<li>有限制的 Integer：比如 OrderId，Percentage，Quantity 等</li>
<li>可枚举的 int：比如 Status（一般不用 Enum 因为反序列化问题）</li>
<li>Double 或 BigDecimal：一般用到的 Double 或 BigDecimal 都是有业务含义的，比如 Temperature、Money、Amount、ExchangeRate、等</li>
<li>复杂的数据结构：比如 Map&lt;String, List<Integer>&gt;等，尽量能把 Map 的所有操作包装掉，仅暴露必要行为</li>
</ul>
<h2 id="领域的核心-Entity"><a href="#领域的核心-Entity" class="headerlink" title="领域的核心 - Entity"></a>领域的核心 - Entity</h2><blockquote>
<p>Entity 主要提升代码可扩展性、可测试性</p>
</blockquote>
<p>什么是 Entity（实体）？</p>
<ul>
<li>领域主体对象<ul>
<li>带有 ID 属性，有可以相互映射的持久化 DO 对象</li>
<li>状态可变，或叫有状态</li>
</ul>
</li>
</ul>
<p>使用 Entity 能解决什么问题？</p>
<ul>
<li>核心的领域知识（业务计算逻辑）内聚在 Entity 的行为接口内部，新需求只需要改造 Entity 的领域知识即可，扩展性强</li>
<li>Entity 包含所有的业务逻辑，且它本身只是一个内存中的对象，易于对业务逻辑做完整的覆盖测试，提高可测性</li>
</ul>
<p>如何编写 Entity？</p>
<ul>
<li>构造函数里必须初始化所有必要属性并强校验，保证对 Entity 的所有操作（创建、业务行为）都能保证数据一致性<ul>
<li>推荐使用 Builder 模式来实例化 Entity</li>
</ul>
</li>
<li>成员变量和持久化 DO 对象没有必然联系，尽可能将 DO 对象的列属性转换成 DP</li>
<li>使用充血模型实现有状态的业务行为<ul>
<li>业务行为指收敛在这个 Entity 对象内部的业务计算逻辑</li>
<li>只能通过业务行为改变 Entity 属性，不能直接用 set 方法修改属性，保证逻辑和数据一致性</li>
</ul>
</li>
<li>不能直接将外部实体作为成员变量，否则外部实体的行为可能产生“副作用”，但可以将其他实体的 ID 作为成员变量<ul>
<li>所谓副作用，指无法保证外部实体的行为变更后不会影响本实体，由此可能产生 bug。本质问题是这种依赖关系破坏了实体的职能边界</li>
</ul>
</li>
<li>实体自身的业务行为如果依赖外部实体或外部 DP 等参数，可以将相关逻辑写到领域服务的方法实现里，然后将领域服务作为参数一并传入，在业务行为里调用领域服务<ul>
<li>注意，如果涉及到多个实体的修改，必须通过领域服务实现，不能在任何一个实体的行为里实现</li>
</ul>
</li>
<li>复杂业务里，会存在主实体和子实体，这时主实体就充当<code>聚合根</code>的作用，子实体的所有业务行为都只能通过主实体的业务行为暴露，且外部无法单独拿到子实体<ul>
<li>例如交易场景中的主子订单</li>
</ul>
</li>
</ul>
<h2 id="防腐层-ACL"><a href="#防腐层-ACL" class="headerlink" title="防腐层 - ACL"></a>防腐层 - ACL</h2><blockquote>
<p>防腐层主要提升代码可维护性、可测试性</p>
</blockquote>
<p>什么是防腐层？</p>
<ul>
<li>防腐层是业务系统和外部服务之间的隔离带，防腐层通过依赖倒置原则使得业务系统不直接依赖外部服务，而是依赖防腐层提供的抽象 ACL 接口<ul>
<li>业务系统指应用层。应用层主要指业务接口</li>
<li>外部服务指 RPC 服务、中间件、ORM 框架提供的 dao 层服务等</li>
<li>由基础设施层实现防腐层接口，对外部服务做适配封装</li>
</ul>
</li>
</ul>
<p>使用防腐层能解决什么问题？</p>
<ul>
<li>外部服务变化时，业务系统代码相对稳定，提高可维护性</li>
<li>防腐层接口易于 Mock，提高可测试性</li>
<li>防腐层接口的实现里可以对外部服务做统一的技术优化，例如缓存、降级等，真正做到技术实现和业务逻辑分离</li>
</ul>
<p>如何实现防腐层？</p>
<ul>
<li>在领域层的一个 package 里定义所依赖外部服务的抽象 ACL 接口</li>
<li>接口的入参、出参使用域对象 Entity 和 DP，保证业务系统内部只会操作域对象，使得业务逻辑高度内聚，提高可维护性</li>
<li>基础设施层实现 ACL 接口，适配（包装）所有的外部服务，包括外部对象到域对象（Entity、DP）的转换</li>
</ul>
<h2 id="领域服务-DomainService"><a href="#领域服务-DomainService" class="headerlink" title="领域服务 - DomainService"></a>领域服务 - DomainService</h2><blockquote>
<p>领域服务主要提升代码可维护性、可扩展性</p>
</blockquote>
<p>什么是领域服务？</p>
<ul>
<li>领域服务是比单个实体的业务行为更复杂的业务逻辑，通常用来编排多实体间的业务行为或单实体的多个业务行为，起到跨对象事务的作用，保证整体的逻辑和数据一致性</li>
</ul>
<p>如何实现领域服务？</p>
<ul>
<li>入参出参使用 DP、Entity</li>
<li>对 DP、Entity 暴露的业务行为做编排调用</li>
</ul>
<p>使用领域服务解决什么问题？</p>
<ul>
<li>业务接口的计算逻辑（或者说领域知识）完全不依赖任何外部服务，收敛在领域层内，提高可维护性、可扩展性<ul>
<li>因此领域层其实没有任何外部依赖</li>
</ul>
</li>
</ul>
<h2 id="业务接口（也称应用服务、系统服务）"><a href="#业务接口（也称应用服务、系统服务）" class="headerlink" title="业务接口（也称应用服务、系统服务）"></a>业务接口（也称应用服务、系统服务）</h2><p>在上面提到的 DP、Entity、ACL、DomainService 的基础上，业务接口只需要对领域服务和外部服务做编排调用即可</p>
<h1 id="DDD-的应用架构"><a href="#DDD-的应用架构" class="headerlink" title="DDD 的应用架构"></a>DDD 的应用架构</h1><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>Command&#x2F;Query:</p>
<ul>
<li>接口层入参，对应读写服务</li>
</ul>
<p>VO：</p>
<ul>
<li>接口层出参</li>
<li>转换器：VoAssembler<ul>
<li>实现 DTO 到 VO 的转换</li>
</ul>
</li>
</ul>
<p>DP：</p>
<ul>
<li>应用层入参，接口层调用应用层系统服务时转成 DP</li>
<li>Spi 接口出入参</li>
<li>领域层领域服务出入参</li>
<li>ACL 接口的出入参</li>
<li>Entity 的成员变量</li>
<li>命名：Xxx</li>
<li>不需要序列化，内存对象</li>
</ul>
<p>DTO：</p>
<ul>
<li>应用层出参</li>
<li>转化器：DtoAssembler<ul>
<li>实现 Entity 到 Dto 的转换，推荐使用 MapStruct 作为实现</li>
</ul>
</li>
</ul>
<p>Entity：</p>
<ul>
<li>Spi 接口出入参</li>
<li>领域层领域服务出入参</li>
<li>ACL 接口的出入参</li>
<li>命名：XxxEntity</li>
<li>不需要序列化，内存对象</li>
</ul>
<p>DO：</p>
<ul>
<li>基础设施层</li>
<li>ORM 框架操作的数据对象</li>
<li>转化器：DataConverter<ul>
<li>实现 DO 和 Entity 之间的转换，推荐使用 MapStruct 作为实现</li>
</ul>
</li>
</ul>
<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><p>业务系统的分层和依赖关系：</p>
<ul>
<li><p>Client 层</p>
<ul>
<li>放对外提供的应用服务接口定义</li>
<li>入参：Command&#x2F;Query</li>
<li>出参：VO</li>
</ul>
</li>
<li><p>接口层（网关层）</p>
<ul>
<li>对各种通信协议框架（HTTP、RPC、消息队列、任务调度、socket 通信等）的包装</li>
<li>session 管理、鉴权、日志、异常处理、前置缓存、限流</li>
<li>依赖应用层的系统服务，调用系统服务需要将 Command&#x2F;Query 转为 DP 对象</li>
<li>转换器：VoAssembler，实现 应用层出参 DTO 到 VO 的转换，VO 做脱敏处理</li>
</ul>
</li>
<li><p>应用层</p>
<ul>
<li>实现领域对外提供的系统服务</li>
<li>依赖领域层（通过 Spi 层间接依赖）、Spi 层、Plugins（三方 Spi 实现类）</li>
<li>定义防腐层（ACL）接口，包括外部服务和仓储服务，不做具体实现，通过 Spring 依赖注入做依赖反转</li>
<li>只负责业务流程编排但不实现任何具体的业务计算逻辑<ul>
<li>编排：调用领域服务和 ACL 代理接口，调用 spi 接口做业务隔离定制</li>
</ul>
</li>
<li>入参 DP，出参 DTO</li>
<li>依赖 Spi 加载框架做业务扩展点注入，如 COLA-Extension</li>
<li>依赖 Spring 做依赖注入</li>
</ul>
</li>
<li><p>Spi 层</p>
<ul>
<li>定义为三方提供业务定制能力的 Spi 接口，依赖 Domain 层（DP、Entity）</li>
</ul>
</li>
<li><p>领域层</p>
<ul>
<li>定义 Entity、DP，实现 DomainService</li>
</ul>
</li>
<li><p>基础设施层</p>
<ul>
<li>防腐层的 ACL 接口实现，依赖应用层，适配业务系统依赖的所有外部服务</li>
<li>依赖三方服务、中间件服务、dao 层 ORM 框架<ul>
<li>dao 层实现推荐 CQRS 架构</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>DDD 的一般开发模式：</p>
<ul>
<li>先实现领域层和 ACL 防腐层，定义好域对象 Entity 和 DP，定义好 ACL 接口，通过 DomainService 实现领域知识，即业务计算逻辑</li>
<li>再实现应用层，对领域服务和适配外部服务的 ACL 接口做编排调用实现业务接口</li>
<li>最后实现基础设施层</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习HashMap</title>
    <url>/2020/06/18/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0HashMap/</url>
    <content><![CDATA[<h1 id="HashMap的底层结构"><a href="#HashMap的底层结构" class="headerlink" title="HashMap的底层结构"></a>HashMap的底层结构</h1><p>HashMap的底层数据结构是<code>哈希表</code><br>哈希表也称<code>散列表</code>。可以理解为一个数组，基于哈希算法得到元素的哈希值，基于哈希值对数组长度取余得到元素在数组的下标，实现O(1)时间复杂度的增删查效率<br>这种方式在哈希算法不能保证绝对散列时，会存在哈希冲突</p>
<p><code>哈希冲突</code>：作为key的两个不同对象在put时，经过哈希算法得到的哈希值对数组长度取余后结果相同，即在哈希表的位置相同。<br>因为最后用哈希值对数组长度取余，所以两个不同对象发生哈希冲突的概率还是比较大的，尽管两个对象的哈希值一般情况下不相同</p>
<p>解决哈希冲突有两种方式：</p>
<ul>
<li><code>开放定址法</code>。就是继续寻找下一块未被占用的存储地址</li>
<li><code>链地址法</code>。数组+链表的结构来解决哈希冲突</li>
</ul>
<p>链地址法是如何解决哈希冲突的？<br>HashMap使用链地址法解决哈希冲突，将冲突的元素追加到链表尾部。基于Key查询value时，尽管产生了哈希冲突，也会遍历链表，找到真正的key（哈希值相等且equals为true或对象相等）对应的value</p>
<p>所以HashMap的底层结构可以总结为：<code>采用链地址法解决哈希冲突的哈希表</code></p>
<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><ul>
<li>HashMap的无参实例化并没有初始化数组，而是在put的时候进行，初始化默认数组长度为16，默认阈值因子为0.75</li>
<li>HashMap数组长度一定是二次幂</li>
<li>HashMap使用的哈希算法：取key的hashCode，对高十六位和低十六位做异或运算作为新的低十六位，加大低十六位的随机性<ul>
<li><code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li>
</ul>
</li>
<li>HashMap计算key对应数组下标的算法：哈希值对(数组长度-1)做与运算<ul>
<li>因为数组长度是二次幂，所以”对(数组长度-1)做与运算 &#x3D;&#x3D;&#x3D; 对数组长度取模”</li>
</ul>
</li>
<li>put时，如果发生哈希冲突，且key的equals方法也为true或对象严格等，则认为是同一个对象，会updateValue，并返回oldValue。否则认为是两个不同key对象，用链地址法将新Entry加到链表尾部</li>
<li>get时，先通过计算哈希值并对数组长度取余得到下标，取出entry链表并遍历，当哈希值相同且对象严格等或equals为true，则取出entry.value，否则返回null</li>
<li>当map里元素数目超过阈值（默认16*0.75）时进行扩容<ul>
<li>当元素数目超过64，会使用红黑树替代链表（Java8新增）</li>
<li>扩容后，rehash的策略是：对所有在哈希表里存储的Entry对象（包括在链表上的每个Entry对象）重新计算下标：<code>(Entry.key.hash &amp; 新数组长度-1）</code>，因此之前在链表里的元素可能会移动到扩容后的新空间，链表长度缩短，提高空间利用率和查询效率</li>
</ul>
</li>
</ul>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://blog.csdn.net/qq_38182963/article/details/78942764">https://blog.csdn.net/qq_38182963/article/details/78942764</a><br><a href="https://blog.csdn.net/cnm10050/article/details/105082209">https://blog.csdn.net/cnm10050/article/details/105082209</a></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习JAVA注解</title>
    <url>/2022/05/30/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0JAVA%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h1><p>JAVA 原生注解：</p>
<ul>
<li>@Overried、@Deprecated 等，大多数用于「标记」和「检查」</li>
</ul>
<p>框架定义的注解：</p>
<ul>
<li>Spring 的@Controller、@Component 等，Lombok 的@Data、@Builder 等</li>
</ul>
<p>元注解：</p>
<ul>
<li>所谓的元 Annotation 就是用来修饰注解的</li>
<li>常用的元 Annotation 有@Retention 和@Target<ul>
<li>@Retention 注解可以简单理解为设置注解的生命周期</li>
<li>@Target 表示这个注解可以修饰哪些地方（比如方法、还是成员变量、还是包等等）</li>
</ul>
</li>
</ul>
<h1 id="注解的生命周期"><a href="#注解的生命周期" class="headerlink" title="注解的生命周期"></a>注解的生命周期</h1><p>如果要自定义注解，必须关心它的生命周期。<br>@Retention 注解会修饰我们自定义注解生命周期。@Retention 注解传入的是 RetentionPolicy 枚举，该枚举有三个常量，分别是 SOURCE、CLASS 和 RUNTIME</p>
<ul>
<li>SOURCE 代表着注解仅保留在源码级别中，在编译器会被处理，不会带到字节码文件中</li>
<li>CLASS 代表着注解在字节码文件中保留，但不会被 JVM 加载到内存</li>
<li>RUNTIME 代表着注解被 JVM 加载到内存时仍保留，因此运行时环境可以使用它</li>
</ul>
<p>JAVA 编译阶段有一个过程为「注解抽象语法树」，这里其实就会去解析生命周期为 SOURCE 的注解，然后做处理的逻辑。<br>JDK 提供了 Hook，我们想要在编译时期做注解相关的事，可以继承 AbstractProcessor 并实现 process 方法。比如可以看到 lombok 就用 AnnotationProcessor 继承了 AbstractProcessor，这就是为什么使用了个@Data 这样的注解就能有 set&#x2F;get 等方法了，就是在这里加上去的</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习JAVA线程</title>
    <url>/2021/04/30/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0JAVA%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="JAVA线程"><a href="#JAVA线程" class="headerlink" title="JAVA线程"></a>JAVA线程</h1><p><img src="/JVM/JAVA%E7%BA%BF%E7%A8%8B.png"></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>JAVA线程和操作系统的内核线程的映射关系？</p>
<ul>
<li>一一映射</li>
</ul>
<p>线程的调度方式有哪两种？JAVA使用哪种？</p>
<ul>
<li>协同式和抢占式。Java使用抢占式，由操作系统调度。</li>
</ul>
<p>为什么JAVA的线程优先级在不同操作系统下的表现不同？</p>
<ul>
<li>JAVA定义的线程优先级需要映射到操作系统内核线程优先级，因此优先级表现与操作系统相关联</li>
</ul>
<p>JAVA线程有哪五种状态？状态转移关系是？</p>
<ul>
<li>New、Runnable、Waiting、TimedWaiting、Block</li>
</ul>
<p>共享对象按线程安全等级可划分为哪几类？</p>
<ul>
<li>不可变、绝对线程安全、相对线程安全、线程兼容（线程不安全）</li>
</ul>
<p>哪些类型声明为不可变final类型就可以保证一定线程安全？</p>
<ul>
<li>基本数据类型、枚举类、String</li>
</ul>
<p>什么是绝对线程安全？什么是相对线程安全？</p>
<ul>
<li>绝对线程安全的对象，做任何操作都需要保证是线程安全的，包括复合操作，所以绝对安全的类很少，String是绝对线程安全的</li>
<li>相对线程安全的对象，调用任何方法都需要保证是线程安全的，但复合操作不能保证线程安全。我们一般使用的同步集合类都属于相对线程安全的，例如Vector、HashTable、ConcurrentHashMap</li>
</ul>
<p>为什么Vector类是相对线程安全，而非绝对线程安全？</p>
<ul>
<li>复合操作无法保证线程安全。例如常见的putIfAbsent操作，判断absent和put操作都是线程安全的，但作为一个复合操作并不能保证线程安全，可能判断absent成功后线程切换，其他线程添加了这个对象。</li>
</ul>
<p>JAVA实现互斥同步的方式有哪些？</p>
<ul>
<li>synchronised、ReentrantLock</li>
</ul>
<p>为什么说Synchronized同步方式是一个重量级操作？</p>
<ul>
<li>通过操作系统的互斥量实现互斥同步，线程阻塞和唤醒需要在线程用户态和内核态之间切换，成本高</li>
</ul>
<p>ReentrantLock和Synchronized的区别有哪些？</p>
<ul>
<li>ReentrantLock阻塞可被中断</li>
<li>ReentrantLock支持同时存在多个wait&#x2F;signal，通过condition实现，更灵活地唤醒阻塞在某个condition条件下的线程</li>
<li>ReentrantLock支持公平锁</li>
</ul>
<p>JAVA中非阻塞同步（乐观策略）的典型实现方式是什么？J</p>
<ul>
<li>CAS</li>
</ul>
<p>什么是CAS操作的”ABA问题”？</p>
<ul>
<li>CAS虽然成功，但可能Compare的时候对象的值是A，但在Set前，经历了从A到B再回到A的过程，因此虽然CAS成功，但过程中对象仍可能被并发修改</li>
</ul>
<p>什么是自旋？什么是自适应自旋？</p>
<ul>
<li>线程获取不到锁时，不挂起，而是跑一定次数的空循环，期间依然不断尝试获取锁。在锁很快得到释放时，这么做能避免线程阻塞唤醒带来的开销</li>
<li>基于之前自旋后获取锁的情况，动态调整自旋时间</li>
</ul>
<p>什么是锁消除？什么是锁粗化？</p>
<ul>
<li>不发生线程逃逸的代码，可以消除加锁操作，称为锁消除。连续执行的代码频繁加解锁，可以在外层只加一次锁，称为锁粗化</li>
</ul>
<p>轻量级锁的加解锁过程是怎样的？什么情况下轻量级锁会升级为重量级锁？</p>
<ul>
<li>加锁：先根据锁对象的MarkWord判断是否未被加锁，是则把MarkWord复制到栈帧上，再CAS将加锁对象的MarkWord区域指向栈帧上存储MarkWord的地址，成功则加锁成功。否则说明被其他线程抢占了，升为重量级锁，锁对象的MarkWord指向互斥量</li>
<li>解锁：CAS将栈空间的MarkWord写回到锁对象，如果失败，说明已经升级到重量级锁，需要唤醒被阻塞的线程</li>
</ul>
<p>轻量级锁相比重量级锁（互斥量）的优势是？什么场景下更适合使用轻量级锁？</p>
<ul>
<li>轻量级锁使用CAS避免了使用互斥量的开销，在加解锁期间如果不存在并发竞争锁对象，就不会升级为重量级锁，减少了使用互斥量的性能开销</li>
<li>锁竞争不激烈，线程间交替持有锁时，适合轻量级锁</li>
</ul>
<p>偏向锁的工作原理是？适合什么场景？</p>
<ul>
<li>MarkWord区域指向持有锁的线程id，这样同一线程下次获取锁时，无需额外操作</li>
<li>只有同一个线程尝试获取锁，适合用偏向锁</li>
</ul>
<p>偏向锁、轻量级锁、重量级锁之间的升降级流转过程是？</p>
<ul>
<li>如果MarkWord处于无锁状态且偏向锁可用，则尝试获取偏向锁，失败则升级为轻量级锁</li>
<li>轻量级锁解锁成功，恢复到无锁状态，偏向锁不可用。解锁失败，升级为重量级锁，唤醒阻塞线程</li>
<li>重量级锁解锁成功，恢复到无锁状态，偏向锁不可用</li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>JAVA的线程是纯native实现的，因此完全依赖底层操作系统。JAVA线程最终会映射到操作系统的线程模型上</p>
<p>操作系统的线程模型有以下三类：</p>
<ul>
<li>一对一线程模型。程序里创建的线程实际是内核线程封装的轻量级进程，程序线程与<code>内核线程</code>是一一映射的</li>
<li>一对多线程模型。程序里创建的线程与系统内核无关，是纯用户态的线程（<code>用户线程</code>）。一个内核线程映射多个用户线程</li>
</ul>
<p>JAVA在Windows和Linux操作系统上，使用一对一线程模型，即JAVA线程会映射到内核线程</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程调度有两种方式</p>
<ul>
<li>协同式：线程控制型。线程执行完后通知操作系统进行线程切换。缺点是一旦线程执行时间过长，会阻塞其他的线程</li>
<li>抢占式：操作系统控制型。操作系统来调度线程的执行。JAVA使用这种方式<ul>
<li>JAVA支持设置线程优先级来影响线程调度，但因为JAVA线程与内核线程一一映射，而内核线程的优先级与对应的操作系统有关，因此JAVA定义的线程优先级需要映射到操作系统内核线程优先级。所以在不同操作系统中，JAVA线程优先级表现不同，不能完全依赖设置的优先级</li>
</ul>
</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>JAVA定义了五种线程状态</p>
<ul>
<li>新建（New）：线程创建且未启动前</li>
<li>运行（Runable）：Ready和Running都对应这种状态</li>
<li>无限期等待（Waiting）：线程执行时主动调用监视器对象的无参wait方法。需要被其他线程显式notify唤醒</li>
<li>限期等待（TimedWaiting）：线程执行时主动调用sleep和wait带参方法，会让出执行权。但会在指定时间后回到Runable状态<ul>
<li>sleep和join不会释放锁，wait会释放锁</li>
</ul>
</li>
<li>阻塞（Blocked）：线程执行时遇到同步代码且未获得排它锁，则被动让出执行权。获得对象锁后回到Runable状态</li>
</ul>
<h3 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait &amp; notify"></a>wait &amp; notify</h3><p>wait和notify的总结如下：</p>
<ul>
<li>wait方法会使当前线程进入自己所持有的监视器锁(this object)的等待队列中, 并且放弃一切已经拥有的(这个监视器锁上的)同步资源, 然后挂起当前线程, 直到以下四个条件之一发生:<ul>
<li>其他线程调用了this object的notify方法, 并且当前线程恰好是被选中来唤醒的那一个</li>
<li>其他线程调用了this object的notifyAll方法</li>
<li>其他线程中断了当前线程</li>
<li>指定的超时时间到了.(如果指定的超时时间是0, 则该线程会一直等待, 直到收到其他线程的通知)</li>
</ul>
</li>
<li>当以上4个条件之一满足后, 该线程从wait set中移除, 重新参与到线程调度中, 并且和其他线程一样, 竞争锁资源, 一旦它又获得了监视器锁, 则它在调用wait方法时的所有状态都会被恢复, 这里要注意“假唤醒”的问题<ul>
<li>如果用if判断唤醒条件，则notifyAll唤醒后可能产生虚假唤醒。例如生产消费模型，生产者notifyAll唤醒所有消费者，可能出现超额消费（超卖）。最好的解法是使用while判断唤醒条件，因为if判断唤醒条件，唤醒后不会再次校验唤醒条件，可能这时又不满足唤醒条件了，即发生了虚假唤醒。see：<a href="https://www.cnblogs.com/jichi/p/12694260.html">https://www.cnblogs.com/jichi/p/12694260.html</a></li>
</ul>
</li>
<li>当前线程在进入wait set之前或者在wait set之中时, 如果被其他线程中断了, 则会抛出InterruptedException异常, 但是, 如果是在恢复现场的过程中被中断了, 则直到现场恢复完成后才会抛出InterruptedException</li>
<li>即使wait方法把当前线程放入this object的wait set里, 也只会释放当前监视器锁(this object), 如果当前线程还持有了其他同步资源, 则即使它在this object中的等待队列中, 也不会释放</li>
<li>notify方法会在所有等待监视器锁的线程中任意选一个唤醒, 具体唤醒哪一个, 交由该方法的实现者自己决定.</li>
<li>线程调用notify方法后不会立即释放监视器锁，只有退出同步代码块后，才会释放锁（与之相对，调用wait方法会立即释放监视器锁）</li>
<li>线程被notify或notifyAll唤醒后会继续和其他普通线程一样竞争锁资源</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全的极简定义：</p>
<p>并发下对共享对象的操作都可以获得正确的结果</p>
<h3 id="共享数据的五类线程安全等级"><a href="#共享数据的五类线程安全等级" class="headerlink" title="共享数据的五类线程安全等级"></a>共享数据的五类线程安全等级</h3><p>按共享数据的线程安全等级由强至弱排序，可以将共享数据分为五类：</p>
<p>不可变、绝对线程安全、相对线程安全、线程兼容、线程对立</p>
<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变类型的共享数据，无需进行任何同步措施，一定是线程安全的</p>
<p>如果共享数据是基本数据类型，只要定义时使用final修饰就可以保证它不会变</p>
<p>如果共享数据类型是引用类型，需要保证对象的行为不会对其状态（属性）产生任何影响。常见的例子是String对象，String类任何的方法都不会影响原来的值，只会返回一个新构造的字符串对象</p>
<h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对线程安全类型的共享数据，要求调用方不需要任何同步措施，就能保证对共享数据的操作是线程安全的</p>
<p>有些声明为线程安全的类，不一定是绝对线程安全的</p>
<p>例如Vector类，虽然它的所有方法都声明为同步来保证线程安全，但对于<code>复合操作</code>依然需要调用方使用同步措施保证线程安全。例如经典的<code>put-if-absent</code>情况，尽管contains、add方法都正确地同步了，但复合操作时，if条件判断为真，那个用来访问vector.contains方法的锁已经释放，在即将的vector.add方法调用之间有间隙，在多线程环境中，完全有可能被其他线程获得vector的lock并改变其状态，此后vector.add继续，但此时它已经基于一个错误的假设了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!vector.contains(element)) </span><br><span class="line">    vector.add(element); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全类型的共享数据，需要保证对共享对象单独的操作是线程安全的。但对于一些复合操作，就可能需要调用方额外的同步措施保证调用的正确性。上面Vector例子就能印证。所以说Vector类是相对线程安全的。类似的还有HashTable和一些其他的同步集合类。</p>
<h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容类型的共享数据，需要调用端正确使用同步措施保证对象并发环境下安全的使用。我们平时说一个类不是线程安全的，基本都是这种情况。</p>
<h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立类型的共享数据，无论调用方是否采取同步措施，都无法在多线程环境下并发操作对象。</p>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>同步指多线程并发访问共享数据时，同一时刻数据只被一个线程使用。互斥是实现同步的方式</p>
<p>JAVA中最常使用的互斥同步方式就是synchronized关键字。使用synchronized需要明确指明锁定和解锁的对象，可以在代码里明确声明，如果没有，根据synchronized修饰的是类方法还是实例方法，取对应的class对象或实例对象作为锁对象</p>
<blockquote>
<p>Synchronized</p>
</blockquote>
<p>synchronized关键字编译后会在同步块前后形成两条字节码指令：monitorenter和monitorexit。enter时需要获得对象的锁，如果对象没被锁定或当前线程已经持有对象锁，把锁的计数器+1。exit时把锁的计数器-1。如果线程获取对象锁失败，则阻塞等待</p>
<p>由此可知，synchronized同步块对线程来说是可重入的</p>
<p>synchronized是重量级的一个操作：JAVA的线程会映射到系统内核线程，synchronized同步会频繁阻塞和唤醒线程，这些操作都要依赖操作系统完成，因此要频繁地在用户态和内核态之间切换，影响性能</p>
<blockquote>
<p>ReentrantLock</p>
</blockquote>
<p>和synchronized类似，都是可重入锁。但也有区别：</p>
<ul>
<li>阻塞可中断：阻塞在等待对象锁的线程可以中断来放弃等待，改为处理其他的事情</li>
<li>公平锁：多个线程按申请对象锁的时间顺序依次获得锁。ReentrantLock支持公平锁和非公平锁两种模式，synchronized的锁是非公平的，任何等待锁的线程都有机会获得锁</li>
<li>更灵活的等待通知模式：synchronized的锁对象执行wait&#x2F;notify方法可以实现一个条件下的等待通知。ReentrandLock可以创建多个condition（监视器对象），每个condition都可以自由调用await&#x2F;signal完成等待通知，从而有选择性地通知那些等待在特定condition的线程，线程调度更加灵活</li>
</ul>
<p>性能上，在JDK1.6发布后（1.6对synchronized做了优化），二者基本持平</p>
<h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步是一种重量级的、悲观的并发策略</p>
<p>那什么是乐观的并发策略呢？通俗说，就是先操作，再检测有没有并发存在，如果没有就操作成功了，如果有，就采取补偿措施（最常见的就是不断重试直至成功）</p>
<p>这种乐观策略的许多实现方式，都不需要线程挂起，因此称为非阻塞同步</p>
<p>得益于指令集对原子操作指令的丰富，使得非阻塞同步能够实现</p>
<p>JAVA的Unsafe类里提供了compareAndSwapXXX方法，该方法会即时编译为一条CAS(compareAndSwap指令，当前值比较成功后与期望值交换，不成功返回当前值)原子操作指令。基于该方法，诞生了一些非阻塞同步的实现类，例如JUC包里的整数原子类，其中的compareAndSet和getAndIncrement方法都用到了CAS指令。以AtomInteger的自增接口为例，它通过volatile可见性机制直接读到主内存最新值，然后作为当前值，+1后的值作为期望值，调用CAS指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS看起来很适合非阻塞同步，但也有一个漏洞，即<code>ABA问题</code>：变量在读取时是A值，CAS阶段也成功，即当前值仍然是A，但无法能保证在读取和CAS操作期间，变量从未改变过，可能从A到B，又回到A。解决这个问题可以使用版本号，但意义不大，因为通常情况下，ABA问题不会影响并发操作的正确性。如果影响，可以使用传统的互斥同步。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>锁优化是为了更高效地实现线程间对共享对象的竞争</p>
<h4 id="自旋与自适应自旋"><a href="#自旋与自适应自旋" class="headerlink" title="自旋与自适应自旋"></a>自旋与自适应自旋</h4><p>自旋锁的目标是降低线程切换的成本</p>
<p>自旋的概念：</p>
<ul>
<li>通常线程对共享数据的锁定时间很短。在多核处理器中，可以让多个线程并行执行。所以在线程获取不到锁时，可以执行一个忙循环（自旋），看看锁是否会很快释放。自旋次数默认是10次，否则一直自旋得不到锁时，反而浪费硬件资源。</li>
</ul>
<p>自适应自旋：</p>
<ul>
<li>基于对锁的自旋等待结果，动态调整自旋次数，称为自适应自旋</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>JVM在即时编译阶段，对一些代码要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。检测的方法是逃逸分析技术，判断一段代码里堆上的数据是否会逃逸从而被其他线程访问（线程逃逸），如果不会，则可以进行锁消除</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>对同一个锁对象一连串零碎的加锁同步代码，会把加锁范围扩大到最外层，避免频繁的加解锁造成线程阻塞与唤醒带来的性能损耗</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</p>
<p>首先介绍Hotspot虚拟机中<code>对象头的内存布局</code>：</p>
<ul>
<li>对象未被锁定时，一部分存储对象自身的运行时数据，包括哈希码、GC分代年龄、锁标志位等，官方称为<code>Mark Word</code><ul>
<li>MarkWord空间是被复用的，在对象被锁定时，存储的内容会不同</li>
</ul>
</li>
<li>另一部分存储指向方法区对象类型的指针</li>
</ul>
<p>轻量级锁的加锁过程：<br>代码进入同步块时，如果同步对象没有被锁定，JVM会在当前线程的栈帧中分配一部分空间，存储锁对象MarkWord的拷贝称为<code>DisplacedMarkWord</code>，然后CAS将锁对象MarkWord的值改为指向这部分栈帧空间的指针。如果修改成功，这个线程就拥有了锁对象，锁标志位改为轻量级锁状态。如果修改失败，说明锁对象已经被其他线程抢占，锁对象要膨胀为重量级锁，MarkWord存储指向互斥量的指针，锁标志位改为重量级锁状态，等待锁的线程进入阻塞状态</p>
<p>轻量级锁的解锁过程：<br>CAS将栈帧中DisplacedMarkWord的值写回到锁对象的MarkWord区域。如果MarkWord值并未指向栈地址，说明已经升级为重量级锁，解锁还需要唤醒被阻塞线程。</p>
<p>综上，轻量级锁使用CAS避免了使用互斥量的开销，在加解锁期间如果不存在并发竞争锁对象，就不会升级为重量级锁，减少了使用互斥量的性能开销。但如果在并发激烈的场景，轻量级锁会比重量级锁慢，因为额外产生了CAS操作</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<p>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。</p>
<h4 id="偏向锁、轻量级锁、重量级锁的使用场景"><a href="#偏向锁、轻量级锁、重量级锁的使用场景" class="headerlink" title="偏向锁、轻量级锁、重量级锁的使用场景"></a>偏向锁、轻量级锁、重量级锁的使用场景</h4><p>偏向锁：</p>
<ul>
<li>无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li>
</ul>
<p>轻量级锁：</p>
<ul>
<li>无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li>
</ul>
<p>重量级锁：</p>
<ul>
<li>有实际竞争，且锁竞争时间长。</li>
</ul>
<h4 id="不同锁升降级流转"><a href="#不同锁升降级流转" class="headerlink" title="不同锁升降级流转"></a>不同锁升降级流转</h4><p>没有任何线程尝试获取锁对象时，处于未锁定状态</p>
<p>锁对象被初始锁定后，处于偏向锁状态</p>
<p>其他线程尝试获取偏向锁时，如果锁对象正被持有，升级为轻量级锁，如果未被持有，降级为未锁定状态，但后续不可再使用偏向锁</p>
<p>轻量级锁定阶段，如果有其他线程尝试获取锁，升级为重量级锁</p>
<p>轻量级锁和重量级锁解锁后都降级到未锁定状态，重量级锁还需要唤醒阻塞线程</p>
<p><img src="/JVM/%E5%8A%A0%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B.webp"></p>
<h2 id="异步任务FutureTask"><a href="#异步任务FutureTask" class="headerlink" title="异步任务FutureTask"></a>异步任务FutureTask</h2><p>FutureTask表示一个异步任务，它实现了Runnable和Future接口，其中Future接口提供了获取任务结果、取消任务的能力。线程池ThreadPoolExecutor的submit方法会创建一个异步任务FutureTask并执行，然后返回FuturTask，外部通过调用它的get方法获取异步结算结果</p>
<p>FutureTask内部有一个volatile state，表示当前任务的执行状态，含义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int NEW          = 0; //任务新建和执行中</span><br><span class="line">private static final int COMPLETING   = 1; //瞬态，任务已经执行完毕或抛异常了，出参赋值给outcome前的状态</span><br><span class="line">private static final int NORMAL       = 2; //终态，任务正常执行结束，出参赋值给outcome后的状态</span><br><span class="line">private static final int EXCEPTIONAL  = 3; //终态，任务执行异常，throwable赋值给outcome后的状态</span><br><span class="line">private static final int CANCELLED    = 4; //终态，任务从NEW到CANCELED，如果任务还没执行，则不会执行。如果正在执行，cancel方法没效果，只是状态变为canceled</span><br><span class="line">private static final int INTERRUPTING = 5; //瞬态，调用cancel方法且需要中断任务时，在调用任务线程的interupt中断方法前的状态</span><br><span class="line">private static final int INTERRUPTED  = 6; //终态，已调用任务线程的interupt中断方法</span><br></pre></td></tr></table></figure>

<p>重点说下对cancel的理解：</p>
<ul>
<li>异步任务还没执行或还没执行完，状态为NEW，此时可取消，返回true，future.get方法抛任务取消异常。否则如果执行完了或者执行异常了或者之前已经取消了，则不能取消，返回false</li>
<li>如果任务还没执行，则取消生效，任务不会执行</li>
<li>如果任务在执行中<ul>
<li>cancel方法不设置中断线程，则对任务没有任何效果，任务状态改为Canceled</li>
<li>cancel方法设置中断线程，则调用thread.interupt做线程中断，任务状态最终为INTERUPTED</li>
</ul>
</li>
</ul>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FutureDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor executorService = new ThreadPoolExecutor(1, 1,</span><br><span class="line">            0L, TimeUnit.MILLISECONDS,</span><br><span class="line">            new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        // 预创建线程</span><br><span class="line">        executorService.prestartCoreThread();</span><br><span class="line"></span><br><span class="line">        Future future = executorService.submit(new Callable&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object call() &#123;</span><br><span class="line">                System.out.println(&quot;start to run callable&quot;);</span><br><span class="line">                Long start = System.currentTimeMillis();</span><br><span class="line">                while (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    Long current = System.currentTimeMillis();</span><br><span class="line">                    if ((current - start) &gt; 5000) &#123;</span><br><span class="line">                        System.out.println(&quot;当前任务执行已经超过5s&quot;);</span><br><span class="line">                        return 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;当前任务已被中断&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 保证异步任务已经在执行了</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * future.cancel方法说明：</span><br><span class="line">         * 异步任务还没执行或还没执行完，状态为NEW，此时可取消，返回true，否则如果执行完了或者执行异常了或者之前已经取消了，则不能取消，返回false</span><br><span class="line">         * 如果任务还没执行，则取消生效，任务不会执行</span><br><span class="line">         * 如果任务在执行中</span><br><span class="line">         *      cancel方法不设置中断线程，则对任务没有任何效果</span><br><span class="line">         *      cancel方法设置中断线程，则调用thread.interupt做线程中断，任务状态最终为INTERUPTED</span><br><span class="line">         */</span><br><span class="line">        System.out.println(future.cancel(true));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 上面future.cancel返回true，但任务已经在执行中了且没有中断，实际不影响任务执行</span><br><span class="line">             * 不过Future(实际为FutureTask)的状态已经改为Canceled，get方法抛任务取消异常</span><br><span class="line">             * 所以只要任务被取消成功，就无法通过future.get拿到结果</span><br><span class="line">             */</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //NO OP</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习JAVA代理</title>
    <url>/2021/07/28/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Java%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="动态代理和静态代理"><a href="#动态代理和静态代理" class="headerlink" title="动态代理和静态代理"></a>动态代理和静态代理</h1><p>代理是一种设计模式，又简单的分为两种。</p>
<ul>
<li>静态代理:代理类和委托类在代码运行前关系就确定了</li>
<li>动态代理:动态代理类的字节码在程序运行时的时候生成</li>
</ul>
<h1 id="静态代理的问题"><a href="#静态代理的问题" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h1><p>静态代理最直接的实现方法，就是代理类里注入委托类，实现增强逻辑以及回调委托类的方法，可以理解成一个简单的装饰模式。静态代理的缺点就是既然要代理委托类，就要实现委托类的所有方法，工作量太大</p>
<h1 id="动态代理来了"><a href="#动态代理来了" class="headerlink" title="动态代理来了"></a>动态代理来了</h1><p>动态代理在程序运行阶段动态生成代理类，且不需要实现委托类的所有方法，而是统一对委托类的方法做增强处理。回调委托类方法使用反射或预先建立的方法索引机制，不同动态代理的方式不同</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK动态代理的原理简述如下：</p>
<ul>
<li>InvocationHandler注入被代理类</li>
<li>运行时（动态）创建实现了委托类接口的Proxy代理类，在构造方法里注入InvocationHandler<ul>
<li>代理类的静态代码块里通过反射获取了委托类实现接口的所有方法Method类，实现接口时传入了对应的Method类方便后面反射调用</li>
</ul>
</li>
<li>Proxy代理委托类的方法时，回调InvocationHandler的invoke方法，传入原委托方法Method对象、参数列表等</li>
<li>在InvocationHandler的invoke方法里实现增强逻辑，并通过反射回调委托类的原方法</li>
</ul>
<p>jdk动态代理的Demo如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProxyFactory implements InvocationHandler &#123;</span><br><span class="line">    private Class&lt;?&gt; target;</span><br><span class="line">    private Object real;</span><br><span class="line">    //委托类class</span><br><span class="line">    public ProxyFactory(Class&lt;?&gt; target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">	//实际执行类bind</span><br><span class="line">    public  Object bind(Object real)&#123;</span><br><span class="line">        this.real=real;</span><br><span class="line">        //利用JDK提供的Proxy实现动态代理</span><br><span class="line">        return  Proxy.newProxyInstance(target.getClassLoader(),new Class[]&#123;target&#125;,this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">		//代理环绕</span><br><span class="line">        System.out.println(&quot;begin&quot;);</span><br><span class="line">        //执行实际的方法</span><br><span class="line">        Object invoke = method.invoke(real, args);</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calculator proxy =(Calculator) new ProxyFactory(Calculator.class).bind(new Calculator.CalculatorImpl());</span><br><span class="line">        proxy.add(1,2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK动态代理的特点总结如下：</p>
<ul>
<li>JDK动态代理只能代理实现了接口的委托类，且只能代理接口方法</li>
<li>DK的动态代理还可以代理Object类的equals、hashCode、toString这三个方法</li>
</ul>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>如果委托类没实现接口，CGLIB动态创建的代理类是委托类的子类，否则和JDK动态代理一样，代理类也实现了委托类的接口</p>
<p>CGLIB生成的代理类对委托类所有可代理的方法（可覆写或实现了接口的方法）做了索引，执行代理时可以根据委托类方法签名的哈希值快速路由到委托类对应方法，直接用注入的委托类对象实例调用方法即可，避免了反射调用带来的性能损耗</p>
<p>CGLIB动态代理的特点总结如下：</p>
<ul>
<li>CGlib可以传入接口也可以传入普通的类，接口使用实现的方式，普通类使用会使用继承的方式生成代理类</li>
<li>由于是继承方式，如果是static方法、private方法、final方法等描述的方法是不能被代理的</li>
<li>做了方法访问优化，使用建立方法索引的方式避免了传统Method的方法反射调用</li>
<li>CGLIB会默认代理Object中finalize、equals、toString、hashCode、clone等方法。比JDK代理多了finalize和clone</li>
</ul>
<h1 id="AspectJ静态代理"><a href="#AspectJ静态代理" class="headerlink" title="AspectJ静态代理"></a>AspectJ静态代理</h1><p>静态代理唯一的缺点就是我们需要对每一个方法编写我们的代理逻辑，造成了工作的繁琐和复杂。AspectJ就是为了解决这个问题，在编译成class字节码的时候在方法周围加上业务逻辑。复杂的工作由特定的编译器帮我们做。</p>
<p>通过编写满足AspectJ语法的切面类，再配合mvn插件，编译委托类就可以得到静态织入的class文件，加载到JVM的委托类已经被增强了</p>
<p>AspectJ静态代理的特点总结如下：</p>
<ul>
<li>Aspectj并不是动态的在运行时生成代理类，而是在编译的时候就植入代码到class文件，所以性能相对来说比较好</li>
<li>Aspectj不受类的特殊限制,不管方法是private、或者static、或者final的,都可以代理</li>
<li>Aspectj不会代理除了限定方法之外任何其他诸如toString()、clone()等方法</li>
</ul>
<h1 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h1><p>SpringAOP实际上是对JDK代理和CGLIB代理做了一层封装，并引入了AspectJ的一些概念注解，例如@pointCut,@after,@before。需要注意，SpringAOP没有用AspectJ静态代理</p>
<p>我们在使用SpringAOP的时候通常会在XML配置文件中设置<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;</code>来使用CGLIB代理。但是是否一定会使用还是得看传入的class到底是个怎样的类。如果是接口，就算开启了这几个开关，最后还是会自动选择JDK代理</p>
<p>如果使用JDK动态代理，重点关注<code>JdkDynamicAopProxy</code>这个类，它实现了InvokeHandler接口，增强逻辑在invoke方法里。为了实现前置增强、后置增强等多个切面类赋予的增强逻辑，</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Mybatis</title>
    <url>/2022/06/28/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis-的工作流程"><a href="#Mybatis-的工作流程" class="headerlink" title="Mybatis 的工作流程"></a>Mybatis 的工作流程</h1><p>1、创建全局配置文件，包含数据库连接信息、Mapper 映射文件路径等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- 加载类路径下的属性文件 --&gt;</span><br><span class="line">	&lt;properties resource=&quot;db.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 设置一个默认的连接环境信息 --&gt;</span><br><span class="line">	&lt;environments default=&quot;mysql_developer&quot;&gt;</span><br><span class="line">		&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span><br><span class="line">		&lt;environment id=&quot;mysql_developer&quot;&gt;</span><br><span class="line">			&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span><br><span class="line">			&lt;transactionManager type=&quot;jdbc&quot;/&gt;</span><br><span class="line">			&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span><br><span class="line">			&lt;dataSource type=&quot;pooled&quot;&gt;</span><br><span class="line">				&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span><br><span class="line">				&lt;property name=&quot;driver&quot; value=&quot;$&#123;mysql.driver&#125;&quot;/&gt;</span><br><span class="line">				&lt;property name=&quot;url&quot; value=&quot;$&#123;mysql.url&#125;&quot;/&gt;</span><br><span class="line">				&lt;property name=&quot;username&quot; value=&quot;$&#123;mysql.username&#125;&quot;/&gt;</span><br><span class="line">				&lt;property name=&quot;password&quot; value=&quot;$&#123;mysql.password&#125;&quot;/&gt;</span><br><span class="line">			&lt;/dataSource&gt;</span><br><span class="line">		&lt;/environment&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span><br><span class="line">		&lt;environment id=&quot;oracle_developer&quot;&gt;</span><br><span class="line">			&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span><br><span class="line">			&lt;transactionManager type=&quot;jdbc&quot;/&gt;</span><br><span class="line">			&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span><br><span class="line">			&lt;dataSource type=&quot;pooled&quot;&gt;</span><br><span class="line">				&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span><br><span class="line">				&lt;property name=&quot;driver&quot; value=&quot;$&#123;oracle.driver&#125;&quot;/&gt;</span><br><span class="line">				&lt;property name=&quot;url&quot; value=&quot;$&#123;oracle.url&#125;&quot;/&gt;</span><br><span class="line">				&lt;property name=&quot;username&quot; value=&quot;$&#123;oracle.username&#125;&quot;/&gt;</span><br><span class="line">				&lt;property name=&quot;password&quot; value=&quot;$&#123;oracle.password&#125;&quot;/&gt;</span><br><span class="line">			&lt;/dataSource&gt;</span><br><span class="line">		&lt;/environment&gt;</span><br><span class="line">	&lt;/environments&gt;</span><br><span class="line">	&lt;mappers&gt;</span><br><span class="line">		&lt;mapper resource=&quot;zhongfucheng/StudentMapper.xml&quot;/&gt;</span><br><span class="line">	&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>2、读取配置文件，构建全局 SqlSessionFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line">/**</span><br><span class="line"> * 加载位于src/mybatis.xml配置文件</span><br><span class="line"> */</span><br><span class="line">static&#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		Reader reader = Resources.getResourceAsReader(&quot;mybatis.xml&quot;);</span><br><span class="line">		sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、获取当前线程的 SQLSession（事务默认开启）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   private static ThreadLocal&lt;SqlSession&gt; threadLocal = new ThreadLocal&lt;SqlSession&gt;();</span><br><span class="line">   public static SqlSession getSqlSession()&#123;</span><br><span class="line">	//从当前线程中获取SqlSession对象</span><br><span class="line">	SqlSession sqlSession = threadLocal.get();</span><br><span class="line">	//如果SqlSession对象为空</span><br><span class="line">	if(sqlSession == null)&#123;</span><br><span class="line">		//在SqlSessionFactory非空的情况下，获取SqlSession对象</span><br><span class="line">		sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		//将SqlSession对象与当前线程绑定在一起</span><br><span class="line">		threadLocal.set(sqlSession);</span><br><span class="line">	&#125;</span><br><span class="line">	//返回SqlSession对象</span><br><span class="line">	return sqlSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、通过 SQLSession 读取 namdspace 对应的 Mapper 映射文件中的操作编号 id，从而读取并执行 SQL 语句，提交事务，最后关闭连接</p>
<ul>
<li>每个 Mapper 映射文件里都定义了唯一的 namespace 标识</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span><br><span class="line">    sqlSession.insert(&quot;StudentID.add&quot;, student);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">    throw e;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    MybatisUtil.closeSqlSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper 映射文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- namespace属性是名称空间，必须唯一 --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;StudentID&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- resultMap标签:映射实体与表</span><br><span class="line">		 type属性：表示实体全路径名</span><br><span class="line">		 id属性：为实体与表的映射取一个任意的唯一的名字</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;resultMap type=&quot;zhongfucheng.Student&quot; id=&quot;studentMap&quot;&gt;</span><br><span class="line">		&lt;!-- id标签:映射主键属性</span><br><span class="line">			 result标签：映射非主键属性</span><br><span class="line">		     property属性:实体的属性名</span><br><span class="line">		     column属性：表的字段名</span><br><span class="line">		--&gt;</span><br><span class="line">		&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;sal&quot; column=&quot;sal&quot;/&gt;</span><br><span class="line">	&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">	&lt;insert id=&quot;add&quot; parameterType=&quot;zhongfucheng.Student&quot;&gt;</span><br><span class="line">		INSERT INTO ZHONGFUCHENG.STUDENTS (ID, NAME, SAL) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;sal&#125;);</span><br><span class="line">	&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * 关闭SqlSession与当前线程分开</span><br><span class="line"> */</span><br><span class="line">public static void closeSqlSession()&#123;</span><br><span class="line">	//从当前线程中获取SqlSession对象</span><br><span class="line">	SqlSession sqlSession = threadLocal.get();</span><br><span class="line">	//如果SqlSession对象非空</span><br><span class="line">	if(sqlSession != null)&#123;</span><br><span class="line">		//关闭SqlSession对象</span><br><span class="line">		sqlSession.close();</span><br><span class="line">		//分开当前线程与SqlSession对象的关系，目的是让GC尽早回收</span><br><span class="line">		threadLocal.remove();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1><p>如果查询单表就可以满足需求，一开始先查询单表，当需要关联信息时，再关联查询，当需要关联信息再查询这个叫延迟加载。<br>延迟加载能提高数据库查询性能，因为单表查询比多表关联查询速度要快。</p>
<p>在全局配置文件中开启懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;settings&gt;</span><br><span class="line">	&lt;!-- 延迟加载总开关，默认false --&gt;</span><br><span class="line">	&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;!-- 设置按需加载，默认true --&gt;</span><br><span class="line">	&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p>在 Mybatis 中延迟加载就是在 resultMap 中配置具体的延迟加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;!-- 一对一查询延迟加载 的配置 --&gt;</span><br><span class="line">&lt;resultMap type=&quot;orders&quot; id=&quot;orderCustomLazyLoading&quot;&gt;</span><br><span class="line">	&lt;!-- 完成了订单信息的映射配置 --&gt;</span><br><span class="line">	&lt;!-- id：订单关联用户查询的唯 一 标识 --&gt;</span><br><span class="line">	&lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;user_id&quot; property=&quot;userId&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt;</span><br><span class="line">	&lt;!--</span><br><span class="line"></span><br><span class="line">	配置用户信息的延迟加载</span><br><span class="line">	 	select：延迟加载执行的sql所在的statement的id，如果不在同一个namespace需要加namespace</span><br><span class="line">		sql：根据用户id查询用户信息【column就是参数】</span><br><span class="line">		column：关联查询的列</span><br><span class="line">		property:将关联查询的用户信息设置到Orders的哪个属性 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;!--当需要user数据的时候，它就会把column所指定的user_id传递过去给cn.itcast.mybatis.mapper.UserMapper.findUserById作为参数来查询数据--&gt;</span><br><span class="line">	&lt;association property=&quot;user&quot;</span><br><span class="line">		select=&quot;cn.itcast.mybatis.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&gt;&lt;/association&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!--</span><br><span class="line">           在association和collection标签中都有⼀个fetchType属性，通过修改它的值，可以修改局部的加载策略</span><br><span class="line">           局部的加载策略的优先级高于全局的加载策略</span><br><span class="line">           fetchType=&quot;lazy&quot; 懒加载策略</span><br><span class="line">           fetchType=&quot;eager&quot; ⽴即加载策略</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot; column=&quot;id&quot;</span><br><span class="line">           select=&quot;com.lagou.dao.OrderMapper.findByUid&quot; fetchType=&quot;lazy&quot;&gt;</span><br><span class="line">       &lt;/collection&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>懒加载基本原理：<br>使⽤ CGLIB 或 Javassist( 默认 ) 创建⽬标对象的代理对象<br>当调⽤代理对象的延迟加载属性的 getting ⽅法时，拦截器发现需要延迟加载时，那么就会执行事先保存好的查询关联懒加载对象的 SQL，并赋值给代理对象</p>
<h1 id="Mapper-接口的工作原理"><a href="#Mapper-接口的工作原理" class="headerlink" title="Mapper 接口的工作原理"></a>Mapper 接口的工作原理</h1><p>通常一个 Mapper 映射文件都会写一个 Mapper 接口与之对应，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。<br>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement。因此 Mapper 接口的方法不能重载<br>SqlSession 执行 sql 时会使用 JDK 动态代理为 Mapper 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; byPaging = userMapper.selectUser();</span><br></pre></td></tr></table></figure>

<h1 id="Mybatis-四大组件"><a href="#Mybatis-四大组件" class="headerlink" title="Mybatis 四大组件"></a>Mybatis 四大组件</h1><h1 id="Mybatis-插件"><a href="#Mybatis-插件" class="headerlink" title="Mybatis 插件"></a>Mybatis 插件</h1><p>mybatis 在一次 sqlSession 中对持久层的操作，底层依赖四大组件，分别是：</p>
<ul>
<li>ParameterHandler 参数处理器</li>
<li>StatementHandler SQL 语法构建器</li>
<li>Executor 执行器</li>
<li>ResultSetHandler 结果集处理器</li>
</ul>
<p>mybatis 提供插件机制，允许业务自定义插件，基于 JDK 动态代理对四大组件做代理，在持久化过程中嵌入定制逻辑。mybatis 插件的基本原理是：</p>
<ul>
<li>实现自定义插件（需要实现 org.apache.ibatis.plugin.Interceptor 接口）</li>
<li>mybatis 启动过程中插件注册给 SqlSessionFactory 的 InterceptorChain<ul>
<li>注册方式 1：在 SqlSessionFactory 读取的全局配置文件中添加分页插件</li>
<li>注册方式 2：配置 SqlSessionFactory 的 Bean 时进行添加。可以在@Bean 或 xml 配置里直接添加</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">        &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span><br><span class="line">        &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;</span><br><span class="line">            &lt;!-- 使用MySQL方言的分页 --&gt;</span><br><span class="line">            &lt;property name=&quot;helperDialect&quot; value=&quot;sqlserver&quot;/&gt;&lt;!--如果使用mysql，这里value为mysql--&gt;</span><br><span class="line">            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line"> &lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 SQL 的不同阶段，会创建对应的四大组件，创建组件时会遍历 InterceptorChain 里所有的 mybatis 插件，如果插件匹配这个组件，就用 JDK 动态代理包装组件<ul>
<li>创建插件时通过注解指定要匹配的组件类型、方法名和方法参数，如果组件存在对应的方法，则插件和组件匹配</li>
</ul>
</li>
<li>如果组件被动态代理，调用方法前会判断该方法是否在插件的注解里配置了，如果是，先执行插件的增强逻辑，再执行方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">    type = Executor.class,</span><br><span class="line">    method = &quot;query&quot;,</span><br><span class="line">    args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">), @Signature(</span><br><span class="line">    type = Executor.class,</span><br><span class="line">    method = &quot;query&quot;,</span><br><span class="line">    args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;</span><br><span class="line">)&#125;)</span><br><span class="line">public class PageInterceptor implements Interceptor &#123;</span><br><span class="line">    // 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><p>分页插件是 mybatis 自己提供的，提供便捷的分页查询能力<br>分页插件的实现类：com.github.pagehelper.PageInterceptor</p>
<p>分页插件的使用：</p>
<ul>
<li>通过工具类 PageHelper 将分页参数存到 threadLocal</li>
<li>Executor 组件执行 query 方法时，执行 PageInterceptor 的增强逻辑，重写 sql，添加从 threadLocal 拿到的分页参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(1, 10);</span><br></pre></td></tr></table></figure>

<p>分页插件推荐使用 spring-boot-starter 的方式注册，直接引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>它会帮你间接引入 mybatis 框架和分页插件所需要的依赖，然后在配置类中直接给应用中的 SqlSessionFactory bean 注册 PageInterceptor 插件</p>
<h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><p>Mybatis 针对相同的查询 sql，提供了缓存机制。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存：SqlSession 级别，同一个 SqlSession 中的相同 sql 会命中一级缓存。默认开启。关闭的方法是：设置 local-cache-scope 的值为 statement（默认 session）</p>
<ul>
<li>由于使用了数据库连接池，默认是每次执行完 sql 后自动 commit 并关闭 SqlSession，这就导致两次查询不是同一个 SqlSession，所以一级缓存其实是失效的。为了使得一级缓存生效，需要把这些 sql 操作放在同一个事务里</li>
<li>只要发生了写操作，都会将作用域中的所有缓存全部清空！与写操作是否操作的是已缓存记录毫无关系！所以如果是作用域内频繁执行写操作，那么缓存基本没效果</li>
<li>因为一级缓存只能感知到 Session 内的写操作，所以容易缓存脏数据，生产环境建议设置为 statement 级别来关闭一级缓存</li>
</ul>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存：Mapper 级别，需要在 Mapper 映射文件中增加标签：<code>&lt;cache&gt;&lt;/cache&gt;</code>才能生效</p>
<ul>
<li>对于一些写操作频繁的数据的查询操作，可以单独禁用查询语句的二级缓存功能，在 mapper 映射文件的 select 查询中设置<code>useCache=&quot;false&quot;</code></li>
<li>如果涉及到多表级联查询，想要二级缓存生效，需要两个 mapper 映射文件都开启缓存，且通过 cache-ref 标签建连关联，制造一个更大范围的二级缓存。否则关联查询的表如果更新了，缓存不会失效</li>
<li>只要发生了写操作，都会将作用域中的所有缓存全部清空！与写操作是否操作的是已缓存记录毫无关系！所以如果是作用域内频繁执行写操作，那么缓存基本没效果</li>
<li>在分布式环境中，二级缓存因为只缓存在本地，所以依然容易缓存脏数据，不建议开启</li>
</ul>
<p>缓存优先级：二级缓存 &gt; 一级缓存 &gt; 数据库</p>
<h3 id="主动刷新缓存"><a href="#主动刷新缓存" class="headerlink" title="主动刷新缓存"></a>主动刷新缓存</h3><p>因为缓存作用域内的写操作导致全部缓存失效的机制，所以如果写频繁的数据，使用二级缓存其实作用不大。但如果对于查询数据的时效性要求不高，二级缓存就有用武之地，这里推荐使用它的主动刷新缓存机制</p>
<p>1、mapper 映射文件中的写操作 sql，把刷新缓存开关关闭（默认开启）。<code>flushCache=&quot;false&quot;</code></p>
<p>2、mapper 映射文件配置主动刷新缓存。<code>&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;1000 size=&quot;512&quot; readOnly=&quot;true&quot;&quot;&gt;&lt;/cache&gt;</code></p>
<ul>
<li>flushInterval：刷新间隔，单位毫秒</li>
<li>size：缓存队列大小，默认 1024</li>
<li>eviction：缓存在队列空间不够时的淘汰策略。FIFO 即先入先出，常用的还有 LRU 最近最少使用</li>
<li>readOnly：true 表示只读，查询到的 DO 对象不能做写操作。底层返回给调用者的只是 DO 对象的引用，因此有性能优势</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习JVM</title>
    <url>/2020/06/22/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0JVM/</url>
    <content><![CDATA[<h1 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>JVM 将内存划分为哪几个区域？每个区域的作用是？</p>
<ul>
<li>主要是堆空间、方法区、虚拟机栈区</li>
<li>堆空间存储对象实例数据。方法区存储类元数据，例如静态变量。虚拟机栈区是线程维度，按方法维度为每个方法在栈上分配一个栈帧</li>
</ul>
<p>每个栈帧分为哪几个区域？每个区域的作用是？</p>
<ul>
<li>局部变量表：存储局部变量。操作数栈：用于计算。动态链接：存储该方法在方法区的符号引用，用于确定方法的直接引用。</li>
</ul>
<p>堆中为对象分配内存有哪两种方法？与什么因素有关？</p>
<ul>
<li>指针碰撞和空闲队列。堆内存规整，即 JVM 垃圾回收时做了整理操作，可用指针碰撞法，否则使用空闲队列法。</li>
</ul>
<p>堆中为对象分配内存空间如何保证线程安全？</p>
<ul>
<li>CAS 重试或 TLAB，提前为线程分配一块内存空间</li>
</ul>
<p>对象在内存中包含哪几个区域？对象头存储哪些数据？</p>
<ul>
<li>对象头、实例数据、对齐填充。对象头存储 MarkWord(分代年龄、hashcode、线程相关信息)、类型指针。</li>
</ul>
<p>访问对象有哪两种方式？各自的优缺点是？Hotspot 虚拟机使用哪种方式？</p>
<ul>
<li>句柄访问、直接访问。Hotspot 使用直接访问。</li>
</ul>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p><img src="/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有的内存空间，如果线程执行的是JAVA代码，计数器记录的是将要执行的<code>字节码指令地址</code>，如果是Native方法，计数器值为空。<br>程序计数器在<code>线程切换</code>时将里面的指令地址缓存在CPU的缓存里。等下次线程重新被调度执行时，CPU从缓存再读到自己的程序计数器里就能继续向下执行线程</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈是线程私有的，每创建一个线程，虚拟机就会为这个线程创建一个虚拟机栈，虚拟机栈的生命周期和线程是相同的</p>
<p>虚拟机栈表示 Java 方法执行的内存模型，每调用一个方法就会为每个方法生成一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口（调用方程序计数器）等信息</p>
<p>每个方法被调用和完成的过程，都对应一个栈帧从虚拟机栈上入栈和出栈的过程</p>
<p>方法执行完成后可能执行的操作包括：</p>
<ul>
<li>恢复调用方所属栈帧的局部变量表和操作数栈</li>
<li>返回值压入调用方栈帧的操作数栈</li>
<li>调整调用方程序计数器的值，指向调用方的下一条指令地址</li>
</ul>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存储方法参数和方法内定义的局部变量</p>
<p>局部变量表的大小在编译时就已经确定。存储变量的最小内存单元称为 slot，每个 slot 占 4 字节，对 64 位机器，JVM 会以高位对齐的方式分配两个连续 slot 空间（long、double 本身需要 8 字节，占据两个 Slot）</p>
<p>运行期间不会改变局部变量表的大小</p>
<p>访问局部变量表使用 slot 索引</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>顾名思义，在方法内部执行计算时用到操作数栈，是一个 LIFO 栈</p>
<p>栈深度在编译时就已经确定</p>
<p>虽然概念上，不同栈帧是相互独立的，但 JVM 在实现里做了一些优化，让下栈帧的部分操作数栈与上栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量区该栈帧所属方法的引用，目的是支持方法调用过程中的动态连接（运行时确定方法符号引用的直接引用）</p>
<h4 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h4><p>返回地址为调用方下一条指令地址，在方法执行完后，将返回地址写入程序计数器，使得线程可以继续执行调用方后面的指令</p>
<p>每个方法被调用和完成的过程，都对应一个栈帧从虚拟机栈上入栈和出栈的过程</p>
<p>方法执行完成后可能执行的操作包括：</p>
<ul>
<li>恢复调用方所属栈帧的局部变量表和操作数栈</li>
<li>返回值压入调用方栈帧的操作数栈</li>
<li>返回地址写入程序计数器，让调用方继续向下执行指令</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>各个线程共享，存放对象实例</p>
<p>堆中没有空间分配对象实例，就会抛出 OutOfMemoryError</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>各个线程共享，存储类信息、常量、静态变量等数据</p>
<p>方法区没有内存空间可分配时，就会抛出 OutOfMemoryError</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>属于方法区的一部分</p>
<p>类加载时，将 class 文件常量池里的字面量和符号引用放入运行时常量池</p>
<p>在类加载的解析阶段，会将一部分符号引用替换为直接引用</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>DirectMemory，并非 JVM 启动后占用的内存，可以简单理解为 Native 使用的内存。这部分内存在应用程序使用 NIO 技术时会被使用到。</p>
<p>NIO 可以通过 Native 方法直接分配 DirectMemory，然后通过在堆中的 DirectByteBuffer 对象作为这块内存的引用来进行操作。这样能在一些场景中显著提高性能，因为避免了在 JAVA 堆和 Native 堆中来回复制数据。</p>
<p>特别需要注意，DirectorMemory 内存不足时，JVM 也会抛出 OOM!不过 FullGC 时也会对这部分空间进行垃圾回收，但区别是当这块内存不足时，不会主动触发 GC</p>
<h2 id="对象在-JVM-的创建过程"><a href="#对象在-JVM-的创建过程" class="headerlink" title="对象在 JVM 的创建过程"></a>对象在 JVM 的创建过程</h2><ul>
<li>方法区中判断类是否已被加载，如果未加载，先进行类加载</li>
<li>基于类信息在堆中分配内存<ul>
<li>分配内存有两种方法：指针碰撞（适用已分配和未分配空间连续，依赖 GC 收集器是否支持压缩过程）、空闲队列（适用于已分配和未分配空间不连续）<ul>
<li>假设 JVM 堆中内存是规整的，所有用过的内存放在一边，没用过的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存的过程就仅仅是把那个指针向空闲空间的方向挪动一段与对象大小相等的距离，这种分配方式被称为”指针碰撞”</li>
<li>如果 JVM 堆中的内存不是规整的，使用过的内存空间与未使用的内存空间相互交错，那就没办法进行简单的“指针碰撞”了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，分配的时候在列表中找到一段足够大的内存空间分配给对象实例，并更新列表中的记录，这种分配方式被称为”空闲列表”</li>
<li>可见，选择哪种内存分配方式由 JVM 堆内存是否规整决定，而 JVM 堆内存是否规整又由所采用的垃圾收集器是否有整理过程所决定</li>
</ul>
</li>
<li>分配内存过程需要保证原子性<ul>
<li>一种保证原子性的方式是 CAS 重试</li>
<li>另外一种方式是提前为线程预制一块私有内存空间 TLAB(ThreadLocalAvailableBuffer)，需要在 java 进程启动中增加<code>-XX:+/-UseTLAB</code>参数来设定</li>
</ul>
</li>
</ul>
</li>
<li>分配完成后，分配到的内存空间会默认初始化为零值</li>
<li>设置对象头信息（包括哈希值、所属类元数据、GC 分代年龄等）</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="/JVM/JAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg"></p>
<p>分为对象头、实例数据、对齐填充（占位符，满足对象起始地址是 8 字节的整数倍）。重点看下对象头。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>包含两部分。第一部分存储运行时数据，如哈希值、GC 分代年龄、线程相关信息等，官方称为<code>MarkWord</code>。第二部分存储类型指针，即指向类元数据的指针。</p>
<h2 id="访问对象的方式"><a href="#访问对象的方式" class="headerlink" title="访问对象的方式"></a>访问对象的方式</h2><p>线程执行过程中，通过栈帧中局部变量表的对象引用来访问堆中的对象实例</p>
<p>JVM 有两种对象访问方式，对应栈帧存储的对象引用有两种情况：</p>
<ul>
<li>存储句柄的地址<ul>
<li>通过句柄访问。句柄池（堆中的一块内存空间）中存储对象实际的地址，线程通过句柄间接访问对象。好处是在对象移动时（GC 时对象位置会移动），只需要改变句柄池中对象的地址，无需改变栈帧中的引用地址</li>
</ul>
</li>
<li>存储对象的地址（HotSpot 使用的就是这种方式）<ul>
<li>通过指针直接访问堆中的对象。速度更快。</li>
</ul>
</li>
</ul>
<h2 id="StackOverflowError-和-OutOfMemoryError"><a href="#StackOverflowError-和-OutOfMemoryError" class="headerlink" title="StackOverflowError 和 OutOfMemoryError"></a>StackOverflowError 和 OutOfMemoryError</h2><p>基于上文的描述，JVM 占用的内存空间基本被堆、栈和方法区占据</p>
<p>当栈空间不满足线程执行的内存需求时，会抛出 StackOverflowError，但如果增大栈容量，在多线程情况下，也容易产生内存耗尽 OutOfMemoryError</p>
<p>因此这是一个博弈的过程，在多线程场景下，只能通过减少最大堆和减少栈容量来换取更多线程</p>
<hr>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>JVM 垃圾回收通常作用于堆空间，因为栈空间在编译期就已经确定内存分配大小，随线程的生命周期创建和回收，不需要考虑运行期动态分配和回收问题。而方法区回收性价比低。</p>
<p><img src="/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png"></p>
<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><p>引用计数器法如何判断对象是否存活？该方法有什么问题？</p>
<ul>
<li>对象被引用，计数+1，引用失效，计数-1。循环引用的对象无法被 gc</li>
</ul>
<p>可达性分析法如何判断对象是否存活？哪些节点可以作为 GC ROOTS？</p>
<ul>
<li>枚举 GCRoots，从 ROOTS 节点出发可达的对象判断为存活。栈帧中局部变量表里引用的对象、方法区中的全局对象可作为 GCRoots</li>
</ul>
<p>什么是强引用、软引用、弱引用？他们与 GC 有什么关系？</p>
<ul>
<li>new 出来的对象是强引用。强引用指向的对象不会被 GC。只被软引用 SoftReference（对象）指向的对象，如果内存空间不足时会被 GC。只被弱引用 WeakReference 指向的对象，下次 GC 时被回收。</li>
</ul>
<p>GC 的标记清楚算法有什么问题？</p>
<ul>
<li>内存碎片化</li>
</ul>
<p>什么是 GC 的复制算法？该算法有什么问题？</p>
<ul>
<li>内存均分为两部分，只在一半的内存空间分配对象，GC 时将存活的对象复制到另一半空间，再清空之前使用的那一半空间</li>
</ul>
<p>HotSpot 使用什么 GC 算法？为什么要有两个 survivor 区？</p>
<ul>
<li>改进版的复制算法。将内存空间分为 Eden 区和两个 Survivor 区，比例 8:1:1。只在 Eden 区分配内存，GC 时将 Eden 取和 Survivor 区存活的对象复制到另一个 Survivor 区，再清空这两部分空间</li>
<li>两个 Survivor 区避免 GC 产生内存碎片化。假设只有一个 Survivor，GC 时必然产生碎片化，Eden 区存活的对象复制到 Survivor 区还是不能填补这些碎片空间。</li>
</ul>
<p>为什么 GC 时，JVM 要停止所有线程？</p>
<ul>
<li>因为保证枚举的 GCRoots 准确性的前提是获取全局一致性的内存空间快照，所以要停止所有线程。</li>
</ul>
<p>为了避免枚举 GC ROOTS 时扫描全栈，HotSpot 是怎么优化的？</p>
<ul>
<li>类加载完成后，计算得到对象什么偏移量上存的是引用类型数据</li>
<li>JIT 编译阶段，在一些安全点上记录栈帧中哪些位置存的是对象引用，避免全栈扫描</li>
</ul>
<p>GC 的安全点一般选在什么时候？如何在安全点中断线程？</p>
<ul>
<li>方法调用、循环跳转、异常跳转</li>
<li>设置中断标志，线程在安全点会主动取这个标志，如果为真就停止线程等待 GC</li>
</ul>
<p>Parallel Scavenge 收集器有什么优势？CMS 收集器有什么优势和缺陷？</p>
<ul>
<li>并行收集器服务于新生代。优势是能自适应调节 GC 策略，以提供最大的吞吐量或最合适的停顿时间</li>
<li>CMS 收集器服务于老年代。优势是能最大程度减少 FullGC 时间，缺陷是内存碎片化问题、FullGC 和线程运行并行执行导致对象进入老年代时空间不足、和业务线程共同竞争 CPU</li>
</ul>
<h2 id="不同语言的垃圾回收方式"><a href="#不同语言的垃圾回收方式" class="headerlink" title="不同语言的垃圾回收方式"></a>不同语言的垃圾回收方式</h2><ul>
<li>C\C++\汇编语言，他们都需要程序员自己手动释放内存，因此开发效率不高，且容易出现野指针（变量指向的内存空间数据被修改或回收）。但执行效率高，因为不需要单独运行垃圾回收线程。</li>
<li>java\go\python等语言，引入了GC（垃圾回收器）概念，运行专门的垃圾回收线程。因此程序员只负责分配内存，开发效率更高，但执行效率不高。</li>
<li>rust是一种既能保证较高执行效率，且程序员不用关心垃圾回收的语言。它提出一种ownership思想，堆上分配的对象只会被线程栈帧上的一个变量指向，因此栈帧出栈时就可以垃圾回收。但rust的学习门槛很高。</li>
</ul>
<h2 id="定位垃圾对象的算法"><a href="#定位垃圾对象的算法" class="headerlink" title="定位垃圾对象的算法"></a>定位垃圾对象的算法</h2><p>如果对象不再被引用，则认为是垃圾对象，GC时被回收。Java使用根可达算法判断对象是否被引用，python使用引用计数。</p>
<ul>
<li>引用计数<ul>
<li>对象被引用+1，引用失效-1，简单高效</li>
<li>无法解决相互循环引用问题（A、B都不会被其他对象访问，但A和B互相持有对方引用，造成GC无法回收A、B）</li>
</ul>
</li>
<li>根可达算法<ul>
<li>一些<code>GC ROOTS</code>节点作为起点，当所有引用链都无法触达对象时，该对象可被GC。HotSpot使用这种机制。<ul>
<li>可被作为<code>GC ROOTS</code>节点的对象包括：栈帧的局部变量表中引用的对象、方法区中引用的常量、静态对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意，上述机制如果判断对象不被引用后，JVM 在 GC 前还会执行对象的 finalize 方法（只会执行一次，下次 GC 时不会再次执行），如果方法里对象重新被引用，则不会被 GC，否则被 GC</p>
<h2 id="对象引用类型"><a href="#对象引用类型" class="headerlink" title="对象引用类型"></a>对象引用类型</h2><p>对象引用类型不同，垃圾回收的时机也不同。</p>
<ul>
<li>强引用（描述特别有用的对象），类上没有特殊声明，创建的都是强引用对象，只有对象不被引用时才被GC</li>
<li>软引用SoftReference（描述有用但非必要的对象）指向的对象在将要发生OOM时才会被GC，即使这时还被引用</li>
<li>弱引用WeakReference（描述非必要的对象）指向的对象在下一次GC时会被回收，即使这时还被引用</li>
<li>虚引用PhantomReference指向的对象在对象被GC时，引用方能收到系统通知</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>JVM对内存空间使用分代模型划分为年轻代和老年代，年轻代的垃圾回收称为YGC，老年代称为FGC。且年轻代和老年代使用的垃圾回收算法不同。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>对标记为垃圾的对象原地回收，清除后产生大量内存碎片，内存空间利用率低。因此实际不使用这种算法。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>年轻代的GC算法。</p>
<p>原始的复制算法将内存等分成两部分，新创建的对象只在其中一半的区域分配内存，回收时将存活的对象复制到另一半空的内存，然后清除之前分配内存的一半空间。问题是永远只能利用50%的内存空间，太浪费。</p>
<p>但实际生产中，98%的对象都会在下次GC时被回收。因此复制算法做了改进。将内存空间分为Eden区和两个Survivor区，比例是8：1：1。每次使用Eden区和其中一个Survivor区，新对象在Eden区分配内存，每次GC时将Eden和Survivor区还存活的对象复制到另一个Survivor区，再清空Eden区和上次使用的Survivor区。<br>使用两个Survivor区的作用是避免内存碎片化。假设使用一个，每次gc，回收survivor区的对象会产生碎片，把eden区存活的对象复制到survivor区无法插入这些碎片化的内存空间里，造成内存碎片化。</p>
<p>如果GC时存活下来的对象超过Survivor空间容量（10%），或者存活对象年龄达到阈值，对象被移动到老年代。</p>
<h3 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h3><p>老年代的GC算法。</p>
<p>标记清除完之后，将所有的存活对象压缩到内存的一端。避免了碎片的产生，但性能较差，因此适用于老年代。因为老年代不会频繁GC，年轻代因为要频繁为对象分配内存，所以会频繁GC，因此更适合复制算法，性能更好。</p>
<h2 id="HotSpot对根可达算法的性能优化"><a href="#HotSpot对根可达算法的性能优化" class="headerlink" title="HotSpot对根可达算法的性能优化"></a>HotSpot对根可达算法的性能优化</h2><p>HotSpot是最常用的JVM。</p>
<h3 id="枚举GC-ROOTS"><a href="#枚举GC-ROOTS" class="headerlink" title="枚举GC ROOTS"></a>枚举GC ROOTS</h3><p>上文说过，Java定位垃圾对象使用根可达算法。该算法必须保证在一致性的快照中进行。否则定位的准确性无法保证，因此在定位垃圾对象时需要停止所有线程，即STW（stop the world）</p>
<p>根可达算法需要找到GC时刻所有的GC ROOTS，如果全栈扫描所有栈帧来获取对象引用以及遍历方法区获取全局引用，效率太低</p>
<ul>
<li>类加载完成后，计算得到对象什么偏移量上存的是引用类型数据</li>
<li>JIT 编译过程中，在特定位置（某些指令执行处，称为<code>安全点</code>）记录下栈帧中哪些位置是引用，避免全栈扫描<ul>
<li>这些记录存在<code>OopMap</code>（ordinary object pointer）这种数据结构中，GC 时通过 OopMap 可以快速枚举所有 GC ROOTS</li>
<li>设置安全点也是为了减少 OopMap 的存储开销，不可能每个指令都对应有 OopMap</li>
</ul>
</li>
</ul>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>可以理解为，JVM 只会在安全点执行 GC，而安全点选取的多少对程序运行有直接影响。安全点太少的话 GC 间隔太久，太多影响程序性能（GC 时停止所有线程）。</p>
<p>安全点的选取准则是具有让程序长时间执行的特征，换句话说需要在程序执行告一段落时才选取为安全点。因此一般选取<code>方法调用、循环跳转、异常跳转</code>这些指令处作为安全点。</p>
<p>既然 GC 时需要中断所有线程，那 HotSpot 是如何实现呢？答案是需要 GC 时，设置中断标志，线程在安全点会主动取这个标志，如果为真就停止线程等待 GC</p>
<h2 id="JVM垃圾回收器"><a href="#JVM垃圾回收器" class="headerlink" title="JVM垃圾回收器"></a>JVM垃圾回收器</h2><p>根据分代模型，JVM将堆空间分为年轻代和老年代，在这两部分空间使用的垃圾回收器各不相同，但一般都是配对使用</p>
<h3 id="Parallel-Scavenge-amp-amp-Parallel-Old"><a href="#Parallel-Scavenge-amp-amp-Parallel-Old" class="headerlink" title="Parallel Scavenge &amp;&amp; Parallel Old"></a>Parallel Scavenge &amp;&amp; Parallel Old</h3><p>Parallel Scavenge是年轻代的垃圾回收器，Parallel Old是老年代的垃圾回收器。它们简称<code>PSPO</code>，也称为并行垃圾回收器，使用多线程来执行垃圾回收，适合几个G的内存。</p>
<p>PSPO适合高吞吐量（程序运行时间占总时间的比例）的计算密集型业务，不适合需要快速响应的交互型业务</p>
<ul>
<li>减少响应时间和提高吞吐量是矛盾的。举个例子，原来10秒GC一次，耗费100毫秒。现在5秒GC一次，耗费70毫秒，虽然线程STW的时间减少了，响应速度更快，但吞吐量反而更低了</li>
</ul>
<h3 id="ParNew-amp-amp-CMS"><a href="#ParNew-amp-amp-CMS" class="headerlink" title="ParNew &amp;&amp; CMS"></a>ParNew &amp;&amp; CMS</h3><p>ParNew是年轻代垃圾回收器，CMS是老年代。ParNew仍然使用多线程做垃圾回收，不用PS是因为和CMS不适配。这一组垃圾回收器也适合于几个G的内存。</p>
<p>CMS（concurrent mark sweep）是一款以<code>获取最短GC时间</code>为目标的收集器，适合需要快速响应的交互型业务。它也使用标记整理算法做垃圾回收，不过在识别垃圾对象阶段和清除垃圾对象阶段，都能和业务线程并发执行，即不需要STW。它的GC流程为：</p>
<ul>
<li>初始标记（标记GC ROOTS）<ul>
<li>需要STW，但耗时短</li>
</ul>
</li>
<li>并发标记（GC ROOTS TRACING）<ul>
<li>和业务线程并发执行，不需要STW</li>
<li>使用<code>三色标记算法</code>判定对象是否为垃圾对象。它的思想和根可达算法一样，也是顺着ROOT对象往下找，只不过会将对象区分为三类，以便并发标记线程下次被调度时知道该从哪些对象开始继续查找垃圾对象</li>
</ul>
</li>
<li>重新标记<ul>
<li>需要STW，修复并发标记阶段对一些对象是否可回收的错判</li>
</ul>
</li>
<li>并发清除<ul>
<li>和业务线程并发执行，不需要STW</li>
</ul>
</li>
</ul>
<p>当然，CMS也有一些缺陷：</p>
<ul>
<li>CPU资源敏感，如果用户线程吃CPU资源（计算密集型服务），使用CMS会因为并发竞争CPU资源而降低用户程序性能</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>随着内存越做越大，几十G的内存出现后，采用分代模型的垃圾回收器，做一次YGC的STW时间越来越久，因此诞生了不使用分代模型的G1垃圾回收器。它适合几十G的内存。</p>
<p>G1使用分区的思想，将内存划分为很多块小的区域。虽然G1物理上对内存没有使用分代模型来划分，但是逻辑上依然使用了分代的思想，将每块区域设置为Eden区、Survivor区和Old区的一种。因为年轻代老年代的内存空间变小了，所以GC的速度自然就变快了，当然GC的频率也肯定更高。</p>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="JVM启动参数"><a href="#JVM启动参数" class="headerlink" title="JVM启动参数"></a>JVM启动参数</h2><ul>
<li>-Xms4g<ul>
<li>最小堆大小，例如设置为4g</li>
</ul>
</li>
<li>-Xmx4g<ul>
<li>最大堆大小，例如设置为4g</li>
<li>最小堆大小和最大堆大小通常设为一样，避免扩缩容产生内存抖动。生产环境中建议4G</li>
</ul>
</li>
<li>-Xmn2g<ul>
<li>年轻代大小，例如设置为2g</li>
</ul>
</li>
<li>-XX:SurvivorRatio&#x3D;8<ul>
<li>年轻代Eden和Survivor的比值。注意有2个Survivor，所以如果设为8，表示8:1:1</li>
</ul>
</li>
<li>-XX:MaxDirectMemorySize&#x3D;1g<ul>
<li>最大直接内存，单位字节。NIO中ByteBuffer会用到直接内存实现零拷贝来提升IO性能</li>
</ul>
</li>
<li>-XX:+UseConcMarkSweepGC<ul>
<li>使用CMS，这时也会伴随设置年轻代垃圾回收器：-XX:+UseParNewGC</li>
</ul>
</li>
<li>-XX:+PrintGC<ul>
<li>打印GC日志</li>
</ul>
</li>
<li>-Xloggc:&#x2F;home&#x2F;admin&#x2F;me&#x2F;logs&#x2F;gc.log<ul>
<li>GC日志文件</li>
</ul>
</li>
<li>-XX:+HeapDumpOnOutOfMemoryError<ul>
<li>OOM时自动生产堆转储文件</li>
</ul>
</li>
</ul>
<h2 id="JVM调优常用命令"><a href="#JVM调优常用命令" class="headerlink" title="JVM调优常用命令"></a>JVM调优常用命令</h2><ul>
<li>jps<ul>
<li>查询所有JAVA进程和对应的进程id</li>
</ul>
</li>
<li>jinfo ${java进程id}   <ul>
<li>查询某个JAVA进程的schema，例如系统配置、JVM启动参数</li>
</ul>
</li>
<li>jstack ${java进程id} | more<ul>
<li>查询某个JAVA进程的所有线程信息，包括线程名、优先级、线程状态和调用堆栈</li>
</ul>
</li>
<li>top<ul>
<li>查询运行的进程占CPU和内存的情况，按占用CPU由大到小排序</li>
</ul>
</li>
<li>top -Hp ${java进程id}   <ul>
<li>查询某个Java进程中的线程占CPU和内存的情况，按占用CPU由大到小排序</li>
</ul>
</li>
<li>jmap -histo ${java进程id} | head -20<ul>
<li>按类的维度查询类产生了多少个实例对象以及占内存大小，按占据内存大的取前20个</li>
<li>jmap会产生STW，生产环境不能用</li>
</ul>
</li>
<li>jmap -dump:format&#x3D;b,file&#x3D;xxx.hprof<ul>
<li>把JVM的整个堆转储为一个文件，再使用工具对文件做离线分析</li>
<li>堆文件分析工具：jvisualvm（JDK自带）、jhat</li>
<li>jmap会产生STW，生产环境不能用</li>
<li>生产环境设置JVM启动参数“-XX:+HeapDumpOnOutOfMemoryError”</li>
</ul>
</li>
</ul>
<h2 id="如何模拟实际生产环境做JVM调优"><a href="#如何模拟实际生产环境做JVM调优" class="headerlink" title="如何模拟实际生产环境做JVM调优"></a>如何模拟实际生产环境做JVM调优</h2><p>上面说的jmap命令会产生STW，影响接口性能，生产环境不能用，所以需要模拟实际生产环境，以便执行jmap做堆分析。具体有这么几种方式：</p>
<ul>
<li>在测试机上做压测</li>
<li>在生产环境的负载均衡中剔除掉问题机器</li>
<li>用tcpcopy把线上流量打到测试机，模拟线上真实流量</li>
</ul>
<h2 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h2><p>下载arthas：<code>curl -O https://arthas.aliyun.com/arthas-boot.jar</code><br>执行arthas：<code>java -jar arthas-boot.jar</code>，然后选择将arthas挂载到哪个java进程</p>
<p>arthas常用命令：</p>
<ul>
<li>dashboard<ul>
<li>查看堆内存、GC、线程的CPU占用率等信息</li>
</ul>
</li>
<li>thread<ul>
<li>查看所有线程信息，包括CPU占用率、线程状态等</li>
<li><code>thread -b</code>查看是否有线程发生了死锁</li>
</ul>
</li>
<li>jvm <ul>
<li>和<code>jinfo</code>类似，查看虚拟机相关信息，包括虚拟机名称、厂商、类路径、使用什么垃圾回收器等</li>
</ul>
</li>
<li>jad ${类名}<ul>
<li>反编译类，还能输出类在classpath下的路径和类使用的加载器</li>
</ul>
</li>
<li>redefine ${class文件路径}<ul>
<li>热部署class类。如果不想修改类后重新部署整个工程，可以在IDEA修改类后”Build-recompile xx.java”来本地编译类文件，然后用redefine命令执行热部署</li>
</ul>
</li>
<li>trace ${类目} ${方法名}<ul>
<li>跟踪一个方法内部各个调用的执行时间</li>
</ul>
</li>
</ul>
<h2 id="JVM调优经验"><a href="#JVM调优经验" class="headerlink" title="JVM调优经验"></a>JVM调优经验</h2><ul>
<li>尽量避免使用大内存（超过4G，需64位JDK来支持）。这可能造成FullGC特别耗时（堆空间太大）、发生OOM时无法Dump堆快照（堆空间太大，dump文件几十G，难以存储和分析）、内存资源较32位机器而言消耗更多<ul>
<li>解法是创建多个32位（最大4G内存）虚拟机，保证FullGC的停顿时间可控</li>
</ul>
</li>
<li>存在大量NIO操作时，如果DirectMemory内存空间较少，也可能产生OOM</li>
<li>用户程序中不要调用<code>Runtime.getRuntime().exec()</code>，该方法会创建进程，频繁创建进程非常消耗CPU、内存资源</li>
<li>存储大量数据时不要使用HashMap，内存利用率太低，容易占满堆空间产生OOM</li>
</ul>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p><img src="/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png"></p>
<h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p>类加载发生的时机有哪些？</p>
<ul>
<li>new、Class.forName 反射调用、访问类的静态变量或静态方法</li>
</ul>
<p>类加载包括哪几个阶段？每个阶段的作用是？</p>
<ul>
<li>加载，把.class 字节码加载到 JVM，在方法区生成 class 对象并分配内存空间。</li>
<li>验证，验证加载的字节码的安全性</li>
<li>准备，为类的静态变量赋初值</li>
<li>解析，将方法区的符号引用替换为直接引用</li>
<li>初始化，执行静态代码块，并将类的静态变量赋实际的值</li>
</ul>
<p>什么是静态解析和动态连接？</p>
<ul>
<li>静态解析，指在类加载阶段将方法的符号引用替换为实际的调用地址。动态链接指在运行期间确定并替换方法的符号引用为实际的调用地址</li>
</ul>
<p>什么是非虚&#x2F;虚方法？哪些方法是非虚&#x2F;虚方法？</p>
<ul>
<li>非虚方法可以静态解析，虚方法只能动态链接。非虚方法包括静态方法、私有方法，虚方法指实例方法</li>
</ul>
<p>什么是解析调用？什么是分派调用？</p>
<ul>
<li>调用非虚方法，称为解析调用。调用虚方法，称为分派调用</li>
</ul>
<p>为什么说 JAVA 是一门支持静态多分派、动态单分派的语言？</p>
<ul>
<li>所谓静态多分派，即需要知道多个宗量才能在编译期确定要调用的虚方法。典型应用就是方法重载。所谓动态单分派，指在运行期才能根据单宗量确定要调用哪个虚方法。典型应用就是方法重写。宗量指的是方法调用者和方法参数。</li>
</ul>
<p>什么是双亲委派模型？作用是？</p>
<ul>
<li>优先委托父加载器进行类加载，称为双亲委派模型。作用是实现了 Java 自带的核心类库只会被 JVM 提供的 bootstrap 和扩展类加载器加载，保证 Java 应用的安全性</li>
</ul>
<p>线程上下文加载器的作用是？有什么使用案例？</p>
<ul>
<li>Spi 应用场景中，核心类要加载第三方应用的实现类，而核心类是用父级加载器加载的，因此按双亲委派模型，无法加载到第三方应用的实现类。这时可以通过线程上下文加载（应用加载器）来加载，打破双亲委派模型。应用场景：1、JDBC 加载第三方实现的驱动 Driver 类，使用 ServiceLoader 实现，它内部使用的就是线程上下文加载器。2、Spring 框架加载应用里定义的 bean，也使用了线程上下文加载器。</li>
</ul>
<p>Tomcat 使用哪些类加载器？他们各自的作用和相互之间的父子关系是？</p>
<ul>
<li>commonCL：加载 tomcat 容器和 web 应用公共的类。catalinaCL：加载只被 tomcat 容器使用的类，对 web 应用不可见。sharedCL：加载所有 web 应用公共的类。webappCL：加载 web 应用自身的类。</li>
<li>tomcat 类加载器使用标准的双亲委派模型实现类加载和隔离。commonCL 是 catalinaCL 和 sharedCL 的父加载器。sharedCL 是 webappCL 的父加载器。</li>
</ul>
<h2 id="类加载的几个阶段"><a href="#类加载的几个阶段" class="headerlink" title="类加载的几个阶段"></a>类加载的几个阶段</h2><p>JAVA语言在运行期执行类加载</p>
<p>类在JVM的生命周期为：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载，其中“加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化”称为类加载阶段</p>
<p>通常发生以下操作时（JVM称之为对类的主动引用），如果类还未加载，会触发类加载流程</p>
<ul>
<li>new一个对象</li>
<li>类的静态属性或方法被访问(非final类型，final类型在编译期已经优化到常量池中访问，不会触发类的初始化)</li>
<li>对类进行反射调用</li>
<li>子类被初始化前会触发父类初始化</li>
</ul>
<p>下面具体介绍类加载每个阶段的功能</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>基于类的全限定名获取类的class文件字节码（由类加载器实现），JVM将字节码转化为静态数据结构存储在方法区内，最后在堆中生成一个Class对象供用户调用</p>
<ul>
<li>字节码包含类的元信息、静态变量、常量（例如final变量值和符号引用）。其中常量存储在运行时常量池<ul>
<li>JDK8以前，使用“永久代”这种堆内存作为方法区</li>
<li>从JDK8开始，使用“元空间”这种直接内存作为方法区，且只存储类的元信息，将类的静态变量和运行时常量池都放到了堆中</li>
</ul>
</li>
<li>加载前JVM会验证字节码文件格式，例如著名的4字节“cafe babe”魔数</li>
</ul>
<p>程序员可以通过自定义类加载器来灵活控制获取class字节码的方式：</p>
<ul>
<li>zip压缩包获取，jar、war包里的类就是这种加载方式</li>
<li>网络获取</li>
<li>运行时计算生成字节流，动态代理就是这种加载方式</li>
</ul>
<p>当同一个类由两个不同类加载器加载，这两个类认为是不相等的（equals、isAssignableFrom、instanceOf 等方法都返回 False）</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>虽然JAVA编译后生成的字节码class文件，虚拟机加载它相对安全，但class文件依然可以不由java源码编译生成，甚至可以直接十六进制编写字节码，因此虚拟机仍然很有必要对字节码进行验证，保证JVM能安全稳定地运行</p>
<ul>
<li>这里的验证更多是对数据安全性的验证，上面说的加载阶段是对字节码格式的验证</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类的静态变量分配内存并赋默认值</p>
<ul>
<li>如若同时被final修饰，准备阶段就会分配从常量池获取的值</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段将运行时常量池内的符号引用转化为直接引用，也称为<code>静态解析</code>。如果此时不能转为直接引用，需要在运行期再根据调用栈中的实际内存地址替换符号引用，称为<code>动态连接</code>。Java的多态底层就是用动态连接实现的</p>
<ul>
<li>符号引用：描述引用的类和接口的全限定名的字符串</li>
<li>直接引用：引用的类和接口的实际内存地址<ul>
<li>类的静态方法、私有方法、构造方法、final方法可以在类加载阶段直接确定内存地址，即可以静态解析。这些方法也称为非虚方法</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>为类的静态变量赋值，执行类的静态代码块。注意构造方法不会在这里执行，只有new对象时才会执行构造方法</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>类加载逻辑遵循双亲委派模型，即加载 class 时，所有的类加载器都会先委托父加载器进行类加载，只有父加载器加载失败，才会自己尝试加载类。这种设计保证了 jdk 的核心类只会被启动加载器 bootstrap 加载，保证了 java 应用程序的安全</p>
<p>类加载器的层级结构从父到子依次是：<code>bootstrap启动加载器-扩展加载器-应用加载器-用户自定义加载器</code></p>
<p>双亲委派模型的实现写在 ClassLoader 的 loadClass 方法，用户实现的自定义类加载的加载逻辑需要重写 findClass 方法，该方法在 loadClass 方法里被回调</p>
<p>双亲委派模型使得类加载满足先父后子这样的加载层级关系，但这种关系也是一种约束。例如 JNDI 服务的代码由 bootstrap 加载，但代码里又需要加载业务方的 SPI，显然 bootstrap 是加载不到的，只能由应用加载器来加载。因此 JAVA 引入了<code>线程上下文加载器</code>，通过当前线程来获取，默认就是应用加载器。因此通过线程上下文加载器，就可以加载 SPI，但这也打破了双亲委派模型的原则</p>
<blockquote>
<p>JNDI：Java 命名与目录接口（Java Naming and Directory Interface），简单理解 JNDI 服务的作用就是通过配置文件对资源（例如 MySQL 链接参数、业务方 SPI 实现类路径）进行命名，然后再根据名字来找资源</p>
</blockquote>
<h2 id="类加载案例"><a href="#类加载案例" class="headerlink" title="类加载案例"></a>类加载案例</h2><h3 id="tomcat-类加载器架构"><a href="#tomcat-类加载器架构" class="headerlink" title="tomcat 类加载器架构"></a>tomcat 类加载器架构</h3><p>tomcat 的类加载架构：使用正统的双亲委派模型实现，父子关系描述如下：</p>
<ul>
<li>common 类加载器<ul>
<li>catalina 类加载器</li>
<li>shared 类加载器<ul>
<li>webapp 类加载器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>common 类加载器的父加载器是应用加载器。</p>
<p>common 类加载器负责加载所有 web 应用和 tomcat 容器共用的类库。这些类库放置在&#x2F;common 目录下</p>
<p>catalina 类加载器负责加载只被 tomcat 使用的类库，对所有 web 应用不可见。这些类库放置在&#x2F;server 目录下</p>
<p>shared 类加载器负责加载被所有 web 应用共享的类库。这些类库放置在&#x2F;shared 目录下</p>
<p>webapp 类加载器负责加载尽可以被 web 应用使用的类库。这些类库放置在&#x2F;WebApp&#x2F;WEB-INF 目录下。如果有多个 web 应用，就存在多个 webapp 类加载器</p>
<p>如果多个 web 应用都共用 Spring 框架，那么对 Spring 框架的加载会交给 shared 类加载器或 common 类加载器，但 Spring 要加载 web 应用的类，那么如何加载不在其加载范围的类库呢？其实就是通过上面介绍的<code>线程上下文加载器</code>来获取 webapp 类加载器</p>
<h3 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h3><p>OSGi 中的模块（Bundle）类似 Java 类库，都可以打成 Jar 包。区别是 Bundle 中可以声明依赖的 package 也可以声明导出的 package，且每个 Bundle 有自己的类加载器，Bundle 间的类加载器是平级关系，一个 Bundle 加载器既可以被其他 Bundle 加载器使用，也可以使用其他其他 Bundle 加载器。因此可以实现模块级的热插拔功能，但也增加了类加载的复杂度，容易产生死锁。</p>
<p>OSGi 类加载产生死锁：BundleA 和 BundleB 类加载时互相依赖彼此的类加载器，且 loadClass 是一个同步方法，会对类加载器加锁，所以这两个类加载器都在等待对方处理自己的类加载请求，产生死锁。</p>
<h3 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h3><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>动态代理在运行时使用字节码生成技术生成代理类。</p>
<p>参考：<br><a href="https://blog.csdn.net/Scplove/article/details/52451899">https://blog.csdn.net/Scplove/article/details/52451899</a><br><a href="https://blog.csdn.net/zhangqiluGrubby/article/details/61919622">https://blog.csdn.net/zhangqiluGrubby/article/details/61919622</a></p>
<p>JDK 动态代理 ：委托类必须实现接口，对没有实现接口的类不能 JDK 动态代理。</p>
<p>委托类被动态代理的方法包括：接口方法、hashCode、equals、toString</p>
<p>动态体现在：</p>
<ul>
<li>运行时动态生成代理类$ProxyN</li>
<li>代理类不与委托类有任何绑定关系，代理类可以代理任意委托类（委托类必须实现接口），因此可以灵活复用于各种委托类的应用场景中。这是和静态代理最本质的区别</li>
</ul>
<p>应用场景：</p>
<ul>
<li>Spring 使用动态代理对 bean 增强</li>
</ul>
<p>除了 jdk 动态代理外，还有一种动态代理技术：CGLIB 动态代理。它针对类来实现代理，对指定目标类产生一个子类，通过方法拦截技术，拦截所有父类方法调用。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>所谓静态，即代理类和委托类的代理关系在编译前就已经确定。</p>
<p>代理类和委托类都实现相同接口或继承相同的父类，用户手动实现代理类，通过聚合的方式在代理类中聚合委托类，实现接口代理。</p>
<h1 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h1><p>这一块只做了解。</p>
<p>定义：在运行期进行类型检查的语言称为<code>动态语言</code>。相对的，编译期进行类型检查的语言称为<code>静态语言</code>。JAVA 是静态语言</p>
<p>动态语言和静态语言的另一个显著区别是：动态语言的变量无类型，变量值才有类型（联想 JS）</p>
<p>JVM 对动态语言的支持一直存在缺陷，主要表现在方法调用上</p>
<p>JVM 方法调用的第一个参数必须是方法的符号引用，而符号引用在编译期确定，即编译期就需要知道调用方类型，这与动态语言在编译期不 care 类型的特点冲突。动态语言在运行时才能真正知道方法调用方的类型。</p>
<p>JDK 从 1.7 开始真正支持动态语言特性。</p>
<ul>
<li>在方法调用时，提供了一种不依赖符号引用确定目标方法的机制，称为 MethodHandle。可以在运行期才能确定调用方类型。</li>
</ul>
<h1 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><p>伪泛型、真实泛型的含义？类型擦除和类型膨胀指的是？</p>
<ul>
<li>Java 使用伪泛型，编译期间将泛型类的类型转化为原始类型，称为类型擦除。访问泛型类时，强转成传入的实际类型。</li>
<li>真实泛型在编译期不做类型擦除，使用到的泛型类会编译为真实类型，称为类型膨胀。</li>
</ul>
<h2 id="泛型的类型擦除"><a href="#泛型的类型擦除" class="headerlink" title="泛型的类型擦除"></a>泛型的类型擦除</h2><p>泛型的本质是参数化类型</p>
<p>Java 的泛型是<code>伪泛型</code>，Java 的泛型基本上都是在编译阶段实现的</p>
<p>之所以是伪泛型，因为<code>类型擦除</code>特性：</p>
<p>在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，替换为原始类型，这个过程称为类型擦除</p>
<p>作为编译期类型擦除补偿，编译期对涉及访问泛型类型对象的代码处做了增强，增加了<code>强制类型转换</code>来保障结果符合预期。同时，JAVA 在代码编译前会进行泛型类型检查</p>
<p>与伪泛型相对的是<code>真实泛型</code>，编译后不会类型擦除，使用泛型的类会编译为真实泛型类型，运行时也会加载为真实泛型类型对应的泛型类，这也称为<code>类型膨胀</code></p>
<p>举个例子，List<String>和 List<Integer>泛型擦除后都只是 List 类型，而一些使用真实泛型的语言，编译期不做类型擦除，运行时会生成两个类，分别是 List<String>和 List<Integer></p>
<h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><p><img src="/JVM/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E4%B8%8E%E8%BF%90%E8%A1%8C%E4%BC%98%E5%8C%96.png"></p>
<h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><p>为什么说 JAVA 程序是可移植跨平台的？</p>
<ul>
<li>JVM 运行在物理机之上，提供了自己的指令集，与硬件无关，因此是可移植跨平台的</li>
</ul>
<p>解释执行和编译执行的特点各是什么？</p>
<ul>
<li>JVM 执行引擎支持解释执行和编译执行。解释执行可直接执行 java 编译后的字节码，编译执行指将字节码做 JIT 编译为硬件平台可识别的机器码后执行。</li>
<li>解释执行因为无需二次编译，因此可快速启动 Java 程序，编译执行主要用于提高热点代码的执行效率</li>
</ul>
<p>为什么编译执行性能优于解释执行？</p>
<ul>
<li>机器码可直接被底层硬件平台识别和执行。解释执行需要翻译字节码，再执行 JVM 指令，底层还是要执行硬件平台的指令</li>
<li>JVM 在 JIT 编译阶段做了性能优化，而代码编译阶段几乎没有任何优化</li>
</ul>
<p>JIT 如何探测热点代码？</p>
<ul>
<li>基于计数器的热点探测，当方法调用次数超过阈值会触发 JIT 编译，生成机器码，后续调用该方法时，JVM 做编译执行而非解释执行</li>
</ul>
<p>为什么 JIT 的即时编译又称为 OSR（栈上替换）编译？</p>
<ul>
<li>JIT 编译后，方法的调用地址改变，但此时该方法的旧地址还在栈帧上，因此需要替换，所以 JIT 编译又称为栈上替换</li>
</ul>
<p>JIT 在编译阶段对代码做了哪些优化？</p>
<ul>
<li>方法内联，逃逸分析</li>
</ul>
<p>什么是方法内联？有什么好处和局限性？</p>
<ul>
<li>方法内部调用其他方法时，将其他方法的代码“复制”到方法内，避免额外创建栈帧。局限性是对于虚方法，可能存在多态，无法确定调用方法的版本，因此很难做方法内联。</li>
</ul>
<p>虚方法无法内联的解决方案是什么？</p>
<ul>
<li>继承关系分析技术。不存在多态，可以内联。存在多态，缓存方法的调用方，如果每次调用不变，则可以内联，否则无法内联，到虚方法表查找真正的调用地址</li>
</ul>
<p>有哪两种类型的逃逸分析？</p>
<ul>
<li>方法逃逸分析，判断方法内部创建的对象是否会被外部方法引用。线程逃逸分析，判断对象是否会被外部线程访问。</li>
</ul>
<p>基于逃逸分析的优化方案有哪些？</p>
<ul>
<li>栈上分配、标量替换：如果不存在方法逃逸，对象可在栈帧上分配，不用在堆上分配，减轻 GC 压力。栈上分配时，只分配对象被访问到的成员变量，而非整个对象，称为标量替换</li>
<li>同步消除：如果不存在线程逃逸，则不存在读写竞争，可以消除对象的同步锁</li>
</ul>
<h2 id="JVM-执行引擎"><a href="#JVM-执行引擎" class="headerlink" title="JVM 执行引擎"></a>JVM 执行引擎</h2><p>JVM 运行在物理机之上，可以自定义一套指令集，因此能执行那些不被硬件直接支持的指令</p>
<p>JAVA 代码编译过程概括为：词法、语法分析–&gt;抽象语法树 AST–&gt;字节码指令流</p>
<p>编译生成的指令流是一种<code>基于栈的指令集架构</code>，指令通过操作数栈执行。相比于另一种直接依赖硬件来执行指令的<code>寄存器指令集</code>，基于栈的指令集优点是可移植，缺点是性能不如寄存器指令集</p>
<p>JVM 的执行引擎负责执行字节码指令流，执行的方式有两种：<code>解释执行</code>和<code>编译执行</code></p>
<p>解释器能快速启动和执行被编译成字节码的 JAVA 程序，编译执行是由<code>及时编译器JIT</code>将字节码编译成机器码后执行，可以理解为在执行时二次编译了，目的是为了提升热点代码的执行效率</p>
<p>主流的 JVM 同时配有解释器和编译器，二者互相配合。且当编译器进行一些“激进优化”失败后，可以逆优化回退到解释执行</p>
<h2 id="JIT-即时编译器"><a href="#JIT-即时编译器" class="headerlink" title="JIT 即时编译器"></a>JIT 即时编译器</h2><p>JIT 的作用：为了提高热点代码执行效率，运行时 JIT 将这些代码编译成与本地平台相关的机器码</p>
<p>Hotspot 使用<code>基于计数器的热点探测</code>来甄别热点方法和循环体（热点循环体会触发所在方法的 JIT 编译）。当方法调用次数超过阈值，会触发 JIT 即时编译，下次调用时，方法的入口地址会替换为新的</p>
<p>因为循环体热点探测发生在方法执行过程中，因此触发的<code>即时编译</code>动作也称为<code>OSR编译</code>（栈上替换，方法栈帧还在栈上，方法就被替换了）</p>
<p>编译执行比解释执行更快的原因有两点：</p>
<ul>
<li>虚拟机翻译字节码产生的额外耗时</li>
<li>JVM 对代码的优化都做在了 JIT 即时编译阶段，代码编译阶段几乎没有任何优化措施</li>
</ul>
<h3 id="JIT-编译优化"><a href="#JIT-编译优化" class="headerlink" title="JIT 编译优化"></a>JIT 编译优化</h3><p>JIT 编译阶段的代码优化有哪些呢？</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>什么叫方法内联？</p>
<ul>
<li>方法内联就是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用</li>
</ul>
<p>方法内联有什么好处？</p>
<ul>
<li>消除方法调用的成本，如无需再建立新的栈帧</li>
<li>为其它优化手段建立良好的基础，如无用代码消除等</li>
</ul>
<p>方法内联的局限？</p>
<ul>
<li>非虚方法在编译期就可以确定方法版本，但虚方法如果存在多态，很难确定调用的方法版本。因此虚方法很难在 JIT 编译期做方法内联</li>
</ul>
<p>虚方法无法内联的解决方案</p>
<ul>
<li>使用<code>CHA</code>（类型继承关系分析）技术对整个应用做类型分析<ul>
<li>对于虚方法，查询 CHA 后得到方法只有一个版本，即不存在多态，则可以内联</li>
<li>对于虚方法，查询 CHA 后得到方法有多个版本，即存在多态，则通过<code>内联缓存</code>来实现内联：在方法调用时记录下调用方，如果每次虚方法调用方不变，则内联可以继续。否则，取消方法内联，查找虚方法表进行方法分派</li>
<li>虚方法内联的解决方案属于激进优化，需要预留逃生门，当方法内联不成立时，先回退到解释执行</li>
</ul>
</li>
</ul>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析与方法内联用到的 CHA(类型继承关系分析)一样，虽然不是直接优化的方法，但可以作为其他优化手段的分析技术</p>
<p>逃逸分析的目标是对象作用域，存在两种对象逃逸</p>
<ul>
<li>方法逃逸：当一个对象在方法中定义之后，作为参数传递到其它方法中；</li>
<li>线程逃逸：如类变量或实例变量，可能被其它线程访问到；</li>
</ul>
<p>如果对象不存在方法逃逸和线程逃逸，可以进行一些优化：</p>
<ul>
<li>栈上分配。不会逃逸出方法之外的对象可以在栈上分配内存。对象随方法结束栈帧回收而被销毁。不用在堆上分配，减轻 GC 压力。</li>
<li>标量替换。如果一个对象不会逃逸出方法外，可以只在栈上创建它被访问到的成员变量，不用在栈上创建整个对象。标量的含义就是不可再分解的变量，一般就是对象的类型为基本类型的成员属性。<ul>
<li>目前 hotspot 虚拟机对不存在方法逃逸的对象，实际就是用标量替换作为栈上分配的实现方式</li>
</ul>
</li>
<li>同步消除。不会逃逸出线程的对象，不会产生读写竞争，可以消除对它的同步锁</li>
</ul>
<h1 id="JAVA-内存模型"><a href="#JAVA-内存模型" class="headerlink" title="JAVA 内存模型"></a>JAVA 内存模型</h1><p><img src="/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><p>什么是缓存一致性协议？</p>
<ul>
<li>多核 CPU 中，每个 CPU 各自高速缓存里的共享（公共）变量需要保证数据一致性</li>
</ul>
<p>MESI 缓存一致性协议的实现原理是？</p>
<ul>
<li>CPU 修改高速缓存里的共享变量后，先发送该数据 Invalid 的通知到其他 CPU 的高速缓存，收到响应后再写到内存</li>
<li>高速缓存读取变量时，如果状态是 Invalid，重新从主内存读取</li>
</ul>
<p>缓存一致性协议为什么不能保证线程安全？</p>
<ul>
<li>修改共享变量后，需要同步等待 Invalid 通知的响应后，才能写回内存，拖累了 CPU 的性能，因此 CPU 将同步改成异步，先将计算后的公共变量写到“store buffer”，然后发送 Invalid 通知就结束了。等收到 Invalid 响应后，再把数据从“store buffer”写回内存。而其他 CPU 的高速缓存也不会立刻执行 Invalid，而是将 Invalid 请求放入队列后就返回响应了。</li>
<li>引入异步和 store buffer 后，其他缓存读到的共享变量可能为脏数据，因此无法保障共享变量的线程安全性。即，使用异步实现缓存一致性协议后，破坏了可见性。<ul>
<li>Invalid 通知还在队列里没处理，这时读取的共享变量为脏数据</li>
<li>虽然将共享变量标记为 Invalid，但最新值还没来得及从 store buffer 写入内存，这时读取的共享变量为脏数据。如果是同步的方式，可以认为收到 Invalid 响应后立刻写入内存</li>
</ul>
</li>
<li>引入异步和 store buffer 后，因为共享变量会先缓存在 store buffer 中而非写入内存，所以 CPU 出于性能考虑可能会优先将一些非共享变量的值写入内存，产生指令重排序，因此也无法保障线程安全性</li>
</ul>
<p>什么是 JAVA 内存模型？作用是什么？</p>
<ul>
<li>Java 内存模型建立了与底层硬件的映射关系，将内存划分为主内存和工作内存（类比高速缓存）。线程只能修改工作内存里的数据，无法直接修改主内存。目的是让 Java 程序在各个平台达到一致的内存访问效果。</li>
</ul>
<p>从 JAVA 内存模型的角度，如何解释 volatile 可见性的实现原理？</p>
<ul>
<li>每次访问 volatile 变量，都会从主内存读取最新值到工作内存。每次写工作内存里的 volatile 变量后，都会立刻回写主内存</li>
</ul>
<p>volatile 底层是如何实现可见性和有序性的？</p>
<ul>
<li>JVM 在 volatile 关键字修饰的变量的读写指令前后加入了内存屏障，效果就是将缓存一致性协议改回同步方式，不会产生读取脏数据问题和指令乱序问题，保障了可见性和有序性</li>
</ul>
<p>为什么 volatile 不能保证原子性？</p>
<ul>
<li>以自增操作为例，该操作是非原子操作，包括读取变量、变量自增、变量回写。虽然 volatile 保证读取变量时读到的是最新值，但对于变量做自增操作时，可能有新的值回写到主内存，这时操作的 volatile 变量就过期了，是线程不安全的，所以仅靠 volatile 不能保证原子性</li>
</ul>
<p>volatile 有哪些应用场景？</p>
<ul>
<li>用作哨兵，通常是个布尔对象，及时获取其他线程对哨兵状态的变更</li>
<li>单例实例用 volatile 修饰，创建单例时不需要加同步代码块</li>
</ul>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>CPU 的每个核由计算单元 ALU、寄存器（存储当前线程需要做运算的数据）、指令计数器（存储下一条指令在内存中的地址）、高速缓存组成</p>
<p>CPU 在做运算时，先从内存读取数据到寄存器，ALU 再从寄存器读取数据做运算，后者的读取速度比前者快了 100 倍。为了提高 CPU 的利用率，避免浪费大量时间等待从内存读取数据，引入了高速缓存，集成到 CPU 的核上。CPU 每次运算时读取和写入的都是缓存，而不是每做一次运算就读取和写入一次内存，大大提升了 CPU 利用率</p>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>多核 CPU 的每个 CPU 都有高速缓存，因此如果多线程在多核上并发计算同一内存空间上的共享数据，每个核上的缓存都会存储一份共享数据的镜像，需要保证每个 CPU 各自缓存的共享数据的一致性（可见性，别的线程改了我能立刻将最新值读到缓存），因此产生了缓存一致性协议</p>
<ul>
<li>严格意义上说是“缓存行”的一致性，因为 CPU 缓存是以缓存行为最小单元从内存读取数据的，大小为 64 字节。引入缓存行也是为了提高读取性能，因为从内存读取数据是 IO 操作拖累 CPU 性能，且程序运行过程中大概率会读取相邻数据，所以干脆读取“一行”数据</li>
</ul>
<p>每个 CPU 厂商有自己的缓存一致性协议实现，最经典的是 MESI 协议。CPU 修改高速缓存里的共享变量后，先发送该数据 Invalid 的通知到其他 CPU 的高速缓存，收到响应后再写到内存。从高速缓存读取变量时，如果状态是 Invalid，重新从主内存读取。可以看出，缓存一致性协议保证了共享变量的可见性。</p>
<p>这种实现方案本质是同步的。修改共享变量后，需要同步等待 Invalid 通知的响应后，才能写回内存，拖累了 CPU 的性能，因此优化方案是将同步改成异步，先将计算后的公共变量写到“store buffer”，然后发送 Invalid 通知就结束了。等收到 Invalid 响应后，再把数据从“store buffer”写回内存。而其他 CPU 的高速缓存也不会立刻执行 Invalid，而是将 Invalid 请求放入队列后就返回响应了。</p>
<p>异步方案的问题是破坏了共享变量的可见性。例如 Invalid 通知还在队列里没处理，这时读取的共享变量为脏数据。或者是将共享变量标记为 Invalid，但最新值还没来得及从 store buffer 写入内存，这时读取的共享变量为脏数据。如果是同步的方式，可以认为收到 Invalid 响应后立刻写入内存。</p>
<p>另外引入异步和 store buffer 后，会产生指令重排序。因为共享变量会先缓存在 store buffer 中而非写入内存，所以 CPU 出于性能考虑可能会优先将一些非共享变量的值写入内存，产生指令重排序。</p>
<h2 id="JAVA-内存模型-1"><a href="#JAVA-内存模型-1" class="headerlink" title="JAVA 内存模型"></a>JAVA 内存模型</h2><p>JVM 规范中定义了一套<code>JAVA内存模型</code>，目的是屏蔽硬件和操作系统差异，使得 JAVA 程序在各个平台达到一致的内存访问效果</p>
<ul>
<li>JAVA 内存模型主要面向的是<code>堆上对象</code>的读写规则，因为只有堆上对象才会存在多线程竞争问题，栈上对象是线程私有的，不会被共享</li>
</ul>
<p>JAVA 内存模型划分了<code>主内存</code>和<code>工作内存</code>。映射到硬件层面，主内存可以理解为内存区域，工作内存可以理解为高速缓存区域。线程对变量的操作只发生在工作内存，不能直接读写主内存。</p>
<p>JAVA 内存模型主要考虑的是变量在多线程间的可见性以及满足 happens-before 规则的指令有序性</p>
<ul>
<li>所谓 happens-before 规则，即前面一个操作的结果对后续操作必须是可见的，不能因为指令重排序破坏这个规则</li>
<li>可见性要依赖底层的缓存一致性协议实现。上面提到的异步方案其实保证不了共享变量的可见性，因此 JAVA 提供了 volatile 关键字来强保证共享变量的可见性<ul>
<li>实现可见性的前提就是保证有序性，因为如果指令乱序了可能导致 volatile 变量的值不符合代码逻辑，所以即使满足可见性，实际拿到的也是一个错误的结果</li>
</ul>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>被 volatile 修饰的变量，可以保证可见性和有序性</p>
<p>可见性从 JAVA 内存模型角度可以这么理解：</p>
<ul>
<li>一般的变量，线程修改后，不会立刻从工作内存写回主内存，需要等线程切换时才回写。线程读取变量到工作内存后，操作的就是工作内存中变量的值，对于之后变量在主内存的更新是感知不到的。即，<code>不立即写主内存，也不实时读主内存</code>。</li>
<li>volatile 变量在线程的工作内存修改后，会<code>立刻回写主内存</code>。而其他线程每次使用 volatile 变量时，也会去<code>实时读取主内存volatile的值</code></li>
</ul>
<p>可见性从缓存一致性协议可以这么理解：<br>异步方式实现的缓存一致性协议，不会在共享变量修改后同步写内存，且共享变量 Invalid 操作也不会同步执行，因此其他 CPU 计算的共享变量仍有可能是一个脏数据。为了保证 volatile 修饰对象的可见性，JVM 在对象读写前后加入了内存屏障指令，将异步缓存一致性协议改回同步方式，废弃了 store buffer 和 Invalid queue，所以共享变量的修改会实时被其他线程读取到，保证了可见性。</p>
<p>但是 volatile 变量不能保证并发下的原子性。因为做一些<code>依赖volatile变量值的非原子操作（原子操作，可以理解为一条机器码指令）的运算</code>，例如 volatile 变量自增，可能在 CPU 计算 volatile 变量期间，其他线程将 volatile 变量的最新值写回主内存，导致计算前已经读取的 volatile 值成了脏数据，因此基于原 volatile 值做的任何运算也就不能保证是原子操作，是线程不安全的</p>
<p>如果是对 volatile 修饰对象的原子操作或读操作，则可以认为是线程安全的。java 中的原子操作包括：</p>
<ul>
<li>除了 long 和 double 之外的基本类型的赋值操作，因为 long 和 double 类型是 64 位的，所以它们的操作在 32 位机器上不算原子操作，而在 64 位的机器上是原子操作。</li>
<li>所有引用 reference 的赋值操作</li>
<li>java.concurrent.Atomic *包中所有类的原子操作</li>
</ul>
<p>volatile 的应用场景：</p>
<ul>
<li>用作哨兵。当线程执行了操作后，通过修改哨兵的布尔值，能立即通知到其他线程</li>
<li>DCL 模式创建单例。将单例修饰为 volatile，保证并发下，线程在加锁前能可靠地判断当前时刻单例是否为空</li>
</ul>
<p>volatile 除了保证变量可见性，还保证有序性（执行时不会进行<code>指令重排序</code>）。因为提升 volatile 变量可见性后，如果允许指令重排序，线程读取的 volatile 变量值可能与代码期望效果不符。可以试想一下 volatile 作为哨兵的例子，指令重排序后可能会提前放哨。</p>
<ul>
<li>指令重排序：JVM 执行引擎提升性能的一种优化，实际执行的顺序与代码的顺序不一致，但保证最终一致性</li>
<li>禁止指令重排序会消耗写 volatile 变量的性能，但使用 volatile 整体的开销还是比加锁要低。</li>
</ul>
<p>除了 volatile 关键字，synchronized 和 final 关键字也能保证可见性</p>
<ul>
<li>synchronized 保证可见性的依据：对一个变量 unlock 前，必须先把变量回写到主内存</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Netty</title>
    <url>/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Netty/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h2><p>TCP：传输控制协议<br>UDP：用户数据协议</p>
<ul>
<li>TCP 是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP 是无连接的（发送数据之前不需要先建立连接）</li>
<li>TCP 提供可靠的服务（通过 TCP 传输的数据。无差错，不丢失，不重复，且按序到达）；UDP 提供面向事务的简单的不可靠的传输。</li>
<li>UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP 使用越来越多。</li>
<li>每一条 TCP 连接只能是点到点的，UDP 支持一对一，一对多和多对多的交互通信。</li>
<li>TCP 对系统资源要求比较多，UDP 对系统资源要求比较少</li>
<li>UDP 程序结构更加简单</li>
<li>TCP 是流模式，UDP 是数据报模式</li>
</ul>
<p>UDP 应用场景</p>
<ul>
<li>数据包总量比较少的通信，比如 DNS、SNMP</li>
<li>视频、音频等对实时性要求比较高的多媒体通信</li>
<li>广播通信、多播通信</li>
</ul>
<p>TCP 如果保证高可靠传输？</p>
<ul>
<li>序列号：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和：TCP 将保存它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>流量控制：控制发送速率。TCP 连接的每一方都有固定大小的缓冲空间（窗口）。通过可变大小的滑动窗口协议，发送方根据确认消息里接收方窗口的大小，控制发送速率，防止丢数据。</li>
<li>拥塞控制：发送方还有一个拥塞窗口，窗口大小基于一定的策略（慢开始、快重传、快恢复）动态调整。目的是当网络拥塞时，减少数据的发送。<ul>
<li>发送方的发送窗口取的是拥塞窗口和接收方接收窗口的最小值。</li>
</ul>
</li>
<li>自动重传 ARQ 协议：每发完一个分组就启动一个定时器，并停止发送，等待对方确认。在收到确认后再发下一个分组。如果超时未收到对方确认，将重发这个报文段。这种方式信道利用率低，一般采取连续 ARQ 协议，即位于发送窗口内的分组可以连续发送而不用等确认，接收方对按序到达的最后一个分组发送确认。缺点是如果出现消息丢失，发送方需要回退 N 重发。</li>
</ul>
<p>TCP 建联的三次握手机制：</p>
<ul>
<li>第一次握手：主机 A 发送位码 syn ＝ 1，随机产生 seq number&#x3D;1234567 的数据包到服务器，主机 B 由 syn&#x3D;1 知道，A 要求建立联机；</li>
<li>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number&#x3D;(主机 A 的 seq+1)，syn&#x3D;1，ack&#x3D;1，随机产生 seq&#x3D;7654321 的包</li>
<li>第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1，以及位码 ack 是否为 1。若正确，主机 A 会再发送 ack number&#x3D;(主机 B 的 seq+1)，ack&#x3D;1。主机 B 收到后确认 seq 值与 ack&#x3D;1 则连接建立成功</li>
</ul>
<p>TCP 断连的四次挥手机制(假设 C 端发起断连)：</p>
<ul>
<li>C 端发送 FIN 报文</li>
<li>S 端发送 ACK 报文，然后把剩余数据发完</li>
<li>S 端发送 FIN 报文</li>
<li>C 端发送 ACK 报文，S 端收到 ACK 后，关闭连接。C 端超过一定时长后没收到消息（担心 C 端发送的 ACK 丢失），证明 S 端已经断开，则关闭连接</li>
</ul>
<p>为什么建联三次握手，断连四次握手？<br>因为建联时，接收端可以 ACK 和 SYN 一起发送。断连时，被断开方收到 FIN 消息后，还可能有需要发送的数据，所以只能先 ACK，等发完数据后再发送 FIN。</p>
<p>什么是 TCP 拆包、粘包？<br>拆包：将应用层下发的一个大数据包拆成多个数据包<br>粘包：将应用层下发的多个小数据包合成一个数据包</p>
<p>TCP 为什么存在拆包、粘包？</p>
<ul>
<li>TCP 基于字节流，对应用层下发的数据看成一连串无边界的字节流</li>
<li>TCP 的数据帧结构没有标识数据长度的字段</li>
<li>TCP 基于发送窗口大小来发送数据包，且发送窗口存在动态调整，所以存在拆包、粘包</li>
</ul>
<p>如何解决拆包、粘包？<br>只能通过在应用层定制协议来实现。一般有三种方式：</p>
<ul>
<li>消息定长</li>
<li>每条报文尾部增加特殊字符来标识</li>
<li>应用层定制协议字段，消息头增加字段标识数据长度</li>
</ul>
<h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h2><p>在传输层上做的一层抽象编程接口，不同编程语言都有对应的 Socket 服务端和客户端的库。<br>Socket 在设计之初就希望也能适应其他网络协议，不局限于 TCP&#x2F;IP 协议，<code>但一般用到的Socket都是基于TCP/IP协议的实现</code>，且 Socket 在传输层既可以基于 TCP 协议，也可以基于 UDP 协议做实现。</p>
<h3 id="长连接-amp-短链接"><a href="#长连接-amp-短链接" class="headerlink" title="长连接 &amp; 短链接"></a>长连接 &amp; 短链接</h3><p>所谓长连接，指在一个 TCP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接(心跳包)。基于 TCP 的 Socket 连接就是长连接（三次握手建联后，除非一方主动发起断连，否则连接通道不会断开）。数据库连接就用的长连接。<br>短连接是指通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接。比如一次 HTTP 连接，只是 TCP 建连、发送请求、接收响应、断连。<br>HTTP&#x2F;1.1 已经默认开启长连接：把 Connection 头写进标准，除非请求中写明 Connection: close，否则浏览器和服务器之间是会<code>维持一段时间</code>的 TCP 连接，不会一个请求结束就断掉。</p>
<blockquote>
<p>延伸：Http&#x2F;1.1 除了默认开启长连接来减少 TCP 建连的开销，还有什么提效的方法？</p>
</blockquote>
<p>答案在 Http2，其提供了 multiplexing 多路传输特性，可以在一个 TCP 链接建立后，并行完成多个 Http 请求，以提高页面加载效率。<br>Http&#x2F;1.1 时代是采用上面说的默认开启长连接和同时建立多个 TCP 连接来提高页面加载效率</p>
<h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>操作系统的核心是内核，独立于普通的应用程序，有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将内存划分为两部分，一部分为内核空间，一部分为用户空间。对 32 位操作系统而言，虚拟存储空间为 2^32&#x3D;4G。针对 linux 操作系统，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间</p>
<h2 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符（socket 也是一种文件描述符，因为需要 IO 操作）。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。<br><code>网络IO里，fd可以简单理解为socket连接</code></p>
<h2 id="缓存-I-x2F-O"><a href="#缓存-I-x2F-O" class="headerlink" title="缓存 I&#x2F;O"></a>缓存 I&#x2F;O</h2><p>缓存 I&#x2F;O 又被称作标准 I&#x2F;O，大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O。在 Linux 的缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>Java 调用 channel（文件 channel、网络连接 socketChannel 等）的数据读取 api 时，会经历以下步骤：</p>
<ul>
<li>用户态（java 内存空间）切换到内核态<ul>
<li>因为 java 无法直接操作系统资源，需要调用操作系统内核来完成</li>
</ul>
</li>
<li>等待数据到来</li>
<li>（磁盘、网卡上的）数据复制到内核缓冲区</li>
<li>内核态切换回用户态</li>
<li>内核缓冲区数据复制到用户空间（java 堆内存空间）</li>
</ul>
<p>可以看到，一次数据读（写一样）经历了两次用户态内核态切换、两次数据复制，性能不高。针对这一问题，linux 内核做了优化，提供所谓<code>直接内存</code>给 java nio 的 ByteBuffer 使用，直接内存物理上指内核缓冲区，java 使用直接内存可以直接读写内核缓冲区上的数据，少了一次数据复制的性能损耗，且内核缓冲区的地址固定，不会受 java 垃圾回收导致堆数据地址偏移的影响，IO 读写性能更高。我们把这种使用直接内存解决读写数据时在内核缓冲区和 java 堆内存相互复制数据的技术，称为零拷贝。</p>
<p>在零拷贝技术的基础上，针对一种使用频率较高的复合操作：读取磁盘文件数据再写入网卡进行发送，Linux 内核进一步优化。完成该复合操作本来需要涉及到三次用户态到内核态的切换才能完成，但现在只需要由用户态切换一次到内核态，由内核将磁盘数据复制到内核缓冲区后，直接复制到网卡，性能进一步提升。目前 java nio 已支持对该类复合操作的性能优化。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=51">https://www.bilibili.com/video/BV1py4y1E7oA?p=51</a></p>
<h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p><img src="/Netty/IO%E6%A8%A1%E5%9E%8B.jpg"></p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>阻塞 IO（BIO）指用户线程在“等待数据和数据拷贝这两个阶段”都阻塞。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=48">https://www.bilibili.com/video/BV1py4y1E7oA?p=48</a></p>
<p>BIO 模式下，线程执行所有网络 IO 的 api 都是阻塞的，例如接受 socket 连接、读取网络数据。因此服务端会为每个 Socket 连接分配一个独立的线程来负责该连接所有的 IO 读写操作，问题是高并发下内存占用率高、线程上下文切换成本高。即使使用线程池，因为线程大部分时间是阻塞在 IO 上的，利用率不高，只适合 http 短连接场景，通过请求执行后快速断开连接来提高线程利用率。早期的 tomcat 设计就是采取 BIO+线程池+http 短连接来做的。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=4">https://www.bilibili.com/video/BV1py4y1E7oA?p=4</a></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>非阻塞 IO（NIO）指如果没有数据直接返回，否则阻塞在数据拷贝。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=48">https://www.bilibili.com/video/BV1py4y1E7oA?p=48</a></p>
<p><code>BIO里用户最关心“我要读”，NIO里用户最关心&quot;我可以读了&quot;，在AIO模型里用户更需要关注的是“读完了”</code></p>
<p>NIO 编程的三大组件：</p>
<ul>
<li>Channel</li>
<li>Selector</li>
<li>Buffer</li>
</ul>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel 可以理解为 fd，是一个底层的数据传输双向通道模型，与传统 Stream 的区别，channel 是双向的，Stream 是单向的。在网络 IO 中使用 SocketChannel 表示 socket 连接。区别于 BIO，NIO 中的 channel 可以设置为非阻塞模式，没有 IO 事件到来时也不会阻塞线程，因此可以在单线程里使用 while 循环来轮训多个客户端 socket 连接，但这带来的问题就是大量的空转，浪费 CPU 资源。后面介绍的 Selector 可以解决这个问题</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer 是数据的内存缓冲区。当数据到来时 Channel 将数据写到 Buffer，程序从 Buffer 读取数据。当程序要写（发送）数据时，将数据写到 Buffer，Channel 负责将 Buffer 里的数据发送出去。因此读写不会直接操作 channel，而是操作 buffer，由 buffer 再和 channel 进行数据互通<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=2">https://www.bilibili.com/video/BV1py4y1E7oA?p=2</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=25">https://www.bilibili.com/video/BV1py4y1E7oA?p=25</a></p>
<p>读取数据到 ByteBuffer<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=6">https://www.bilibili.com/video/BV1py4y1E7oA?p=6</a></p>
<p>Buffer 每次读写时需要先调 api 切换到对应模式，原因是读写操作都是操作的同一片内存空间，Buffer 使用三个属性来控制读写行为，分别是 position（当前读或写的起始位置）、limit（读取或写入的终止位置）、capacity（buffer 分配的内存空间大小）<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=7">https://www.bilibili.com/video/BV1py4y1E7oA?p=7</a></p>
<p>对于应用层下发的数据，在传输层会出于网络传输效率考虑，对数据包做拆分或合并，因此服务端从 Channel 的 Buffer 读取数据后，需要解决产生的半包或黏包问题，根据一些协议字段重新对数据做拆分或合并<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=14">https://www.bilibili.com/video/BV1py4y1E7oA?p=14</a></p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>多路复用是一种可以同时阻塞监听多个通道上的 IO 事件的技术。注意虽然是阻塞监听，但本质还是利用了 NIO，所以每个通道都必须工作在非阻塞 IO。<br>当 IO 事件到来时返回有事件的通道和相应的 IO 事件，业务线程拿到通道后再执行阻塞式的数据拷贝。虽然多路复用和阻塞 IO 很类似，但因为可以同时监听多个通道，所以效率有很大提升。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=49">https://www.bilibili.com/video/BV1py4y1E7oA?p=49</a></p>
<p>Selector 是一个实现了非阻塞 IO 的多路复用器，可以通过一个持有 Selector 的线程来监听多个注册在它上的 Channel 指定的 IO 事件，当没有 IO 事件时线程阻塞在 selector 的 select 方法，当 IO 事件到来时唤醒线程，处理有 IO 事件的 channel 连接。因此使用 Selector 来处理多个客户端连接有两个好处：</p>
<ul>
<li>提高了 CPU 利用率</li>
<li>节省了服务端线程数目，降低了线程上下文切换成本<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=5">https://www.bilibili.com/video/BV1py4y1E7oA?p=5</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=27">https://www.bilibili.com/video/BV1py4y1E7oA?p=27</a></li>
</ul>
<p>Netty 使用多线程来最大化利用 Selector 的多路复用能力，boss 线程的 selector 只负责监听服务端 socketChannel 的 accept 事件，worker 线程的 selector 只负责监听已经建立连接的客户端 socketChannel 的读写事件<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=40">https://www.bilibili.com/video/BV1py4y1E7oA?p=40</a></p>
<p>需要注意，worker 线程的 selector 没有 IO 事件时阻塞在 select 方法，此时 boss 线程拿到客户端 socketChannel 调用 worker 线程的 selector 注册时也会阻塞，产生死锁。解法是将注册操作封装为一个 runnable 任务添加到 worker 线程的任务队列，然后唤醒 worker 线程的 selector，worker 线程接着遍历任务队列执行添加的注册操作。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=44">https://www.bilibili.com/video/BV1py4y1E7oA?p=44</a></p>
<p>Selector 将注册给它的 channel 映射为一个 SelectionKey，添加到集合 a 里，每次 channel 有 IO 事件到来，将 channel 对应的 selectionKey 添加到另一个集合 b 里交给业务处理。这里需要注意：</p>
<ul>
<li>集合 b 只进不出，所以每次业务处理完事件后需要手动从集合 b 里删除 selectionKey</li>
<li>如果客户端连接强制断开时，服务端会收到一个读 IO 事件，但从 ByteBuffer 读数据会抛出 IO 异常，这时需要捕获 IO 异常，然后将客户端 channel 对应的 selectionKey 从集合 a 里删除</li>
<li>如果客户端正常断开连接，服务端会收到一个读 IO 事件，通过读取数据长度为-1 判断是正常断开连接，然后将客户端 channel 对应的 selectionKey 从集合 a 里删除</li>
<li>如果数据没读完，下次调用 select 还会返回该 selectionKey 的读事件<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=30">https://www.bilibili.com/video/BV1py4y1E7oA?p=30</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=31">https://www.bilibili.com/video/BV1py4y1E7oA?p=31</a></li>
</ul>
<p>服务端接收到客户端 socketChannel 时，如果需要给客户端发送数据，可以给 socketChannel 的 selectionKey 添加一个监听可写事件。当发送数据量很大时，一次写操作把网络缓冲区沾满了，还有剩余没写完的数据在 ByteBuffer 里，selector 会在下次网络缓冲区有空间时监听到这个 selectionKey 的写事件，交给服务端继续执行剩余数据的写操作<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=38">https://www.bilibili.com/video/BV1py4y1E7oA?p=38</a></p>
<p>使用 selectionKey 的附件 attachment 机制解决半包、黏包问题。附件是 Channel 注册给 Selector 时指定的一个附加对象。可以将 ByteBuffer 作为附件，存储未处理完的数据。下次处理 IO 读事件时，可以通过附件取出上次的 ByteBuffer，然后将后面的数据继续写入 ByteBuffer<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=35">https://www.bilibili.com/video/BV1py4y1E7oA?p=35</a></p>
<h3 id="多路复用-IO"><a href="#多路复用-IO" class="headerlink" title="多路复用 IO"></a>多路复用 IO</h3><p>NIO 的核心是选择器 Selector 的 select 方法，获取发生了 IO 事件的所有 channel，底层使用多路复用实现。</p>
<p>多路复用 IO 的实现方式有三种：select、poll 和 epoll 模式，可以理解为 epoll 是改进版，JDK1.6 之后使用的是 epoll 模式，极大提升了 NIO 的性能。</p>
<p>select 模式(<code>两次拷贝+轮询+遍历=性能低</code>)：<br>用户线程里将要监控的文件描述符添加到 fd_set 数组中，用户空间需要维护这个数组，然后<code>拷贝</code>到内核进行监控。因为数组存储文件描述符，所以能监控的文件描述符数量受限，一般最大为 1024。<br>内核需要<code>轮询</code>fd_set 数组检测这些文件描述符是否发生了事件，当事件发生后，将 fd_set 数组同步<code>拷贝</code>回用户空间的数组<br>用户线程需要<code>遍历</code>用户空间的数组才知道哪个文件描述符发生了事件。</p>
<p>缺点：</p>
<ul>
<li>存在大量的内核和用户空间的内存拷贝，系统开销大</li>
<li>内核轮询 fd 数组获取事件 &amp; 用户线程需要遍历 fd 数组判断哪些 fd 有事件到达，效率低</li>
</ul>
<p>poll 模式：<br>存储文件描述符的结构从数组改为链表，因此监听文件描述符的数量不受限，其他地方和 select 模式相同</p>
<p>epoll 模式把 select 调用分为了三部分：</p>
<ul>
<li>调用 epoll_create 建立一个 epoll 对象，这个对象包含了一个红黑树和一个双向链表。并与底层建立回调机制。</li>
<li>调用 epoll_ctl 向 epoll 对象中添加所有 fd（网络 IO 中就是 socket 句柄）</li>
<li>调用 epoll_wait 收集发生事件的 socket 连接。</li>
</ul>
<p>性能上有哪些提升呢？</p>
<ul>
<li>用户空间拷贝全量 fds 到内核？No!<ul>
<li>内核里使用<code>红黑树</code>存储所有文件描述符，高效添加和删除文件描述符（网络 IO 里是 socket 连接），省去从用户空间往内核拷贝全量文件描述符的性能消耗</li>
</ul>
</li>
<li>轮询 fds 获取 fd 事件？No!<ul>
<li><code>回调而非轮询</code>的方式获取事件（socket 数据到达）</li>
</ul>
</li>
<li>内核拷贝全量 fds 到用户空间？No!<ul>
<li>使用双向链表存储发生事件的 socket，只需要从内核拷贝<code>发生事件的fd</code>到用户空间</li>
</ul>
</li>
</ul>
<p>总结：<br>一颗红黑树，一张准备就绪句柄（fd）双向链表，少量的内核 cache（存储红黑树），就帮我们解决了大并发下的 socket 处理问题。执行 epoll_create 时，创建了红黑树和 fd 双向链表，执行 epoll_ctl 时，如果增加 socket 句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向 fd 双向链表中插入数据。执行 epoll_wait 时立刻返回链表里的数据即可。<br><img src="/Netty/epoll%E5%AE%9E%E7%8E%B0.png"></p>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>异步 IO（AIO）指用户线程发起 IO 请求后可以继续执行，由另一个线程在数据复制完成后通过回调将数据传递给用户线程。因此异步 IO 一定是非阻塞的<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=50">https://www.bilibili.com/video/BV1py4y1E7oA?p=50</a></p>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><blockquote>
<p>Netty 是一个基于 JavaNIO 的网络通信框架，屏蔽了底层 IO 通信的技术细节，封装了很多常用的网络通信协议，通过责任链模式保证了程序的扩展性。用户只需要专注于处理半包黏包问题、网络协议的编解码和业务逻辑的处理。</p>
</blockquote>
<p>Netty 用到了这些技术：</p>
<ul>
<li>Epoll 模式的多路复用技术</li>
<li>Reactor 设计模式</li>
<li>主从多线程模型</li>
</ul>
<h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><p>基于 Netty 编写 C&#x2F;S 端，一次 C—&gt;S 通信流程可以拆分为这么几个步骤：</p>
<ul>
<li>客户端向服务器端发起 tcp 连接建立请求</li>
<li>服务器端 bossEventLoop 线程的 selector 监听到 accept 事件，调用 ChannelInitializer 的回调方法初始化客户端 SocketChannel，往 channel 的 pipeline 上添加自定义的 Handler</li>
<li>将 socketChannel 注册给 workerEventLoop 线程的 selector，监听该连接上后续的读写事件</li>
<li>客户端在连接建立后，调用 ChannelInitializer 的回调方法初始化该连接 socketChannel，往 channel 的 pipeline 上添加自定义的 Handler</li>
<li>客户端使用该 socketChannel 向服务端发送数据</li>
<li>服务端 workerEventLoop 线程的 selector 监听到 read 事件，调用 socketChannel 的 pipeline 上的 handler 处理请求，这会回调到业务之前添加的自定义 handler 执行业务逻辑</li>
</ul>
<h2 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h2><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>客户端 Netty 引导类，负责在客户端初始化和启动 netty 组件</p>
<h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><p>服务端 Netty 引导类，负责在服务端初始化和启动 netty 组件</p>
<h3 id="NioXxxChannel"><a href="#NioXxxChannel" class="headerlink" title="NioXxxChannel"></a>NioXxxChannel</h3><p>netty 里的 channel，对应 nio 里的 Channel，表示一个网络连接，包括 NioSocketChannel，NioServerSocketChannel</p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>每个 channel 都有自己的 pipeLine 责任链，它维护一个双向链表，channel 的 io 事件会根据事件类型（in\out）交给链表里匹配的 channelHandler 处理</p>
<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>channel 的 IO 事件处理器，作为双向链表的节点挂载在 channelPipeLine 上</p>
<h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>NioEventLoop 内部维护一个工作线程和一个 Selector，可以监听和执行绑定在 Selector 上的 channel 的 IO 事件，也可以执行普通任务和定时任务</p>
<p>与 NioEventLoop 类似的是<code>DefaultEventLoop</code>，区别是它不能监听 IO 事件（没有 Selector），只能执行普通和定时任务。可以把一些 socketChannel 的 pipeline 上比较耗时的 handler 处理指定给 DefaultEventLoop 执行（通过给 handler 指定 DefaultEventLoopGroup，默认 handler 指定的是 NioEventLoopGroup），避免占用 NioEventLoop 的线程时间导致其他 socketChannel 的 IO 处理受影响。</p>
<ul>
<li>pipeLine 的 handlers 在链式处理 IO 事件过程中，判断当前线程与下一个 handler 绑定的 eventLoop 所在线程，如果一致，则继续调下一个 handler 处理，如果不一致，则提交任务到下一个 handler 绑定的 eventLoop 所在线程，从而实现执行 handler 线程的切换。</li>
<li>需要注意，其实每个请求的整体响应时间并没有缩短，反而因为线程切换的开销有所延长，但总比直接把线程打满导致后面的请求得不到响应要好很多！即，异步的作用是提升吞吐量而非提升性能！</li>
</ul>
<p>NioEventLoop 逻辑上可以分为 BossNioEventLoop 和 WorkerNioEventLoop，前者只负责监听服务端 SocketChannel 的 accept 事件，后者只负责监听客户端 socketChannel 的读写事件。这么划分的目的是利用了异步多线程的优势，将建立连接和读写客户端连接分开在不同线程处理，避免性能相互影响，从而让 accept 的 nioEventLoop 线程尽快空闲下来执行新的建立连接事件，进而能提升系统的吞吐量（qps）</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=70">https://www.bilibili.com/video/BV1py4y1E7oA?p=70</a></li>
</ul>
<h3 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h3><p>管理一组 NioEventLoop 线程。提供一个自定义线程池 ThreadPerTaskExecutor，为每个 NioEventLoop 创建独立的线程。默认会创建 2 倍当前机器 CPU 核数的 EventLoop</p>
<p>它的作用主要是负载均衡，将 channel 均分给 Loop 线程来监听和执行 IO 事件</p>
<p>逻辑上 NioEventLoopGroup 又分为两类，BossNioEventLoopGroup 管理 BossNioEventLoop，WorkerNioEventLoopGroup 管理 WorkerNioEventLoop。服务端 BossNioEventLoopGroup 在接收到客户端 socket 连接后，会负载均衡地将客户端连接均分注册到 WorkerNioEventLoopGroup 内部的 WorkerNioEventLoop 的 Selector 上，后续该客户端连接上的 IO 事件都会在分配的 WorkerNioEventLoop 线程上处理</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>客户端 NioSocketChannel 调用 connect 请求建立连接或 close 断开连接后，返回一个异步凭证 ChannelFuture。可以调用它的 sync 方法让当前线程阻塞直到连接建立&#x2F;断开，再从 ChannelFuture 拿到建连&#x2F;断开后的 Channel。也可以给 ChannelFuture 添加一个 Listener 方法，在连接建立&#x2F;断开后异步回调该方法，拿到建连&#x2F;断开后的 channel。</p>
<ul>
<li>注意，执行建连&#x2F;断开的线程实际为 NioEventLoop，所以执行 listener 方法也默认会在该线程执行，而非原发起调用 connect&#x2F;close 的线程。</li>
<li>异步：发起调用的线程和执行调用的线程是两个线程，发起调用的线程非阻塞。可以通过添加 listener 回调执行异步计算后的逻辑，也可以通过异步凭证 Future 同步阻塞获取结果，执行后续逻辑。</li>
</ul>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>Netty 的 ByteBuf 可以理解为 nio 里的 ByteBuffer，默认创建返回的是<code>直接内存</code>，读写性能更好（不过创建时不如使用 java 的堆内存快）</p>
<p>ByteBuf 相对于 ByteBuffer 做了这些优化：</p>
<ul>
<li>自动扩容<ul>
<li>当写入的字节数超过预设大小时会自动扩容</li>
</ul>
</li>
<li>池化，避免高并发下重复创建 ByteBuf<ul>
<li>默认创建直接内存的代价较高</li>
</ul>
</li>
<li>读写模式切换时不需要调 api<ul>
<li>ByteBuf 将读写用两个指针表示，ByteBuffer 的读写是共用指针的，所以要调 api 来切换模式</li>
</ul>
</li>
<li>支持切片 slice，即对 ByteBuf 做切分，单独处理其中某一部分空间<ul>
<li>底层也是通过读写指针实现</li>
<li>不需要将分片数据单独复制到另一个 ByteBuf 上，是“零拷贝”的思想</li>
</ul>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=81">https://www.bilibili.com/video/BV1py4y1E7oA?p=81</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=86">https://www.bilibili.com/video/BV1py4y1E7oA?p=86</a></p>
<h2 id="Netty-组件架构图"><a href="#Netty-组件架构图" class="headerlink" title="Netty 组件架构图"></a>Netty 组件架构图</h2><p><img src="/Netty/Netty%E7%BB%84%E4%BB%B6%E8%A7%86%E5%9B%BE.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="服务端启动-netty"><a href="#服务端启动-netty" class="headerlink" title="服务端启动 netty"></a>服务端启动 netty</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleServer &#123;</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    public SimpleServer(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() throws Exception &#123;</span><br><span class="line">        //EventLoopGroup是用来处理IO操作的多线程事件循环器</span><br><span class="line">        //bossGroup 用来接收进来的连接</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        //workerGroup 用来处理已经被接收的连接</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            //启动 NIO 服务的辅助启动类</span><br><span class="line">            ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                //配置 Channel</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                        // 注册handler</span><br><span class="line">                        ch.pipeline().addLast(new SimpleServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line"></span><br><span class="line">            // 绑定端口，开始接收进来的连接</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            // 等待服务器 socket 关闭 。</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new SimpleServer(9999).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端 Netty 程序启动入口：io.netty.bootstrap.AbstractBootstrap#bind(int)</p>
<p>总体分为 init-&gt;register-&gt;bind 三个阶段。</p>
<p>init 阶段构建 NioServerSocketChannel，在用户线程执行：</p>
<ul>
<li>创建 Netty 的 NioServerSocketChannel<ul>
<li>内部会创建 jdk 的 nio 包下的 ServerSocketChannel 作为成员变量</li>
</ul>
</li>
<li>将 ChannelInitializer（本质是一个 Handler，和其他 handler 的区别是它的 initChannel 方法只会执行一次）添加到 NioServerSocketChannel 的 pipeLine</li>
<li>将注册任务提交到 NioEventLoop 执行，返回异步注册结果 Promise 对象给用户线程</li>
<li>注册结果 Promise 对象添加回调方法（在用户线程执行注册后回调）</li>
</ul>
<p>register 阶段将 NioServerSocketChannel 注册到 selector，在 NioEventLoop 的线程异步执行：</p>
<ul>
<li>把 NioServerSocketChannel 里 jdk 原生的 ServerSocketChannel 注册到 NioEventLoop 线程的 selector 上，且 NioServerSocketChannel 作为附件，目的是通过附件的 channel 拿到 pipeLine 处理 IO 事件</li>
<li>执行上面的 ChannelInitializer 的 initChannel 方法，向 pipeLine 添加一个 accept 事件 Handler</li>
<li>触发 register 事件让 pipeLine 上的 inHandler 执行<ul>
<li>因为我们无法给 NioServerSocketChannel 的 pipeLine 添加自己的 handler，所以也感知不到</li>
</ul>
</li>
</ul>
<p>bind 阶段完成端口绑定，在用户线程调用注册后回调时执行，它又会将任务提交到 NioServerSocketChannel 关联的 eventLoop 线程执行</p>
<ul>
<li>触发 bind 事件让 pipeLine 上的 outHandler 执行，最后由 headHandler 给 jdk 原生的 ServerSocketChannel 绑定端口号</li>
<li>触发 active 事件让 pipeLine 上的 inHandler 执行，headHandler 在 readIfIsAutoRead 方法里会设置 NioServerSocketChannel 关注的 IO 事件为 Accept 事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    this.readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doBeginRead() throws Exception &#123;</span><br><span class="line">    SelectionKey selectionKey = this.selectionKey;</span><br><span class="line">    if (selectionKey.isValid()) &#123;</span><br><span class="line">        this.readPending = true;</span><br><span class="line">        int interestOps = selectionKey.interestOps();</span><br><span class="line">        if ((interestOps &amp; this.readInterestOp) == 0) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | this.readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端启动-netty"><a href="#客户端启动-netty" class="headerlink" title="客户端启动 netty"></a>客户端启动 netty</h3><p>客户端启动 demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleClient &#123;</span><br><span class="line"></span><br><span class="line">    public void connect(String host, int port) throws Exception &#123;</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap b = new Bootstrap();</span><br><span class="line">            b.group(workerGroup);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line">            b.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(new SimpleClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            // Start the client.</span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            // Wait until the connection is closed.</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SimpleClient client=new SimpleClient();</span><br><span class="line">        client.connect(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端 Netty 程序启动入口：io.netty.bootstrap.Bootstrap#connect(java.lang.String, int)<br>总体分为 init-&gt;register-&gt;connect 三个阶段，和 Server 端存在一些区别：</p>
<ul>
<li><p>注册阶段向 Channel 的 pipeLine 加入自定义 handler 的区别</p>
<ul>
<li>服务端 Channel 不能加入用户定义的 handler，加入的是 Netty 自带的<code>ServerBootstrapAcceptor</code>，它的作用是在 channelRead 方法里专门处理 Accept 事件。用户定义的 handler 是在服务端接到客户端请求后，加到该客户端 channel 的 pipeLine 上</li>
<li>客户端 Channel 能加入用户定义的 handler</li>
</ul>
</li>
<li><p>绑定阶段替换为连接阶段</p>
<ul>
<li>bind 阶段变成 connect 阶段，也是提交任务在 nioEventLoop 线程执行，调用 channel 的 pipeLine 上的 outHandlers 处理 connect 事件，向服务度发起 tcp 连接</li>
<li>连接完成（建立 tcp 连接成功）后，触发 active 事件交给 channel 的 pipeLine 上的 inHandlers 处理，headHandler 在 readIfIsAutoRead 方法里会设置 NioSocketChannel 关注的 IO 事件为 READ 事件</li>
</ul>
</li>
</ul>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/Netty/Netty%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"></p>
<p>有些细节需要特别说明：</p>
<ul>
<li>DefaultChannelPipeline 是一个双向链表，初始化后有 head 和 tail 节点（head 节点本身是 out 类型节点，是 in 类型 IO 事件的入口，tail 节点相反）</li>
<li>如果想将自定义的 channelHandler 添加到 PipeLine，通过将 add 逻辑写到 ChannelInitializer 的 initChannel 方法来实现。该方法在 channel 注册到 selector 的流程中被回调执行，执行后 channelInitializer 会从 pipeLine 双向链表里 remove。因此 channelInitializer 的使命就是将自定义 channelHandler 添加到 pipeLine</li>
<li>NioEventLoopGroup 的默认 chooser 通过一个原子计数器，每次 choose 的时候计数器+1 后对 NioEventLoop 个数取模得到选取的下标，可以理解为顺序选取 NioEventLoop，每个 NioEventLoop 线程均匀承接 channel，达到负载均衡</li>
<li>nioEventLoopGroup 负责为 nioEventLoop 创建线程，而 loop 线程里主要做两件事<ul>
<li>轮询获取注册到 nioEventLoop 内部 selector 上的所有 channel 的 IO 事件，调用 channel 的责任链 pipeline 上 handlers 处理</li>
<li>执行提交到 nioEventLoop 队列的所有任务（包括定时任务）<ul>
<li>channel 注册流程就是作为任务提交到 nioEventLoop 的任务队列，在 loop 线程里执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="accept-流程"><a href="#accept-流程" class="headerlink" title="accept 流程"></a>accept 流程</h3><p>selector 监听到 NioServerSocketChannel 的客户端建连请求 accept 事件（从全连接队列取出客户端连接）后，在 bossNioEventLoop 线程上执行 accept 流程</p>
<ul>
<li>为客户端连接创建好 NioSocketChannel，封装 nio 原生的客户端 socketChannel</li>
<li>调用 NioServerSocketChannel 的 pipeLine 上的 handlers 处理该 NioSocketChannel，核心在 acceptorHandler 上，它向 workerNioEventLoopGroup 上某个 NioEventLoop 提交一个异步注册任务<ul>
<li>把 NioSocketChannel 注册到该 NioEventLoop 的 selector 上</li>
<li>回调 Server 端用户定义的 ChannelInitializer，把和客户端打交道的 handler 添加到 NioSocketChannel 的 pipeLine 上</li>
<li>在 NioSocketChannel 的 pipeLine 上执行 Active 事件，设置 selector 关心该 NioSocketChannel 的 READ 事件</li>
</ul>
</li>
</ul>
<h3 id="Netty-的通用设计"><a href="#Netty-的通用设计" class="headerlink" title="Netty 的通用设计"></a>Netty 的通用设计</h3><p>通过上述客户端、服务端启动流程和服务端 accept 流程的分析，不难发现一些 Netty 的通用设计。</p>
<ul>
<li>都是通过提交一个注册任务到 NioEventLoop，异步完成注册流程<ul>
<li>服务端 NioServerSocketChannel 注册、客户端 NioSocketChannel 注册、服务端 accept 客户端连接并注册 NioSocketChannel</li>
</ul>
</li>
<li>注册完成后会再提交一个异步任务到 NioEventLoop 执行，任务的核心是触发一个 IO 事件在 Channel 的 pipeLine 上传递处理<ul>
<li>服务端 NioServerSocketChannel 注册完成后触发 bind 事件来绑定端口，绑定成功后再触发 active 事件让 NioServerSocketChannel 关注 ACCEPT 事件</li>
<li>客户端 NioSocketChannel 注册完成后触发 connect 事件来建立和服务端 tcp 连接，建立成功后再触发 active 事件让 NioSocketChannel 关注 READ 事件</li>
<li>accept 的客户端连接注册完成后触发 active 事件让 NioSocketChannel 关注 READ 事件</li>
</ul>
</li>
</ul>
<h3 id="NioEventLoop-1"><a href="#NioEventLoop-1" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>NioEventLoop 内部有三个核心成员变量：Selector、线程、任务队列。</p>
<p>Selector：<br>netty 针对 nioEventLoop 的 selector 做了性能优化。当 io 事件发生时，nio 原生的 selector 使用哈希表存储这些 selectionKeys，因此遍历这些代表 io 事件的 selectionKeys 的效率不高。netty 包装了 nio 原生的 selector，使用数组来存储 selectionKeys，因此遍历的性能有所提升。</p>
<p>线程：<br>nioEventLoop 内部维护了一个单线程，<code>首次</code>提交任务给 nioEventLoop 时启动线程。<br>该线程会死循环执行提交到 nioEventLoop 的任务、定时任务和注册到 selector 上的 channel 产生的 io 事件。逻辑为：</p>
<ul>
<li>判断任务队列是否有任务<ul>
<li>有任务，调用 selector.selectNow 获取 IO 事件，然后执行 IO 事件和任务队列里的任务</li>
<li>没有任务，调用 selector.select 带超时参数的方法，阻塞一定时间等待 IO 事件<ul>
<li>当其他线程提交任务给 nioEventLoop 时，会唤醒 Selector 的阻塞方法 select，开始执行 io 事件和任务</li>
<li>在 Linux 环境下，select 方法偶现不阻塞的情况，这会导致线程在死循环里一直运行，CPU 空转。这就是 netty 著名的<code>空轮训bug</code>。Netty 的解法是引入一个循环计数器，超过阈值（默认 512）就认为产生了空轮训 bug，然后重建一个 selector 替换之前的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以通过 ioRatio 参数来控制执行 io 事件和任务的时间占比。例如设为 80，则执行任务的时间为 IO 事件时间的 1&#x2F;4。不过如果设置为 100，并非只执行 IO 事件，而是 IO 事件执行完接着把任务队列里的任务也都执行完</p>
<h2 id="黏包半包与帧解码器"><a href="#黏包半包与帧解码器" class="headerlink" title="黏包半包与帧解码器"></a>黏包半包与帧解码器</h2><p>黏包半包产生的本质原因是 tcp 协议为流式协议，消息无边界。具体原因有下面几种：</p>
<ul>
<li>tcp 提供可靠传输，需要对端的 ack 才能继续发送下一条数据，为了提高通信效率以及控制流量，tcp 协议的发端使用“滑动窗口”的思想，提供一个发送缓冲区，缓冲区内的每条应用层数据可以不等对端的 ack 就直接发送，当接收到某条消息的 ack 后，窗口才可以继续向下滑动，发送后面的数据。因此，当网络拥塞时，就可能产生半包现象，后面的数据还没发送过来。当网络顺畅时，就可能产生黏包现象，多条应用层数据同时发过来。</li>
<li>tcp 和 ip 层的协议头各占 20 字节，如果应用层一次发送数据的字节过少，会因为协议字段的数据白白浪费带宽，因此对于这种情况也会把多条数据合并在一起发送，产生黏包现象</li>
<li>netty 的 ByteBuf 默认 1024 字节</li>
</ul>
<p>Netty 通过提供一些通用的帧（一条完整的消息数据）解码器来解决黏包半包问题：</p>
<ul>
<li>提供一个定长帧解码器 handler，无论该 socketChannel 的 ByteBuf 上缓存了多少字节，他都按照设置的固定长度拆分后交给后面的 handler 处理，所以只要客户端和服务器端约定好每次发送数据的长度就不会出现黏包半包问题。为了满足所有场景，定长的字节数会比较大，对于一些字节数少的消息比较浪费空间</li>
<li>提供一个指定字符串作为分隔符的帧解码器 handler，当匹配到该字符串即认为一条消息结束，将该消息截取后发送给下游 handler 处理。注意，需要给该解码器指定消息的最大长度，如果读取了最大长度都没匹配到分隔符，会抛出异常。该解法因为要匹配分隔符，所以效率不高</li>
<li>提供一个基于解析长度字段的帧解码器 handler，创建该 handler 时通过构造参数指定长度字段从协议消息数据的几个字节偏移量开始占据几个字节，以及后面的消息内容从几个字节偏移量后开始读取</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=97">https://www.bilibili.com/video/BV1py4y1E7oA?p=97</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=98">https://www.bilibili.com/video/BV1py4y1E7oA?p=98</a></p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>所谓通信协议，即一套数据传输字节流的约定格式，哪些字节表达哪些特定含义。发送端按照协议将应用层数据转成 Byte 数组写入 ByteBuf，这一过程称为协议编码，接收端按照协议格式解析 ByteBuf 里收到的字节数组，转成业务对象，这一过程称为协议解码。<br>对于 netty 而言，实现基于协议的双端通信，需要提供协议编码器 handler 和解码器 handler。不过，netty 已经封装好了一些常用协议的编解码器（codec）handler，如 http、https、redis、websocket 等。如果需要自定义一套通信协议，需要提供该协议的编解码器（codec）handler<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=99">https://www.bilibili.com/video/BV1py4y1E7oA?p=99</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=100">https://www.bilibili.com/video/BV1py4y1E7oA?p=100</a></p>
<p>注意，消息接收端在协议解析前仍然需要添加帧解码器 handler（通常是基于解析长度字段的帧解码器 handler），否则仍然会出现半包黏包问题造成协议被错误解析<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=104">https://www.bilibili.com/video/BV1py4y1E7oA?p=104</a><br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=105">https://www.bilibili.com/video/BV1py4y1E7oA?p=105</a></p>
<h2 id="连接状态监测"><a href="#连接状态监测" class="headerlink" title="连接状态监测"></a>连接状态监测</h2><p>Netty 提供了一个 Channel 的读写事件空闲检测器 handler。服务端可以使用该 handler 监测已建立连接的 socketChannel 是否读空闲，即超过一定时间没有读事件到来。客户端可以使用该 handler 监测自身有多久没有给服务器写（发送）数据了。当发生读空闲、写空闲时，Netty 会发送相应的事件交给 pipeLine 处理。这时会用到 Netty 提供的另一个 ChannelDuplexHandler，处理空闲读、空闲写事件。服务端处理读空闲事件可以简单地断开连接，客户端处理写空闲事件可以发送心跳包。采用这种策略需要注意，读空闲判定的时长阈值一定要大于写空闲判定的时长阈值，否则客户端还没发心跳包，就会被服务端强制断开连接<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=117">https://www.bilibili.com/video/BV1py4y1E7oA?p=117</a></p>
<h2 id="可配置参数"><a href="#可配置参数" class="headerlink" title="可配置参数"></a>可配置参数</h2><p>Netty 提供了一些服务端和客户端的配置参数，可由用户在构建 Netty 程序时动态指定参数值</p>
<ul>
<li>客户端最大连接超时时间<ul>
<li>只作用于客户端，Netty 底层会创建一个延时任务，延时时长就是这里指定的超时时间。如果客户端和服务器在超时时间内连接建立完成就会取消该延时任务，否则执行延时任务，给连接建立 Future（Netty 的连接建立是异步的）设置异常，原线程获取建连的 Future 结果会抛出异常</li>
<li><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=123">https://www.bilibili.com/video/BV1py4y1E7oA?p=123</a></li>
</ul>
</li>
<li>全连接队列大小<ul>
<li>客户端和服务器建连要经过 TCP 三次握手，第一次服务端收到客户端发的 SYN 消息后，会将客户端连接放入半连接队列。第二次服务端收到客户端的 ACK 消息后，会将客户端连接放入全连接队列。服务端执行 ACCEPT 事件会从全连接队列取走客户端连接</li>
<li>Netty 提供配置参数来设置全连接队列大小。注意，Linux 系统在配置文件里也指定了全连接队列的大小，这时会取二者的最小值</li>
<li><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=125">https://www.bilibili.com/video/BV1py4y1E7oA?p=125</a></li>
</ul>
</li>
</ul>
<h2 id="Netty-解决-NIO-空轮询-bug"><a href="#Netty-解决-NIO-空轮询-bug" class="headerlink" title="Netty 解决 NIO 空轮询 bug"></a>Netty 解决 NIO 空轮询 bug</h2><p>所谓 NIO 空轮询 bug，指调用 Selector.select 轮询方法等待 channel 事件到来，但这个阻塞方法有时在没有 channel 事件到来时也可能直接返回，即出现了空轮询，然后再次回到 while 循环不断空轮询，最终导致 CPU 利用率飙到 100%，程序崩溃。</p>
<p>Netty 在 io.netty.channel.nio.NioEventLoop#select 方法里解决了空轮询 bug，具体做法是：</p>
<ul>
<li>检测到 while 死循环里空轮询次数达到阈值（默认 512）时，重建 nioEventLoop 的 selector，然后将注册到老 selector 的 channel 重新注册到新 selector</li>
</ul>
<h2 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h2><blockquote>
<p>reactor 设计模式</p>
</blockquote>
<p>Reactor 模式是处理并发 I&#x2F;O 比较常见的一种模式，中心思想是将所有要处理的 I&#x2F;O 事件注册到一个中心 I&#x2F;O 多路复用器上，主线程阻塞监听注册在多路复用器上的 I&#x2F;O 事件；一旦有 I&#x2F;O 事件到来或是准备就绪，多路复用器返回并将相应 I&#x2F;O 事件分发到对应的处理器中处理。</p>
<p>优点：</p>
<ul>
<li>多路复用技术节省了服务端线程数，避免了多线程切换带来的性能问题</li>
<li>可水平扩展。灵活增加多路复用器来处理高并发请求</li>
</ul>
<p>基于 Reactor 模式，Netty 线程模型分为三种：</p>
<ul>
<li>单线程模型：所有 IO 事件（ACCEPT、读写事件）都在一个线程里监听和处理，适合并发极低的场景</li>
<li>多线程模型：ACCEPT 事件单线程，和客户端的读写事件多线程。对于登录、认证耗时的场景，也存在性能问题。</li>
<li>主从多线程模型：ACCEPT 事件在主线程池里分配线程处理，和客户端的读写事件在从线程池里分配线程处理。<code>Netty推荐使用这种线程模型</code></li>
</ul>
<p>主从多线程模型的优势：</p>
<ul>
<li>多线程方式解决了单点性能问题</li>
<li>主从线程池解决了 ACCEPT 事件中可能出现的一些耗时操作（登录、认证）带来的性能问题</li>
<li>每个 SocketChannel 都在唯一一个 NioEventLoop 线程里执行 IO，确保了这些操作都是线程安全的</li>
</ul>
<p>在 Netty 组件中，NioEventLoopGroup 扮演了线程池角色，主从线程模型中分别有一个主 NioEventLoopGroup，用线程池并发处理多个 NioServerSocketChannel（多个服务端的 ip:port）上的 ACCEPT 事件。从 NioEventLoopGroup 负责多线程并发处理所有 Server 接收到的客户端 NioSocketChannel 的读写事件。NioEventLoop 扮演执行线程角色，监听注册在它内部的多路复用器 Selector 上的所有 channel 的 IO 事件并调用 channel 的 handlers 链式处理。</p>
<p><img src="/Netty/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B1.png"></p>
<p><img src="/Netty/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"></p>
<h1 id="基于-Netty-实现聊天工具-x2F-RPC-框架"><a href="#基于-Netty-实现聊天工具-x2F-RPC-框架" class="headerlink" title="基于 Netty 实现聊天工具&#x2F;RPC 框架"></a>基于 Netty 实现聊天工具&#x2F;RPC 框架</h1><p>基于 TCP&#x2F;IP 的网络编程应用必须考虑上面提到的黏包半包问题和通信协议，因此如果基于 Netty 实现，必备的就是帧解码器 handler 和协议编解码器 codecHandler，以及一些业务 handler。</p>
<p>服务端 Handler（顺序从 head 到 tail，即读事件 handler 执行顺序）：</p>
<ul>
<li>基于解析长度字段的帧解码器 handler<ul>
<li>处理黏包半包</li>
</ul>
</li>
<li>协议编解码器 codecHandler<ul>
<li>返回解码后的业务对象或者将业务对象编码后写入 ByteBuf</li>
</ul>
</li>
<li>Inbound 类型的业务 handler<ul>
<li>【聊天工具】用户登录验证</li>
<li>【聊天工具】处理发送聊天消息请求</li>
<li>【rpc 框架】处理 rpcRequest，反射调用接口，将结果写到 rpcResponse 并 write 回 socketChannel</li>
</ul>
</li>
</ul>
<p>客户端 Handler（顺序从 head 到 tail，即读事件 handler 执行顺序）：</p>
<ul>
<li>基于解析长度字段的帧解码器 handler<ul>
<li>处理黏包半包</li>
</ul>
</li>
<li>协议编解码器 codecHandler<ul>
<li>返回解码后的业务对象或者将业务对象编码后写入 ByteBuf</li>
</ul>
</li>
<li>Inbound 类型的业务 handler<ul>
<li>【聊天工具】读取连接建立事件，发送登录请求</li>
<li>【聊天工具】读取服务端登录响应，发送消息</li>
<li>【rpc 框架】读取 rpcResponse</li>
</ul>
</li>
</ul>
<p>对于聊天工具，客户端只需要维护当前聊天者自己的 socketChannel，持有它来发送消息，而从服务端接收到的消息一定是发给自己的，这可以由服务端保证。<br>服务端维护每个登陆用户和 socketChannel 的映射关系，在处理发送聊天消息请求时读取到接收人，调用他的 socketChannel 发送消息数据到客户端。</p>
<p>对于 RPC 框架，客户端（调用方）需要<code>将rpc服务使用动态代理进行包装</code>，用户线程在发起 rpc 调用时走到动态代理的增强逻辑，先封装 rpcRequest，然后拿到与 rpc 服务端建立好的 socketChannel（如果请求的是同一个 rpc 服务端，socketChannel 可以复用）发送 rpcRequest。</p>
<p>注意，发送 rpcRequest 是在 nioEventLoop 线程执行的，而接收 rpcResponse 也是在 nioEventLoop 线程执行的，所以用户线程在发起 rpc 调用到接收到响应是异步的（不同线程间执行操作）。那么用户线程如何拿到 rpcResponse，即异步线程间如何通信呢？</p>
<p>Netty 使用 Promise 来实现异步线程间结果通信（可以理解为 jdk 里的 Future）</p>
<ul>
<li>用户线程使用 socketChannel 发起 rpc 网络请求</li>
<li>需要创建用于接收 rpcResponse 的 Promise 对象，为 Promise 指定执行线程</li>
<li>将 rpcRequest 里的 sequenceId 和 Promise 对象通过全局 Map 做映射</li>
<li>调用 Promise 对象的 await 阻塞等待异步返回的 rpcResponse</li>
</ul>
<p>这样，客户端收到 rpcResponse 后：</p>
<ul>
<li>通过 rpcResponse 里的 sequenceId 拿到 Promise</li>
<li>将结果 set 给 Promise<ul>
<li>在 Promise 指定的线程里执行</li>
</ul>
</li>
<li>用户线程结束阻塞，拿到结果作为动态代理的结果返回给调用方，完成一次 rpc 请求。<br><a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=136">https://www.bilibili.com/video/BV1py4y1E7oA?p=136</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/cj2580/java/article/details/78087101">https://blog.csdn.net/cj2580/java/article/details/78087101</a><br><a href="https://blog.csdn.net/zgege/java/article/details/81632990">https://blog.csdn.net/zgege/java/article/details/81632990</a><br><a href="https://zhuanlan.zhihu.com/p/23488863">https://zhuanlan.zhihu.com/p/23488863</a><br><a href="https://wenjie.store/archives/netty-nioeventloop-boot-2">https://wenjie.store/archives/netty-nioeventloop-boot-2</a><br><a href="https://blog.csdn.net/eric_sunah/article/details/80437025?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1">https://blog.csdn.net/eric_sunah/article/details/80437025?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1</a></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Rxjava</title>
    <url>/2022/05/01/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Rxjava/</url>
    <content><![CDATA[<p>参考：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/88aacbed8aa5">https://www.jianshu.com/p/88aacbed8aa5</a></p>
</blockquote>
<p>以下介绍基于Rxjava2</p>
<h1 id="reactive是什么"><a href="#reactive是什么" class="headerlink" title="reactive是什么"></a>reactive是什么</h1><blockquote>
<p>一种基于观察者模式的响应式编程范式。</p>
</blockquote>
<p>{待补充}</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>先看看基于Rxjava2的reactive编程最简demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Object&gt; observableEmitter) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).subscribe(new Observer&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(@NonNull Object s) &#123;</span><br><span class="line">        //订阅业务代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable disposable) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable throwable) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，是一种<code>链式调用</code>的写法</p>
<p>Observable.create会返回一个ObservableCreate，他本身也是一个Observable。</p>
<p>Observable是一个模板类，首先看一下Observable的subscribe方法，这是真正执行消费逻辑的起点。subscribeActual是模板方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SchedulerSupport(&quot;none&quot;)</span><br><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">        ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;);</span><br><span class="line">        this.subscribeActual(observer);</span><br><span class="line">    &#125; catch (NullPointerException var4) &#123;</span><br><span class="line">        throw var4;</span><br><span class="line">    &#125; catch (Throwable var5) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(var5);</span><br><span class="line">        RxJavaPlugins.onError(var5);</span><br><span class="line">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&#x27;t throw other exceptions due to RS&quot;);</span><br><span class="line">        npe.initCause(var5);</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObservableCreate的subscribeActual方法实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObservableCreate.CreateEmitter&lt;T&gt; parent = new ObservableCreate.CreateEmitter(observer);</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.source.subscribe(parent);</span><br><span class="line">    &#125; catch (Throwable var4) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(var4);</span><br><span class="line">        parent.onError(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>subscribeActual方法做了这几件事：</p>
<ul>
<li>Observer包装成CreateEmitter，</li>
<li>Observer和Emitter彼此持有对方的引用</li>
<li>调用ObservableOnSubscribe的subscribe方法（ObservableCreate构造方法里注入source，类型是ObservableOnSubscribe）</li>
</ul>
<blockquote>
<p>执行流程</p>
</blockquote>
<p>Observer包装成Emitter –&gt;<br>ObservableOnSubscribe生产事件，调用Emitter的onNext方法将事件传递给订阅者 –&gt;<br>Emitter执行一些框架自身的逻辑功能（比如流控），然后调用Observer的onNext方法将事件传递回Observer –&gt;<br>执行Observer的onNext方法</p>
<blockquote>
<p>执行链路</p>
</blockquote>
<p>Observer –(包装)–&gt; Emitter –(传递)–&gt; ObservableOnSubscribe –(回调)–&gt; Emitter –(回调)–&gt; Observer</p>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>Rxjava框架提供核心类：ObservableCreate。核心方法：subscribeActual。</li>
<li>ObservableCreate负责将事件源的生产与消费串联起来。当然，还有负责事件源类型映射的ObservableMap等。</li>
<li>ObservableCreate拿到业务方的Observer实现类，包装成CreateEmitter（RxJava提供的事件发送器）传递给事件源生产者ObservableOnSubscribe。</li>
<li>ObservableCreate注入业务方的ObservableOnSubscribe实现类，调用其subscribe方法执行“事件源的生产逻辑”。方法内部逻辑：生产事件源Object，通过Emitter向下传递到Observer，执行消费逻辑。</li>
</ul>
<p>所以使用reactive编程的基本模式：</p>
<ul>
<li>自定义Observer（负责事件源的消费）</li>
<li>实现ObservableOnSubscribe接口的subscribe方法（负责事件源的生产）</li>
</ul>
<h2 id="加工“事件源”"><a href="#加工“事件源”" class="headerlink" title="加工“事件源”"></a>加工“事件源”</h2><p>先看下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123;            </span><br><span class="line">    @Override            </span><br><span class="line">    public void call(@NonNull Observer&lt;Object&gt; e) throws Exception &#123;</span><br><span class="line">        // 生产并发送数据源            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(new Function&lt;Object, String&gt;() &#123;</span><br><span class="line">    @Override            </span><br><span class="line">    public String apply(@NonNull Object o) throws Exception &#123;</span><br><span class="line">        // 数据源类型转换              </span><br><span class="line">        // return &quot;Obj&quot;;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override            </span><br><span class="line">    public void onNext(@NonNull String s) &#123;</span><br><span class="line">        //订阅业务代码            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Observable可以调用map\filter等方法对事件源进行加工</p>
<p>Observable调用create创建ObservableCreate，调用map创建ObservableMap</p>
<p>下面是ObservableMap的subscribeActual方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    this.source.subscribe(new ObservableMap.MapObserver(t, this.function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObservableMap把Observer包装为MapObserver，Function是业务方自定义的映射函数，然后调用ObservableCreate的subscribe方法执行“事件源的生产与发送”。对于ObservableMap，source就是级联调用上一级的Observable实现类，这个demo里就是ObservableCreate</p>
<p>MapObserver的“发送数据源”onNext方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (!this.done) &#123;</span><br><span class="line">        if (this.sourceMode != 0) &#123;</span><br><span class="line">            this.downstream.onNext((Object)null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object v;</span><br><span class="line">            try &#123;</span><br><span class="line">                v = ObjectHelper.requireNonNull(this.mapper.apply(t), &quot;The mapper function returned a null value.&quot;);</span><br><span class="line">            &#125; catch (Throwable var4) &#123;</span><br><span class="line">                this.fail(var4);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.downstream.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>downstream是业务方实现类Observer的引用，mapper是业务方定义的映射函数，这两个参数均在构造函数里指定了。</p>
<p>上层（ObservableCreate）调用onNext生产并发送数据后，调用下层MapObserver的onNext方法。内部逻辑：执行映射函数完成数据源类型转换，最后交给业务方实现的Observer消费数据（onNext方法）。</p>
<blockquote>
<p>执行链路</p>
</blockquote>
<p>Observer –(包装)–&gt; MapObserver –(包装)–&gt; Emitter –(传递)–&gt; ObservableOnSubscribe –(回调)–&gt; Emitter –(回调)–&gt; MapObserver –(回调)–&gt; Observer</p>
<p>前半程一层层包装Observer，后半程<code>从顶到底逐层回调</code>每一层Observer包装类的onNext方法消费数据源，直至调到最底层业务方Observer实现类的onNext方法。</p>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>ObservableCreate负责生产和发送数据。生产数据的逻辑由业务方在ObservableOnSubscribe的实现类里控制，发送数据的机制由RxJava框架提供的CreateEmitter负责。</li>
<li>ObservableMap负责完成数据类型的映射。</li>
<li>最后执行业务方Observer的onNext方法消费数据。</li>
</ul>
<p>看到这，基本能看出reactive在实现生产-消费模型的一般思路：</p>
<p>ObservableCreate-&gt;ObservableMap-&gt;ObservableXXX。箭头左边的是右边的parent，右边的ObservableXXX使用一些包装类例如MapObserver、CreateEmitter包装Observer，指定从数据生产后到消费前的处理逻辑。ObservableCreate最终拿到Observer的包装类CreateEmitter，发送数据</p>
<h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><p>所谓流控，在Rxjava架构下，就是消费端（下游）Observer可以决定何时终止对事件源生产端（上游）的消费。</p>
<p>上下游的这种流控通过Disposable实现。</p>
<p>看下Observer的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Observer&lt;T&gt; &#123;</span><br><span class="line">    void onSubscribe(@NonNull Disposable var1);</span><br><span class="line"></span><br><span class="line">    void onNext(@NonNull T var1);</span><br><span class="line"></span><br><span class="line">    void onError(@NonNull Throwable var1);</span><br><span class="line"></span><br><span class="line">    void onComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer的onSubscribe维护一个上游事件生产端创建的Disposable引用，执行dispose方法来终止对上游的消费。</p>
<p>demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void demo8() &#123;</span><br><span class="line">        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;发送&quot; + i);</span><br><span class="line">                    emitter.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            private Disposable disposable;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                disposable = d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                System.out.println(&quot;接收&quot; + integer);</span><br><span class="line">                if (integer &gt; 4) disposable.dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                System.out.println(&quot;数据接受完成&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么，Disposable是何时创建并注入Observer的？</p>
<p>上面提到，ObservableCreate会把Observer包装成一个发射器CreateEmitter，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObservableCreate.CreateEmitter&lt;T&gt; parent = new ObservableCreate.CreateEmitter(observer);</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.source.subscribe(parent);</span><br><span class="line">    &#125; catch (Throwable var4) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(var4);</span><br><span class="line">        parent.onError(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者Observer不持有生产者Observable，而是持有Emitter。生产者Observable也是持有Emitter，可以理解Emitter是生产消费者之间的桥梁。生产者产出的数据通过Emitter传递给消费者，所以Emitter可以承担流控的职责。</p>
<p>CreateEmitter其实是Disposable的一个实现类，Disposable是一次性的意思。流控时，可以理解为消费者不再需要消费了，那么这个Emitter发送器就没有价值了，即它是一次性的，用后即丢。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer想终止消费时，调用Disposable的dispose方法，实际会执行CreateEmiter的dispose方法，将发射器设置为已废弃</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void dispose() &#123;</span><br><span class="line">    DisposableHelper.dispose(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下CreateEmitter的onNext方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        this.onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!this.isDisposed()) &#123;</span><br><span class="line">            this.observer.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，​下游Observer调用dispose方法废弃发射器后，发射器不再回调observer的onNext来消费，达到流控的效果</p>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>CreateEmitter（一个Disposable实现类）和Observer互相持有彼此的引用</li>
<li>CreateEmitter持有Observer来回调下游，执行事件源消费链路</li>
<li>Observer持有CreateEmitter，控制上游是否回调下游进行消费，达到流控的目的。</li>
</ul>
<p>​​​</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>线程切换有两种方法：<code>subscribeOn</code>和<code>observeOn</code></p>
<p>demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void test1() &#123;</span><br><span class="line"></span><br><span class="line">        Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(ObservableEmitter&lt;String&gt; observableEmitter)  &#123;</span><br><span class="line">                System.out.println(&quot;准备&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                    //Thread.sleep(1000);</span><br><span class="line">                    System.out.println(&quot;发射&quot; + &quot; &quot; + Thread.currentThread().getName());</span><br><span class="line">                    observableEmitter.onNext(&quot;123&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                observableEmitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).</span><br><span class="line">            subscribeOn(Schedulers.computation()).</span><br><span class="line">            subscribeOn(Schedulers.io()).</span><br><span class="line">            observeOn(Schedulers.single()).</span><br><span class="line">            map(new Function&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String apply(@NonNull String o) throws Exception &#123;</span><br><span class="line">                //转换业务代码</span><br><span class="line">                System.out.println(&quot;convert&quot; + Thread.currentThread().getName());</span><br><span class="line">                return &quot;Obj&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).</span><br><span class="line">            observeOn(Schedulers.io()).</span><br><span class="line">            subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(@NonNull String s) &#123;</span><br><span class="line">                    //订阅业务代码</span><br><span class="line">                    System.out.println(&quot;接收&quot; + Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onSubscribe(Disposable disposable) &#123;</span><br><span class="line">                    System.out.println(&quot;onSubscribe&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(Throwable throwable) &#123;</span><br><span class="line">                    System.out.println(&quot;onError&quot; + throwable.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line">                    System.out.println(&quot;onComplete&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先说结论：</p>
<ul>
<li>subscribeOn指定上游数据处理执行的线程。上游是相对subscribeOn调用处而言。以上面的例子说明，上游是数据生成和发送。每次调用subscribeOn都对上游生效。如果连续多次调用，第一次调用指定的线程生效</li>
<li>observeOn指定下游数据消费的线程。下游是相对subscribeOn调用处而言。以上面的例子说明，下游是数据Map映射、消费数据。每次调用observeOn都对下游生效。如果连续多次调用，最后一次调用指定的线程生效</li>
</ul>
<p>因此，上面的demo中，数据生产和发送运行在computation线程，数据类型转换运行在single线程，消费端运行在io线程</p>
<h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p>看下subscribeOn方法的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span><br><span class="line">    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn(this, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和map方法类似，也是返回一个Observable，看下它的subscribeActual方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObservableSubscribeOn.SubscribeOnObserver&lt;T&gt; parent = new ObservableSubscribeOn.SubscribeOnObserver(observer);</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line">    parent.setDisposable(this.scheduler.scheduleDirect(new ObservableSubscribeOn.SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是包装了下层的Observer，不过这个SubscribeOnObserver包装类并没有对事件源做其他操作，直接调用了下游observer的onNext方法，这里就不贴代码了。</p>
<p>​重点看下subscribeTask这个任务做了啥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class SubscribeTask implements Runnable &#123;</span><br><span class="line">    private final ObservableSubscribeOn.SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">    SubscribeTask(ObservableSubscribeOn.SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        ObservableSubscribeOn.this.source.subscribe(this.parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，继续向上调用上层Observable的subscribe方法，重点是使得上游的代码都运行在scheduler指定的线程里</p>
<blockquote>
<p>执行链路</p>
</blockquote>
<p>Observer –(包装)–&gt; SubscribeOnObserver –(包装)–&gt; Emitter –(传递)–&gt; ObservableOnSubscribe –(回调)–&gt; Emitter –(回调)–&gt; SubscribeOnObserver –(回调)–&gt; Observer</p>
<p>虽然SubscribeOnObserver没有对Observer做额外处理，但继续调用上层source.subscribe方法时，已经切换到scheduler定义的线程了。因此，上游的所有操作，都会在subscribeOn方法指定的scheduler线程里执行。​​由此可知，如果连续多次调用subscribeOn指定线程，只有第一次起作用</p>
<h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h3><p>observeOn和subscribeOn的思路基本一致，这里只介绍差异。</p>
<p><code>ObserveOnObserver</code>是observeOn方法执行后，对observer的包装类，看下它的onNext方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (!this.done) &#123;</span><br><span class="line">        if (this.sourceMode != 2) &#123;</span><br><span class="line">            this.queue.offer(t);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        this.schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>schedule方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void schedule() &#123;</span><br><span class="line">    if (this.getAndIncrement() == 0) &#123;</span><br><span class="line">        this.worker.schedule(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this指代<code>ObserveOnObserver</code>，它是一个runnable，run方法里会调用下游observer的onNext方法。因此，下游observer的消费代码运行在observeOn方法指定的scheduler线程里。</p>
<h2 id="Flowable背压"><a href="#Flowable背压" class="headerlink" title="Flowable背压"></a>Flowable背压</h2><p>Flowable是Rxjava2较Rxjava的主要更新，可以把它看做是<code>Observable+背压处理</code></p>
<p>那么，什么是<code>背压</code>呢？</p>
<p>当<code>生产速度&gt;消费速度</code>时，未被及时消费的对象堆积在内存中，就产生了所谓的<code>背压</code>。</p>
<p>在Reactive编程模型中，只有在生产端和消费端运行在<code>不同线程</code>，且<code>生产速度&gt;消费速度</code>时，才会出现背压的情况。</p>
<p>需要说明的是，尽管Flowable支持背压，但也牺牲了一些<code>性能</code>，所以除非满足背压的场景，否则还是推荐使用Observable。</p>
<p>另外，Flowable使用了另一套体系（Publisher-Subscriber），与Observable体系（ObservableSource-Observer）的关系可以简单理解为：</p>
<ul>
<li>Flowable(Publisher实现类) &lt;–&gt; Observable(ObservableSource实现类)</li>
<li>Subscriber &lt;–&gt; Observer</li>
</ul>
<p>看下背压的基本写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void demo2() &#123;</span><br><span class="line">        Flowable</span><br><span class="line">                .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                        System.out.println(&quot;发射----&gt; 1&quot;);</span><br><span class="line">                        e.onNext(1);</span><br><span class="line">                        System.out.println(&quot;发射----&gt; 2&quot;);</span><br><span class="line">                        e.onNext(2);</span><br><span class="line">                        System.out.println(&quot;发射----&gt; 3&quot;);</span><br><span class="line">                        e.onNext(3);</span><br><span class="line">                        System.out.println(&quot;发射----&gt; 完成&quot;);</span><br><span class="line">                        e.onComplete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, BackpressureStrategy.BUFFER) //create方法中多了一个BackpressureStrategy类型的参数</span><br><span class="line">                .subscribeOn(Schedulers.newThread())//为上下游分别指定各自的线程</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSubscribe(Subscription s) &#123;   //onSubscribe回调的参数不是Disposable而是Subscription</span><br><span class="line">                        s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(Integer integer) &#123;</span><br><span class="line">                        System.out.println(&quot;接收----&gt; &quot; + integer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable t) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onComplete() &#123;</span><br><span class="line">                        System.out.println(&quot;接收----&gt; 完成&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Flow.create会返回一个FlowableCreate，和ObservableCreate类似，看下它的subscribeActual方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void subscribeActual(Subscriber&lt;? super T&gt; t) &#123;</span><br><span class="line">        Object emitter;</span><br><span class="line">        switch(this.backpressure) &#123;</span><br><span class="line">        case MISSING:</span><br><span class="line">            emitter = new FlowableCreate.MissingEmitter(t);</span><br><span class="line">            break;</span><br><span class="line">        case ERROR:</span><br><span class="line">            emitter = new FlowableCreate.ErrorAsyncEmitter(t);</span><br><span class="line">            break;</span><br><span class="line">        case DROP:</span><br><span class="line">            emitter = new FlowableCreate.DropAsyncEmitter(t);</span><br><span class="line">            break;</span><br><span class="line">        case LATEST:</span><br><span class="line">            emitter = new FlowableCreate.LatestAsyncEmitter(t);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            emitter = new FlowableCreate.BufferAsyncEmitter(t, bufferSize());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.onSubscribe((Subscription)emitter);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.source.subscribe((FlowableEmitter)emitter);</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(var4);</span><br><span class="line">            ((FlowableCreate.BaseEmitter)emitter).onError(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与ObservableCreate不同的是，这里基于入参指定的背压策略枚举，创建对应的发射器Emitter。</p>
<p>这些Emitter对于背压有不同的处理策略，具体体现在onNext实现的差异上。</p>
<p>但这些Emitter也有一些共同逻辑：Emitter会维护一个初始值为128的Long型原子类。每次向下游发送一次数据，该值自减1。如果减到0，基于不同的Emitter实现类，执行不同策略：<code>丢弃 or 忽略(指忽略背压，继续生产数据，可能产生OOM) or 调用subscriber的onError</code> 等等</p>
<p>Flowable体系的Emitter发送数据和Observable体系的Emitter不同，并非依次回调下游的onNext方法，他回调下游ObserveOnSubscriber的onNext，将数据放入下游ObserveOnSubscriber的异步缓存池内（本质是一个队列Queue），然后尝试启动ObserveOnSubscriber的异步线程就结束了</p>
<p>ObserveOnSubscriber在异步线程里执行runAsync方法，如果已消费的数据量小于消费者subscriber指定的阈值，则从异步缓存池里取数据后回调消费者subscriber.onNext方法消费。当下游消费了96个数据对象后，Emitter的原子Long当前值value+96，即已消费的额度回补给发端</p>
<p>消费者subscriber在onSubscribe方法里设置消费数据个数，该值维护在ObserveOnSubscriber，一旦消费数达到了阈值，ObserveOnSubscriber在异步消费线程里不会回调下游subscriber.onNext方法消费</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSubscribe(Subscription s) &#123;   //onSubscribe回调的参数不是Disposable而是Subscription</span><br><span class="line">    s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<p>生产出来的数据，会缓存到异步缓存池中。上游发送数据前，先判断原子Long的value，如果为0，执行背压策略，否则发送数据。然后CAS操作value-1。当下游消费了96个数据对象后，回补额度，Emitter的原子Long当前value+96。</p>
<p><code>这种设计允许下游消费速度在一定限度内比上游生产速度慢。只要生产128个数据的时间内，能消费96个数据，就能回补已消费数据额度用于再生产。否则就要执行相应的背压策略。</code></p>
<p>打个比方：女神一开始给屌丝128的好感度，好友度随女神等级不同，下跌速度不同。在好感度跌0前，如果屌丝送了超过96次礼物，回补96好感度，并重置礼物次数。如果好感度跌0，分手。。。</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习SpringBoot</title>
    <url>/2022/10/09/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0SpringBoot/</url>
    <content><![CDATA[<h1 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h1><p>当你开发一个中间件，或者一个通用组件的时候，通常需要给使用方提供一组可自定义的配置项，这些配置项往往在properties文件里定义，且带有特定前缀用于区分是这个组件的配置。那么如何能在应用启动后读到这些使用方自定义的配置项，影响组件的运行态呢？这时可以借助注解EnableConfigurationProperties</p>
<p>注解EnableConfigurationProperties通常加在你开发的中间件或通用组件的配置类上，注解的value表示需要注册到使用方bf的<code>properties应用配置bean</code>，该bean能把使用方的配置项注入进来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;EnableConfigurationPropertiesRegistrar.class&#125;)</span><br><span class="line">public @interface EnableConfigurationProperties &#123;</span><br><span class="line">    String VALIDATOR_BEAN_NAME = &quot;configurationPropertiesValidator&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] value() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>properties应用配置bean</code>需要使用@ConfigurationProperties 注解指定在应用属性文件里的属性前缀。例如 RocketMQ 使用 RocketMQProperties 这个 bean，注入 applicaiton.properties 里对 RocketMQ 的全局配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;rocketmq&quot;)</span><br><span class="line">public class RocketMQProperties &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来从@EnableConfigurationProperties 注解开始，分析它是如何完成注册应用配置 bean 的</p>
<h2 id="EnableConfigurationPropertiesRegistrar"><a href="#EnableConfigurationPropertiesRegistrar" class="headerlink" title="EnableConfigurationPropertiesRegistrar"></a>EnableConfigurationPropertiesRegistrar</h2><p>@EnableConfigurationProperties 注解主要通过 Import 方式引入了一个 bd 注册器 EnableConfigurationPropertiesRegistrar，看下它的注册 bd 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    registerInfrastructureBeans(registry);</span><br><span class="line">    registerMethodValidationExcludeFilter(registry);</span><br><span class="line">    ConfigurationPropertiesBeanRegistrar beanRegistrar = new ConfigurationPropertiesBeanRegistrar(registry);</span><br><span class="line">    this.getTypes(metadata).forEach(beanRegistrar: :register);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、registerInfrastructureBeans 方法会注册一些基础设施 bean，包括 bpp：<code>ConfigurationPropertiesBindingPostProcessor</code>、应用配置绑定器工厂：<code>ConfigurationPropertiesBinder.Factory</code>、应用配置绑定器：<code>ConfigurationPropertiesBinder</code>、应用配置容器：<code>BoundConfigurationProperties</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void registerInfrastructureBeans(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    ConfigurationPropertiesBindingPostProcessor.register(registry);</span><br><span class="line">    BoundConfigurationProperties.register(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void register(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    Assert.notNull(registry, &quot;Registry must not be null&quot;);</span><br><span class="line">    if (!registry.containsBeanDefinition(BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition definition = BeanDefinitionBuilder.genericBeanDefinition(ConfigurationPropertiesBindingPostProcessor.class, ConfigurationPropertiesBindingPostProcessor: :new).getBeanDefinition();</span><br><span class="line">        definition.setRole(2);</span><br><span class="line">        registry.registerBeanDefinition(BEAN_NAME, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConfigurationPropertiesBinder.register(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void register(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    AbstractBeanDefinition definition;</span><br><span class="line">    if (!registry.containsBeanDefinition(&quot;org.springframework.boot.context.internalConfigurationPropertiesBinderFactory&quot;)) &#123;</span><br><span class="line">        definition = BeanDefinitionBuilder.genericBeanDefinition(ConfigurationPropertiesBinder.Factory.class, ConfigurationPropertiesBinder.Factory: :new).getBeanDefinition();</span><br><span class="line">        definition.setRole(2);</span><br><span class="line">        registry.registerBeanDefinition(&quot;org.springframework.boot.context.internalConfigurationPropertiesBinderFactory&quot;, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!registry.containsBeanDefinition(&quot;org.springframework.boot.context.internalConfigurationPropertiesBinder&quot;)) &#123;</span><br><span class="line">        definition = BeanDefinitionBuilder.genericBeanDefinition(ConfigurationPropertiesBinder.class, () - &gt;&#123;</span><br><span class="line">            return ((ConfigurationPropertiesBinder.Factory)((BeanFactory) registry).getBean(&quot;org.springframework.boot.context.internalConfigurationPropertiesBinderFactory&quot;, ConfigurationPropertiesBinder.Factory.class)).create();</span><br><span class="line">        &#125;).getBeanDefinition();</span><br><span class="line">        definition.setRole(2);</span><br><span class="line">        registry.registerBeanDefinition(&quot;org.springframework.boot.context.internalConfigurationPropertiesBinder&quot;, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void register(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    Assert.notNull(registry, &quot;Registry must not be null&quot;);</span><br><span class="line">    if (!registry.containsBeanDefinition(BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition definition = BeanDefinitionBuilder.genericBeanDefinition(BoundConfigurationProperties.class, BoundConfigurationProperties: :new).getBeanDefinition();</span><br><span class="line">        definition.setRole(2);</span><br><span class="line">        registry.registerBeanDefinition(BEAN_NAME, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、registerMethodValidationExcludeFilter 方法注册了一个过滤器，过滤条件是必须包含 ConfigurationProperties 注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void registerMethodValidationExcludeFilter(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    if (!registry.containsBeanDefinition(METHOD_VALIDATION_EXCLUDE_FILTER_BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition definition = BeanDefinitionBuilder.genericBeanDefinition(MethodValidationExcludeFilter.class, () - &gt;&#123;</span><br><span class="line">            return MethodValidationExcludeFilter.byAnnotation(ConfigurationProperties.class);</span><br><span class="line">        &#125;).setRole(2).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(METHOD_VALIDATION_EXCLUDE_FILTER_BEAN_NAME, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、从父注解@EnableConfigurationProperties 的 value 属性中取出所有应用配置类 class，注册到 bf</p>
<ul>
<li>如果应用配置类 class 通过 ConfigurationProperties 注解指定了前缀，beanName 的格式为：{前缀}-{class.getName}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.getTypes(metadata).forEach(beanRegistrar::register);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Set &lt; Class &lt; ?&gt;&gt;getTypes(AnnotationMetadata metadata) &#123;</span><br><span class="line">    return (Set) metadata.getAnnotations().stream(EnableConfigurationProperties.class).flatMap((annotation) - &gt;&#123;</span><br><span class="line">        return Arrays.stream(annotation.getClassArray(&quot;value&quot;));</span><br><span class="line">    &#125;).filter((type) - &gt;&#123;</span><br><span class="line">        return Void.TYPE != type;</span><br><span class="line">    &#125;).collect(Collectors.toSet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void register(Class &lt; ?&gt;type, MergedAnnotation &lt; ConfigurationProperties &gt; annotation) &#123;</span><br><span class="line">    String name = this.getName(type, annotation);</span><br><span class="line">    if (!this.containsBeanDefinition(name)) &#123;</span><br><span class="line">        this.registerBeanDefinition(name, type, annotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String getName(Class &lt; ?&gt;type, MergedAnnotation &lt; ConfigurationProperties &gt; annotation) &#123;</span><br><span class="line">    String prefix = annotation.isPresent() ? annotation.getString(&quot;prefix&quot;) : &quot;&quot;;</span><br><span class="line">    return StringUtils.hasText(prefix) ? prefix + &quot;-&quot; + type.getName() : type.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConfigurationPropertiesBindingPostProcessor"><a href="#ConfigurationPropertiesBindingPostProcessor" class="headerlink" title="ConfigurationPropertiesBindingPostProcessor"></a>ConfigurationPropertiesBindingPostProcessor</h2><p>应用配置绑定 bpp。该 bpp 在初始化阶段，通过 ac 加载并持有绑定器：<code>ConfigurationPropertiesBinder</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    this.registry = (BeanDefinitionRegistry) this.applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">    this.binder = ConfigurationPropertiesBinder.get(this.applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定器在构造函数里，通过 ac 拿到应用的所有配置项。包括系统属性、环境变量、应用配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfigurationPropertiesBinder(ApplicationContext applicationContext) &#123;</span><br><span class="line">    this.applicationContext = applicationContext;</span><br><span class="line">    this.propertySources = (new PropertySourcesDeducer(applicationContext)).getPropertySources();</span><br><span class="line">    this.configurationPropertiesValidator = this.getConfigurationPropertiesValidator(applicationContext);</span><br><span class="line">    this.jsr303Present = ConfigurationPropertiesJsr303Validator.isJsr303Present(applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationPropertiesBindingPostProcessor 在 bean 前置初始化阶段，对使用@ConfigurationProperties 修饰的 bean，完成应用配置的绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    this.bind(ConfigurationPropertiesBean.get(this.applicationContext, bean, beanName));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ConfigurationPropertiesBean get(ApplicationContext applicationContext, Object bean, String beanName) &#123;</span><br><span class="line">    Method factoryMethod = findFactoryMethod(applicationContext, beanName);</span><br><span class="line">    return create(beanName, bean, bean.getClass(), factoryMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ConfigurationPropertiesBean create(String name, Object instance, Class &lt; ?&gt;type, Method factory) &#123;</span><br><span class="line">    ConfigurationProperties annotation = (ConfigurationProperties) findAnnotation(instance, type, factory, ConfigurationProperties.class);</span><br><span class="line">    if (annotation == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return new ConfigurationPropertiesBean(name, instance, annotation, bindTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部使用绑定器<code>ConfigurationPropertiesBinder</code>完成绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void bind(ConfigurationPropertiesBean bean) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    this.binder.bind(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已完成绑定的应用配置，会缓存在 BoundConfigurationProperties bean</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过注解<code>@EnableConfigurationProperties</code> 开启 sb 的应用配置绑定 bean 能力，在该注解的 value 属性上指定接收应用配置绑定的 bean<br>该注解引入一个 bd 注册器：<code>EnableConfigurationPropertiesRegistrar</code>，该注册器会将 @EnableConfigurationProperties 指定的应用配置绑定 bean 注册到 bf，还会注册一些用于完成应用配置绑定的组件 bean，最重要的是两个 bean：</p>
<ul>
<li>bpp：<code>ConfigurationPropertiesBindingPostProcessor</code>。它在 bean 前置初始化阶段完成应用配置绑定注入</li>
<li>绑定器：<code>ConfigurationPropertiesBinder</code>。ConfigurationPropertiesBindingPostProcessor 依赖该绑定器 bean 实现绑定注入。绑定器通过 ac 在构造函数里拿到应用的所有配置项</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码-BeanFactory架构</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81-BeanFactory%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring 目前使用的 bean 工厂是<code>DefaultListableBeanFactory</code>，围绕该工厂的类图架构，可以窥探 Spring 是如何一步步勾勒出这个功能齐全的 bean 工厂</p>
<h1 id="BeanFactory-架构"><a href="#BeanFactory-架构" class="headerlink" title="BeanFactory 架构"></a>BeanFactory 架构</h1><h2 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h2><p><code>BeanFactory</code></p>
<ul>
<li>bean 工厂的顶层接口，就是一个简单工厂，提供获取 bean 实例的工厂方法 getBean</li>
</ul>
<p><code>ConfigurableBeanFactory</code></p>
<ul>
<li>扩展<code>BeanFactory</code></li>
<li>可配置的 bean 工厂，bean 工厂的扩展能力在此基础上构建</li>
<li>在 BeanFactory 的基础上增加了一些配置 bean 工厂的方法，例如为 bean 工厂添加属性编辑注册器 PropertyEditorRegistrar、设置 BeanClassLoader、添加 bpp<ul>
<li>可配置的 bean 工厂体现在对 bean 加载过程的定制化</li>
</ul>
</li>
</ul>
<p><code>AutowireCapableBeanFactory</code></p>
<ul>
<li>扩展<code>BeanFactory</code></li>
<li>该工厂专注于创建支持依赖注入的 bean 实例<ul>
<li>定义了实际加载得到 bean 实例的 createBean 接口，返回已完成依赖注入和初始化的 bean 实例</li>
<li>定义了对实例化的 bean 实现依赖注入的接口</li>
<li>定义了 bean 初始化相关接口</li>
</ul>
</li>
</ul>
<p><code>DefaultSingletonBeanRegistry</code></p>
<ul>
<li>单例 bean 注册中心，保证单例 bean 在创建中和创建后的全局唯一性</li>
<li>内部维护一些 map 缓存，在单例 bean 创建中和创建后管理单例 bean</li>
</ul>
<p><code>FactoryBeanRegistrySupport</code></p>
<ul>
<li>扩展<code>DefaultSingletonBeanRegistry</code></li>
<li>支持拿到 factoryBean 或通过 factoryBean 获取 realBean</li>
</ul>
<p><code>BeanDefinitionRegistry</code></p>
<ul>
<li>beanDefinition 注册中心</li>
<li>提供 BeanDefinition 的注册和查询接口，bean 工厂实现该接口就会基于 beanDefinition 加载 bean</li>
</ul>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p><code>AbstractBeanFactory</code></p>
<ul>
<li>可配置的基础 bean 工厂<ul>
<li>实现了<code>BeanFactory</code>的工厂方法 getBean，框定了除真正加载 bean 之外的流程<ul>
<li>包括 bean 加载前的优先查三级缓存逻辑、factoryBean 加载 realBean 逻辑、循环依赖检测、加载 depends-on beans</li>
<li>包括 bean 加载后的操作，存入单例缓存 map</li>
</ul>
</li>
<li>实现了<code>ConfigurableBeanFactory</code>，是一个可配置的 bean 工厂<ul>
<li>可注册 bpp、PropertyEditorRegistrar、StringValueResolver</li>
</ul>
</li>
<li>继承<code>FactoryBeanRegistrySupport</code>，可拿到 factoryBean 或通过 factoryBean 获取 realBean</li>
<li>提供模板方法 createBean，由子类真正去加载得到 bean 实例</li>
</ul>
</li>
</ul>
<p><code>AbstractAutowireCapableBeanFactory</code></p>
<ul>
<li>可配置、具备依赖注入能力的 bean 工厂，实现核心的 bean 加载流程<ul>
<li>继承<code>AbstractBeanFactory</code>，可拿到所有对 bean 工厂的自定义配置。实现 createBean 方法，加载得到 bean 实例</li>
</ul>
</li>
<li>实现<code>AutowireCapableBeanFactory</code>，可在 bean 加载过程中对 bean 实例做依赖注入和初始化，以及基于 bean 工厂的配置来定制 bean 加载流程</li>
</ul>
<p><code>DefaultListableBeanFactory</code></p>
<ul>
<li>可配置、具备依赖注入能力、可枚举、可注册 beanDefinition 的 bean 工厂<ul>
<li>实现<code>ListableBeanFactory</code>，提供 byName、byType、byAnnotation 等多种方式枚举 bean 实例、beanNames 的能力</li>
<li>实现<code>BeanDefinitionRegistry</code>，提供对 beanDefinition 注册、枚举的能力</li>
<li>继承<code>AbstractAutowireCapableBeanFactory</code>，本身是一个可配置、具备依赖注入能力的 bean 工厂</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>DefaultListableBeanFactory</code>是 Spring 默认使用的 bean 工厂，它是 beanDefinition 和 bean 的容器，提供 byName、byType、byAnnotation 等多种方式枚举 bean 实例、beanNames、beanDefinition 的能力。同时具备 bean 工厂的基础能力，可以基于注册的 beanDefinition 加载 bean，支持加载过程中的依赖自动注入。并提供对于 bean 工厂的扩展能力，可以向 bean 工厂注册自定义的 bpp、PropertyEditorRegistrar 等，来定制和影响 bean 加载流程</p>
<p><code>DefaultListableBeanFactory</code>不负责解析 bean 配置生成 beanDefinition。<code>XmlBeanFactory</code>作为它的子类，虽然通过注入<code>XmlBeanDefinitionReader</code>和<code>ClassPathResource</code>，具备解析 XML 的 bean 定义生成 beanDefinition 的能力，但这超出了 bean 工厂的职责范围，所以它最后被废弃了，而是由 Spring 容器<code>ApplicationContext</code>持有与 bean 配置对应的<code>BeanDefinitionReader</code>完成解析和创建 beanDefinition，然后注册给<code>DefaultListableBeanFactory</code></p>
<p>BeanFactory 架构的 UML 类图：</p>
<p><img src="/spring/BeanFactory%E7%B1%BB%E5%9B%BE.jpg"></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习MySQL</title>
    <url>/2020/08/28/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0MySQL/</url>
    <content><![CDATA[<h2 id="启动与连接"><a href="#启动与连接" class="headerlink" title="启动与连接"></a>启动与连接</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>1、MySQL 的 Server 层分为哪几个模块？每个模块的功能是？</p>
<ul>
<li>连接器，负责与 mysql 客户端建连和权限校验。分析器，负责 mysql 语句的词法和语法分析，判断对哪些表做什么操作。优化器，制定执行计划，选择索引。执行器，调用存储引擎层 api 执行数据操作</li>
</ul>
<p>2、MySQL 客户端使用长连接的好处和坏处？</p>
<ul>
<li>好处，减少建连和验权产生的耗时，提高 sql 执行效率。坏处，容易产生 OOM，因为执行 sql 临时创建的对象管理在连接对象里，只有断开长连接时才会被 GC</li>
</ul>
<p>3、如何解决客户端长连接造成 OOM 的问题？</p>
<ul>
<li>执行完一个较大操作后执行 mysql_reset_connection 初始化连接资源，不会重新建连和验权</li>
</ul>
<p>4、如何解决客户端连接数激增打满数据库连接池问题？</p>
<ul>
<li>设置连接 timeout，空闲超过一定时间自动断开。或者执行”kill connection 连接 id”命令主动断连</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>MySQL 是 CS 模型，包括 MySQL 服务端和客户端。<br>MySQL 服务端进程占用 3306 端口<br>启动服务端的命令：<code>mysql.server start</code><br>关闭服务端的命令：<code>mysql.server stop</code></p>
<p>服务端又分为 Server 层和存储引擎层<br>Server 层按模块划分包括：连接器、分析器、优化器、执行器。</p>
<ul>
<li>连接器：负责客户端连接管理、权限管理<ul>
<li>MySQL 客户端使用长连接的好处和坏处<ul>
<li>客户端尽量与服务端建立长连接，减少比较耗时的建连次数。但使用长连接容易造成 OOM，使得系统强杀掉 MySQL 进程。原因是 MySQL 执行过程中临时使用的内存都管理在连接对象里，在断连时才会释放。</li>
</ul>
</li>
<li>如何解决客户端长连接造成 OOM 的问题<ul>
<li>每次执行一个较大操作后，执行<code>mysql_reset_connection</code>来重新初始化连接资源，这个过程不会做重连和权限校验</li>
</ul>
</li>
<li>如何解决客户端连接数激增打满数据库连接池问题<ul>
<li>可以设置连接的<code>wait_timeout</code>参数或<code>kill connection +连接id</code>，使得处于空闲状态的连接在指定时间后断开或主动断开，来减少连接数。不过处于空闲的连接，也可能处于事务中，断开连接会回滚事务，所以这种方式也是有损的</li>
</ul>
</li>
</ul>
</li>
<li>分析器：包括词法分析和语法分析，解析出 SQL 语句要对哪张表执行哪些操作</li>
<li>优化器：生成 SQL 操作的执行计划。比如决定使用哪个索引、多表连接时各个表的连接顺序</li>
<li>执行器：调用存储引擎提供的接口执行 SQL 操作</li>
</ul>
<p>存储引擎层提供读写接口，负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB（最常用）、MyISAM（MySQL 自带）、Memory 等多个存储引擎</p>
<p>我们常用的命令<code>mysql -hlocalhost -uroot -p123456</code>是启动客户端，建立与 mysql 服务端的连接<br>客户端启动后，输入<code>quit</code>关闭客户端，断开与 MySQL 服务端的连接</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p>1、数值类型字段超出范围存储时，MySQL 会如何处理？</p>
<ul>
<li>严格模式下插入失败，非严格模式截断处理</li>
</ul>
<p>2、DATETIME 和 TIMESTAMP 区别？</p>
<ul>
<li>DATETIME 存储年月日时分秒，占 8 字节。TIMESTAMP 存储时间戳，占 4 字节。可存储时间范围上，DATETIME 更大</li>
</ul>
<h3 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h3><p>描述数据类型时，有以下约定：</p>
<ul>
<li>M 表示整数类型的最大显示宽度。对于浮点和定点类型，M 是可以存储的总位数（精度）。对于字符串类型，M 是最大长度。允许的最大值 M 取决于数据类型。</li>
<li>D 适用于浮点和定点类型，并指示小数点后面的位数。最大可能值为 30，但不应大于 M-2。</li>
<li>[ ]表示类型定义的可选部分。</li>
</ul>
<p>常用数据类型分为三类：数值型、日期型、字符串型</p>
<h4 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h4><p>数值类型包括整数型、浮点型、定点型</p>
<p>整数型（精确值）</p>
<ul>
<li>TINYINT[(M)] [UNSIGNED] [ZEROFILL]<ul>
<li>范围非常小的整数，有符号的范围是 -128 到 127，无符号的范围是 0 到 255</li>
</ul>
</li>
<li>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]<ul>
<li>范围较小的整数，有符号的范围是 -32768 到 32767，无符号的范围是 0 到 65535</li>
</ul>
</li>
<li>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]<ul>
<li>中等大小的整数，有符号的范围是 -8388608 到 8388607，无符号的范围是 0 到 16777215。</li>
</ul>
</li>
<li>INT[(M)] [UNSIGNED] [ZEROFILL]<ul>
<li>正常大小的整数，有符号的范围是 -2147483648 到 2147483647。无符号的范围是 0 到 4294967295。</li>
</ul>
</li>
<li>BIGINT[(M)] [UNSIGNED] [ZEROFILL]<ul>
<li>大整数，有符号的范围是 -9223372036854775808 到 9223372036854775807，无符号的范围是 0 到 18446744073709551615。</li>
</ul>
</li>
</ul>
<p>注意，如果不手动指定 UNSIGNED，那么默认就是有符号的</p>
<p>默认的字段显示宽度与是否有符号有关。以 TINYINT 为例，如果定义字段<code>a TINYINT</code>，字段 a 的数据类型最终会描述为<code>TINYINT(4)</code>，4 表示最大长度，因为默认有符号，范围是-128~127，所以最长需要 4 个宽度来显示。如果定义时指定为 UNSIGNED，字段最终描述就会变为<code>TINYINT(3) UNSIGNED</code><br>字段显示宽度其实可以在定义时自由指定，如果字段定义时增加了<code>ZEROFILL</code>约束，则不够长度的数据前面会默认补 0，且<code>ZEROFILL</code>约束会自动添加<code>UNSIGNED</code>约束</p>
<p>浮点型</p>
<ul>
<li>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]<ul>
<li>单精度浮点数。允许值是-3.402823466E+38 到-1.175494351E-38，0 以及 1.175494351E-38 到 3.402823466E+38。M 是总位数（小数点和负号不计入），D 是小数点后面的位数</li>
</ul>
</li>
<li>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]<ul>
<li>双精度浮点数。允许值是-1.7976931348623157E+308 到-2.2250738585072014E-308，0 以及 2.2250738585072014E-308 到 1.7976931348623157E+308。M 是总位数（小数点和负号不计入），D 是小数点后面的位数</li>
</ul>
</li>
</ul>
<p>定点型</p>
<ul>
<li>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]<ul>
<li>常用于存储精确的小数，M 是总位数（小数点和负号不计入），D 是小数点后的位数。如果 D 为 0，则值没有小数点或小数部分。如果 D 省略，则默认值为 0，如果 M 省略，则默认值为 10。M 的范围是 1 到 65。D 范围为 0 到 30，且不得大于 M</li>
</ul>
</li>
</ul>
<p>注意，浮点型和定点型的数据在存储时，超出位数会进行四舍五入，所以都存在精度丢失问题</p>
<p>对于数值类型，如果存储时超出范围，会根据 SQL 当前模式做相应处理：</p>
<ul>
<li>严格模式，插入失败</li>
<li>非严格模式，截断后存储</li>
</ul>
<h4 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h4><ul>
<li>CHAR[(M)]<ul>
<li>固定长度的字符串，在存储时始终用空格填充指定长度。M 表示以字符为单位的列长度。M 的范围为 0 到 255.如果 M 省略，则长度为 1。无论字符串多长，存储时始终占用 M 个字节</li>
</ul>
</li>
<li>VARCHAR(M)<ul>
<li>可变长度的字符串，M 表示字符的最大列长度，M 的范围是 0 到 65535（2^16 -1），存储时占用 L+1（L&lt;&#x3D;M,L 为实际字符的长度）个字节</li>
</ul>
</li>
<li>TINYTEXT[(M)]<ul>
<li>不能有默认值，占用 L+1 个字节，L&lt;2^8</li>
</ul>
</li>
<li>TEXT[(M)]<ul>
<li>不能有默认值，占用 L+2 个字节，L&lt;2^16</li>
</ul>
</li>
<li>MEDIUMTEXT[(M)]<ul>
<li>不能有默认值，占用 L+3 个字节，L&lt;2^24</li>
</ul>
</li>
<li>LONGTEXT[(M)]<ul>
<li>不能有默认值，占用 L+4 个字节，L&lt;2^32</li>
</ul>
</li>
<li>ENUM(‘value1’,’value2’,…)<ul>
<li>ENUM 是一个字符串对象，其值从允许值列表中选择，它只能有一个值，从值列表中选择，最多可包含 65535 个不同的元素</li>
</ul>
</li>
<li>SET(‘value1’,’value2’,…) 字符串对象，该对象可以有零个或多个值，最多可包含 64 个不同的成员</li>
</ul>
<h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><ul>
<li>TIME<ul>
<li>范围是’-838:59:59.000000’ 到’838:59:59.000000’</li>
<li>TIME 类型的数据，存储时完整格式为<code>D HH:MM:SS</code>。D 表示天数，当指定该值时，存储时小时会先乘以该值。我们通常按<code>年-月-日 时:分:秒</code>存储时，只会存储时分秒</li>
</ul>
</li>
<li>DATE<ul>
<li>支持的范围是 ‘1000-01-01’到 ‘9999-12-31’</li>
</ul>
</li>
<li>DATETIME<ul>
<li>日期和时间组合。支持的范围是 ‘1000-01-01 00:00:00.000000’到 ‘9999-12-31 23:59:59.999999’。</li>
<li>存储空间 8 字节</li>
</ul>
</li>
<li>TIMESTAMP<ul>
<li>时间戳。范围是’1970-01-01 00:00:01.000000’UTC 到’2038-01-19 03:14:07.999999’UTC。</li>
<li>设置字段为 null 时，timestamp 会自动存储当前时间，datetime 存储的仍然是 null</li>
<li>存储空间 4 字节</li>
</ul>
</li>
<li>YEAR<ul>
<li>范围是 1901 到 2155</li>
</ul>
</li>
</ul>
<h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p>Mysql 表字段在创建时，可以指定约束条件，这里说一些相关的重要知识点。</p>
<ul>
<li>主键不一定必须是自增 id，也可以同时指定多个字段组合作为主键，但主键一定是唯一且非空的</li>
<li>唯一性约束的字段或组合可以为空，但如果非空，需要保证唯一性</li>
<li>主键和唯一性约束都默认增加了字段索引</li>
<li>外键用来关联父表和子表，父表作为外键的字段或组合必须建立索引</li>
</ul>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><p>1、binLog 和 redoLog 的作用是？</p>
<ul>
<li>主备数据同步 &amp;&amp; crashSafe</li>
</ul>
<p>2、写 binLog 和 redoLog 如何降低磁盘 IOPS 消耗</p>
<ul>
<li>降低写盘频率，N 次事务提交后一次性写盘</li>
</ul>
<p>3、什么是双 1 配置？</p>
<ul>
<li>binLog 和 redoLog 的写盘频率都为 1</li>
</ul>
<p>4、binLog 日志有几种格式？它们各自有哪些优缺点？</p>
<ul>
<li>statement、row、mix。statement 占用存储空间最小，但主备数据同步时可能因为选错索引造成主备数据不一致。row 存储变更前后完整的数据，误操作时可通过 row binLog 恢复数据。mix 根据是否会造成主备不一致来决定存 statement 还是 row。</li>
</ul>
<p>5、误删库表后重建数据库有哪几种方案？</p>
<ul>
<li>1.定期全量备份的临时库应用增量 binLog，跳过误操作 binLog。临时库执行 mysqlbinLog 命令只能单线程应用 binLog，优化方案是将临时库设为从库，执行 start slave 从备库应用增量 binLog，这样能利用并行复制能力。2.延时备库，也要跳过误操作 binLog。</li>
</ul>
<p>6、什么是 redoLog 的二阶段提交？</p>
<ul>
<li>保证 binLog 和 redoLog 数据一致性，事务提交时先写 redoLog 为 prepare 状态，然后再写 binLog，成功后再 commit redoLog</li>
</ul>
<h3 id="正文-2"><a href="#正文-2" class="headerlink" title="正文"></a>正文</h3><p>在执行写操作时，会涉及到两个重要的日志模块：redoLog 和 binLog</p>
<h4 id="redoLog"><a href="#redoLog" class="headerlink" title="redoLog"></a>redoLog</h4><p>作用：<br>redoLog 是 InnoDB 存储引擎层的，作用是提供<code>异常重启时数据恢复（crash-safe）的能力</code><br>工作机制：<br>每次执行写操作后，会记物理日志（在某个数据页做了什么修改）到 redoLog 文件。当系统崩溃重启后，可以根据 redoLog 找到之前的操作记录，恢复数据<br>redoLog 文件大小是固定的，因此写 redoLog 的方式是<code>循环写</code>，需要两个指针来指向当前可写的位置（write pos）和已经写入磁盘的位置（check pos）。当 write pos 追上 check pos 后，就需要强制执行一次写磁盘操作</p>
<h4 id="binLog"><a href="#binLog" class="headerlink" title="binLog"></a>binLog</h4><p>作用：<br>binLog 是 Server 层的日志，用于<code>主备数据同步</code>。例如在定期做线上库备份后，以备库的结束时间为起点，读取 binLog，执行回放操作，将备库恢复到和线上库一样的状态。<br>工作机制：<br>每次写操作前，会先写日志到 binLog 文件。具体的写入方式是先写内存 binlog cache，等事务提交时再 fsync 到磁盘里的 binLog 文件，参数<code>sync_binlog</code>控制 fsync 的频率，当设为 N 时，表示 N 个事务后再执行一次 fsync，能大幅降低磁盘 IOPS 消耗。注意，当 N&gt;1，数据库 crash 时存在丢 binlog 的可能性，是有风险的<br>redoLog 使用<code>innodb_flush_at_trx_commit</code>参数和<code>组提交机制</code>写盘，也能大幅降低磁盘 IOPS 消耗<br>当<code>sync_binlog</code>和<code>innodb_flush_at_trx_commit</code>都设置为 1，表示一个事务提交前要写两次磁盘，称为 MySQL 的<code>双1配置</code>。</p>
<p>binLog 的几种日志格式：<br>binLog 有三种日志格式，分别是<code>statement、row、mix</code></p>
<ul>
<li>statement 是原始 SQL 语句，好处是能最大程度降低 binLog 文件大小，因为一个操作 1000 条记录的写操作也只存一行 SQL 语句，但弊端就是在主备数据同步时，备库执行 statment 的结果可能与主库不同，造成主备数据不一致。例如 delete 操作选错索引就会删除不同的记录</li>
<li>row 保存写前和写后的完整数据，虽然占用较大的存储空间，但能保证主备数据一致，且能利用写前数据做回滚操作，目前的数据库一般都是 row 格式的 binLog<ul>
<li>误操作数据后可以利用 row binLog 重放来恢复，但这些操作限于增删改查，对于 drop、truncate 命令，binLog 里还是一条 statement，因此无法回滚。对于这些命令导致的误删除操作，只能通过对定期全量备份库恢复出的临时实例应用增量 binLog 来重建数据库<ul>
<li>如果使用<code>mysqlbinlog</code>命令来应用增量 binLog，只能单线程执行，无法用到<code>并行复制</code>能力，重建数据库耗时较长。优化方案是将临时实例设为从库，执行 start slave 命令从备库上应用 binLog，这能用到并行复制。不过要注意，如果备库没有重建数据库依赖的所有增量 binLog，需要将缺失 binLog 提前写入备库</li>
<li>对于需要应用很多天增量 binLog 的重建库操作，重建时间依然不可控，因此另一种方案是<code>延时备库</code>，即备库会延时指定时间后再执行主库 binLog，只要误操作发现的时间小于延时时间，就可以修改延时备库 binLog，跳过误操作事务，延时备库就可以作为重建后的数据库</li>
</ul>
</li>
</ul>
</li>
<li>mix 格式会判断 statment 是否会产生主备数据不一致，如果会，使用 row 格式，否则使用 statment 格式</li>
</ul>
<p>binLog 和 redoLog 的区别：</p>
<ul>
<li>binLog 是 Server 层的，redoLog 属于 InnoDB 存储引擎，提供 crash-safe 数据恢复能力，binLog 不具备 crash-safe 能力</li>
<li>binLog 写入方式是<code>追加写</code>，redoLog 是<code>循环写</code>。因此 redoLog 相比 binLog 要小得多，在设计之初 binLog 就被用来做数据备份，redoLog 做 crash-safe</li>
<li>binLog 写入的是逻辑日志，redoLog 是物理日志</li>
</ul>
<h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>redoLog 和 binLog 各司其职，在写操作时都需要先更新这两个日志文件，因此必须保证写操作的最终一致性，否则用 binLog 做数据备份后的备库和线上库会存在数据不一致<br>为了保证两个日志文件的最终一致性，在<code>写redoLog时采用二阶段提交</code>：</p>
<ul>
<li>先写 redoLog，处于 prepare 状态</li>
<li>写 binLog 成功</li>
<li>写 redoLog，处于 commit 状态<br>即，只有 binLog 写入成功，redoLog 才处于 commit 状态，只有 commit 状态的 redoLog 记录的操作会写入磁盘</li>
</ul>
<h2 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p>1、主备数据如何同步？</p>
<ul>
<li>备库设为只读，然后从主库拉取 binLog，写到 relayLog，多线程消费 relayLog，并行复制数据到备库</li>
</ul>
<p>2、什么是并行复制？并行复制的实现有哪些策略？</p>
<ul>
<li>为降低主备数据同步延迟，备库并发消费同步的 binLog，称为并行复制。为保证主备一致，同一事务的 sql 操作放到一线程里，同一行写入的多个事务分发到同一线程里</li>
<li>策略包括按库并行、WriteSet 模式并行，后者指 binLog 里写入事务更新的所有行的 hashCode，两个事务写的行没有交集时，分发给不同线程并发执行</li>
</ul>
<p>3、什么是循环复制？如何解决循环复制？</p>
<ul>
<li>双主架构下，两个实例间互相同步 binLog，产生循环复制。例如 A 实例把 binLog 同步给 B，B 执行后又同步回 A，这样一直重复</li>
<li>解决方式是 binLog 里写入执行的实例 id，当校验 binLog 的实例 id 就是自己时，不执行 binLog</li>
</ul>
<p>4、什么场景下可能产生主备延迟？</p>
<ul>
<li>主库写入速率大于备库同步 binLog 速率。造成的原因可能是大事务、备库读压力激增产生性能瓶颈</li>
</ul>
<p>5、主备切换有哪几种策略？和主备延迟有什么关系？</p>
<ul>
<li>主备切换时，主库也要设为 readOnly，防止主备双写产生数据不一致，因此这期间数据库不可写</li>
<li>可靠性优先时，需要备库同步 binLog 追上主库，主备延迟为 0 时，才主备切换</li>
<li>可用性优先时，直接主备切换，新主库继续同步剩下的 binLog，这可能产生主备数据不一致</li>
</ul>
<p>6、什么是 GTID？一主多从架构下做主备切换时，GTID 的作用是什么？</p>
<ul>
<li>GTID 是全局事务 id。一主多从架构下主备切换时，从库通过新主库 GTID SET 和从库已同步的 GTID SET 差集，判断从新主库的哪个 binLog 位点开始同步</li>
</ul>
<p>7、什么情况下存在客户端过期读问题？</p>
<ul>
<li>主备延迟读备库存在过期读问题</li>
</ul>
<p>8、半同步复制 semi-sync 机制如何解决过期读问题？该机制适合一主多从架构吗？</p>
<ul>
<li>主库同步发 binLog 给备库，拿到备库 binLog 的 ACK 后，才返回客户端事务提交成功，同步方式保证主备数据强一致来解决过期读问题，称为半同步复制 semi-sync 机制</li>
<li>不适合一主多从架构，因为有一个从库 ACK 后事务就提交成功，不能保证其他从库也已经同步完成</li>
</ul>
<p>9、GTID 方案能完美解决过期读问题吗？如何解决的？</p>
<ul>
<li>能。客户端读操作先请求主库，主库选择一个从库，传入主库执行的最新 GTID，如果从库在限定时间内执行了这个事务，认为主备数据一致，可以读从库，否则读主库</li>
</ul>
<p>10、MHA 数据库高可用性保障中，是如何检测库实例是否可用的？</p>
<ul>
<li>“执行”select 1 语句”或”更新系统表”来判断实例是否可用</li>
</ul>
<h3 id="正文-3"><a href="#正文-3" class="headerlink" title="正文"></a>正文</h3><h4 id="主备数据同步的流程"><a href="#主备数据同步的流程" class="headerlink" title="主备数据同步的流程"></a>主备数据同步的流程</h4><p>备库设置为 readOnly 模式，防止双写造成主备不一致。备库使用一个长连接与主库建联，内部启动一个 io 线程拉取主库 binLog 日志，并写入<code>relayLog</code>，同时内部有多个线程消费 relayLog，执行 binLog 到备库</p>
<h4 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h4><p>为了提升备库的数据同步性能，降低主备延迟，备库使用多线程消费 relayLog 同步主库数据，称为<code>并行复制</code>，并行复制要做到：</p>
<ul>
<li>不能产生覆盖更新，即对同一行更新的多个事务必须分发到同一个线程，避免主备数据不一致</li>
<li>同一个事务的多次更新必须分发到同一个线程，避免出现查询时只更新了一半的情况</li>
</ul>
<p>MySQL 为了实现并行复制，制定了一些复杂的策略，核心是要保障主备库执行时的逻辑时序性（不一定是严格时序，因为事务间对不同行的更新是可以并行的，因此才可以利用并行复制提高备库的同步数据速度）</p>
<ul>
<li>按库并行<ul>
<li>最简单的并行复制策略是按库并行，每个线程绑定一些库，操作同一个库的事务被分配给对应线程。粒度较粗，在不同库的压力均衡的场景中有不错的效果</li>
</ul>
</li>
<li>writeset 模式<ul>
<li>主库在写 binLog 时，计算更新行的 hash 值一并写入，组成<code>writeset</code>。当两个事务更新的 writeset 没有交集，说明没有并发更新行，就可以在备库不同线程中并行执行</li>
</ul>
</li>
</ul>
<h4 id="循环复制"><a href="#循环复制" class="headerlink" title="循环复制"></a>循环复制</h4><p>双 M 结构下，库实例间会互相同步 binLog，为了避免造成<code>循环复制</code>（即库 A 执行的 binLog 同步给库 B，库 B 执行完又同步给库 A，如果库 A 再次执行就出现循环复制），拿到 binLog 后会校验执行这个 binLog 的库实例 id 是否为当前库，如果是，就不执行 binLog</p>
<h4 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h4><p>备库消费 relayLog 的速度比主库生成 binLog 的速度慢时，就会存在<code>主备延迟</code>（备库写 binLog 时刻与主库写 binLog 时刻的差，忽略主备间 binLog 网络传输速度，通常是很快的）<br>主备延迟用参数<code>seconds_behind_master</code>描述，造成主备延迟的原因可能有这么几种：</p>
<ul>
<li>激增的查询压力<ul>
<li>备库的 IOPS 压力不会比主库小，且备库往往还要承担一些运营数据统计相关的读操作。解决办法是<code>一主多从</code>（从库分担查询压力）和<code>对称部署</code>（主备性能一致）</li>
</ul>
</li>
<li>大事务<ul>
<li>主库的大事务提交后才写 binLog、传输到从库的 relayLog，而从库上消费 relayLog 执行时也可能是大事务，造成消费 relayLog 滞后于主库生成 binLog</li>
</ul>
</li>
</ul>
<h4 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h4><p>主备切换时，在可靠性优先策略下，会判断主备延迟（secondes_behind_master）足够小才执行。这是因为切换的过程中，主库也会置为 readOnly，这段时间数据库是不可写的，直到主备不存在延时，即备库追上主库后，才把备库切为主库，所以切换前主备延迟越小，切换过程中数据库不可写时间越短，且切换的前提一定是主备不存在延迟，保证了可靠性。<br>另一种策略是可用性优先，不会等待主备延迟为 0 就直接切换主备库，这可能造成主备数据不一致，因为存在主备延时会导致主备库部分写操作的时序不一致<br>由此可知，主备延迟越小，主备切换时数据库的可用性越高，而主备数据同步和切换也是 MySQL 高可用系统的基础</p>
<p>一主多从架构下的主备切换：<br>该架构作用是把主库的读压力分担给从库，但是当主库 crash 切换到备库时，从库的数据同步需要从主库切换到备库，读取的源 binLog 文件和<code>位点</code>必然都会改变。那么从库该从备库 binLog 的哪个位点开始同步数据呢？<br>我们知道，备库作为主库，需要将主库的 binLog 全部同步到 relayLog。所以从库的策略是取备库执行主库 crash 时刻的 binLog 位置，从该位点开始拉取从库的 binLog，即拉取到的就是主库 crash 后，备库作为主库后执行的事务 binLog，这样不会丢数据。但保守起见，这个位点可能在 crash 位点前面，即位点后面的部分事务可能在从库已经执行过，所以从库在刚开始执行备库 binLog 事务时可能出现唯一键冲突或删除行不存在，这时将这两类错误跳过就好，因为跳过是无损的</p>
<p>GTID 解决主备切换的位点问题：<br>主备切换时，从库同步时跳过错误的做法依然不够优雅和可靠（当然需要执行一段时间后再关闭这个跳过策略），因此 MySQL 为每个提交了的事务定义了一个<code>GTID</code>全局事务 id 来标识，GTID 通过 binLog 传递给从库（所谓备库也是在从库中选择一个），每个数据库都会维护一个<code>GTID Set</code>，表示它执行过的事务 id。当从库同步数据时，如果发现 GTID 一致，则跳过这个事务，这就解决了主备切换时，从库因不能精准定位位点，可能会重复执行事务的问题<br>实际应用上，MySQL 是通过新主库的 GTID SET 和从库的 GTID SET 取差集（从库真正需要执行的 binLog 事务集）来计算从库在新主库需要的 binLog 位点</p>
<h4 id="主从架构下的过期读问题"><a href="#主从架构下的过期读问题" class="headerlink" title="主从架构下的过期读问题"></a>主从架构下的过期读问题</h4><p>当客户端读从库时，因为存在主备延迟，那么可能读到未更新的数据，称为<code>过期读</code>，解决过期读有这几种方案：</p>
<ul>
<li>强制走主库</li>
<li>对比从库读到主库的最新位点和备库执行的最新位点，二者一致说明主从数据完全同步（前提是忽略 binLog 网络传输延时）</li>
<li>对比从库接收到的 binLog 里的 GTID SET 和已经执行的 GTID SET，相同说明数据完全同步（前提是忽略 binLog 网络传输延时）</li>
<li>半同步复制 semi-sync 机制</li>
<li>等主库位点&#x2F;GTID 方案</li>
</ul>
<p>半同步复制 semi-sync 机制：<br>上面所述的后两种方案都是建立在主库 binLog 传输给备库无延迟的前提下，因此这些方案也不能完全解决过期读问题。不过加上 MySQL 提供了<code>半同步复制semi-sync</code>机制就可以。当开启 semi-sync 时，主库的 binLog 会同步发给备库，只有收到备库 ack 后，才返回客户端事务提交成功，这就保障了主备库 binLog 的绝对同步。但 semi-sync 不适合一主多从架构，因为这时只要有一个从库返回 ack 就会认为主从 binLog 同步成功，读到未及时返回 ack 的从库依然可能出现过期读</p>
<p>等主库位点&#x2F;GTID 方案：<br>该方案能绝对保证不存在过期读。原理是客户端查询请求先到主库，主库选择一个从库，传入主库最新的位点&#x2F;GTID 以及等待超时时间，如果在超时时间内从库执行到了这个位点&#x2F;执行了这条事务，就可以到从库查询，否则查主库<br>位点和 GTID 稍有不同，获取主库最新位点要多一次主库查询，但 GTID 可以在每次执行完事务后就能拿到，因此少了一次查主库的开销<br>当遇到大事务时，主备延迟增加，等待时间很可能超时，这时读请求还是会落在主库，所以应该尽量避免大事务</p>
<h4 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h4><p>MHA 一般是如何实现的？<br><code>MHA</code>（MasterHighAvailability），其实就是数据库的高可用性是如何保障的呢？<br>数据库实例可用，意味着并发 SQL 未超过阈值、日志盘的 IO 利用率未达到 100%，因此有如下几种检测方法：</p>
<ul>
<li>select 1<ul>
<li>这种方法无法检测到并发 SQL 达到阈值的场景，因为 select 1 不会使并发 SQL 数+1（注意，如果 SQL 操作被阻塞，也不会被统计到并发 SQL 数），也无法检测到日志盘利用率，因为不是写操作不会写日志，但它依然是默认的检测方法</li>
</ul>
</li>
<li>update 系统表<ul>
<li>根据主从架构的实例数，在系统表里创建对应数目的记录，主键为库实例的 server_id。定期轮询执行更新系统表操作，每个实例更新自己的记录，执行 relayLog 更新的是其他实例的记录，避免出现行冲突。如果更新失败，说明库实例不可用，需要执行主备切换<ul>
<li>如果系统表只有一条记录，那么发给实例的更新命令和实例通过 binLog 同步过来的操作可能同时更新同一行，产生行冲突</li>
</ul>
</li>
<li>因为是写操作，所以 SQL 并发数和日志盘利用率都能检测到，但有时候日志盘利用率达到 100%时，更新系统表依然可能成功，因此检测的实时性稍差一些</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><p>1、从 InnoDB 实现索引的角度，说说为什么主键不适合选择占用较大存储空间的数据类型？</p>
<ul>
<li>InnoDB 存储数据使用主键索引树和普通索引树，普通索引树上存储的是主键值，因此主键占据存储空间小可有效节省整体的数据存储空间</li>
</ul>
<p>2、什么是回表？</p>
<ul>
<li>普通索引树上缺失查询的字段时，回查主键索引树获取需要的字段值，称为回表</li>
</ul>
<p>3、什么是覆盖索引？</p>
<ul>
<li>索引树上包含了查询需要的所有字段，无需回表</li>
</ul>
<p>4、哪些查询能用到索引的最左前缀原则？</p>
<ul>
<li>多个查询条件字段匹配联合索引从左边开始的几个索引字段</li>
<li>命中字符串索引查询时，查询条件是从左边开始的几个字符</li>
</ul>
<p>5、影响 MySQL 选择索引的因素有哪些？</p>
<ul>
<li>索引的基数、是否回表、是否排序</li>
</ul>
<p>6、什么是基数？</p>
<ul>
<li>索引字段不同值的个数</li>
</ul>
<p>7、为什么 MySQL 有时会选错索引？有什么解决办法？</p>
<ul>
<li>对索引基数的判断是一个抽样后的估值，可能不准确</li>
<li>解决办法是查询时使用 force xx 强制走某个索引，或者执行命令”analyze table xx”来重新统计索引基数</li>
</ul>
<p>8、字符串加前缀索引有什么利弊？</p>
<ul>
<li>优点是减少了索引的存储空间，数据页上可覆盖更多的索引值</li>
<li>缺点是基数变小，查询效率可能受影响，且不能走索引覆盖，必须回表</li>
</ul>
<p>9、有哪些操作看起来会走索引但实际不会</p>
<ul>
<li>索引字段使用函数处理</li>
<li>索引字段是字符串型，但查询条件是数字型，mysql 对索引字段增加强转函数</li>
<li>多表级联查询，前查的表使用 utf8mb4 字符集，后查的表使用 utf8 字符集，这时会对后查表的索引字段使用强转函数，转成 utf8mb4 字符集避免精度损失</li>
</ul>
<h3 id="正文-4"><a href="#正文-4" class="headerlink" title="正文"></a>正文</h3><p>索引的作用是提高查询效率，做到这一点与索引使用的数据结构密切相关<br>下面介绍几个数据结构并分析其利弊</p>
<ul>
<li>哈希表<ul>
<li>适合等值查询，不适合范围查询。写入效率高</li>
</ul>
</li>
<li>有序数组<ul>
<li>只适用于静态存储引擎，适合等值和范围查询，但写入效率低</li>
</ul>
</li>
<li>二叉搜索树<ul>
<li>查询和写入效率比较平均，都是 logN，但当数据量大时，查询一次访问节点个数较多，不适合写入磁盘</li>
</ul>
</li>
<li>N 叉搜索树<ul>
<li>当 N&#x3D;1200，树高为 4，就可以存储 17 亿数据，且查询一次最多访问 3 次磁盘，减少查询时磁盘访问次数，这也是 B+树能作为 InnoDB 的索引存储结构的重要原因</li>
</ul>
</li>
</ul>
<h4 id="InnoDB-的索引实现"><a href="#InnoDB-的索引实现" class="headerlink" title="InnoDB 的索引实现"></a>InnoDB 的索引实现</h4><p>索引的实现放在存储引擎中，以 InnoDB 为例，使用<code>B+树</code>来存储索引<br>每一个索引都对应一个 B+树，主键索引和普通索引对应的 B+树存储数据有区别<br>主键索引树上挂载的是整行数据，因此也被称为<code>聚簇索引</code><br>普通索引树上挂载的是主键的值，因此通过普通索引树查询后需要再回到主键索引树查询才能获取整行记录，这称为<code>回表</code>。正是基于回表的查询策略，所以普通索引也被称为<code>二级索引</code></p>
<h4 id="选取主键的权衡"><a href="#选取主键的权衡" class="headerlink" title="选取主键的权衡"></a>选取主键的权衡</h4><p>一般情况我们的主键选择自增 id，因为这能使得我们用相对较小的存储空间（bigint 是 8 字节）表示相对较大的数据范围。上面提到，普通索引存储的是主键值，所以主键一般不宜选择占用较大存储空间的数据类型。</p>
<h4 id="如何避免回表"><a href="#如何避免回表" class="headerlink" title="如何避免回表"></a>如何避免回表</h4><p>如果查询需要的列在索引中已存在，或者只查询主键 id，那就没必要再回表查询整行记录了，这称为<code>覆盖索引</code>，使用覆盖索引是一种常用的数据库性能优化手段。例如，建立联合索引 a+b，当需要以 a 为条件查询 b 时，就会命中覆盖索引，无需回表<br>另一种避免回表的优化手段是<code>索引下推</code>。当查询命中联合索引时，会尽可能在联合索引树上对查询条件进行判断，只有当出现需要的查询条件不在联合索引里时，才会回表</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>B+树这种索引结构，可以利用索引的最左前缀来定位记录，称为<code>最左前缀原则</code>，这里有两层含义：</p>
<ul>
<li>最左前缀可以是联合索引的最左 N 个字段</li>
<li>最左前缀可以是字符串索引的最左 M 个字符<ul>
<li>例如有联合索引“姓名+年龄”，那么当查询条件是姓名 like’张%’，依然会命中这个联合索引</li>
</ul>
</li>
</ul>
<h4 id="MySQL-索引选择"><a href="#MySQL-索引选择" class="headerlink" title="MySQL 索引选择"></a>MySQL 索引选择</h4><p>MySQL 的 Server 层优化器负责在查询时选择索引，但有时也会选择错误的索引导致耗时较长。我们人为判断应该选择哪条索引时，通常选择“扫描行数最少”的那个索引，但优化器还会综合考虑是否需要回表、是否需要排序、扫描行数这些情况来总和判断，所以有时也会选错索引<br>索引的<code>基数</code>（Cardinality）是优化器选择索引很重要的参考之一。基数表示索引上不同值的个数，因此基数越大，索引的区分度就越高，选择索引后需要扫描的行数就越少。例如一个 1000 条记录的表，索引 a 的基数是 1000，索引 b 的基数是 10，那么查询一条数据的操作，选择索引 a 扫描的行数是 1，选择索引 b 扫描的行数就是 100<br>需要说明的是，基数是采样统计的，只是一个估计值，这也可能造成 MySQL 选错索引<br>如果发现 MySQL 选错索引导致查询超时，可以这么做：</p>
<ul>
<li>使用<code>analyze table t</code>来重新统计索引信息，这时会重新统计索引的基数</li>
<li>可以在查询命令里使用<code>force index(a)</code>来强制指定使用哪条索引</li>
</ul>
<h4 id="字符串加前缀索引的利弊"><a href="#字符串加前缀索引的利弊" class="headerlink" title="字符串加前缀索引的利弊"></a>字符串加前缀索引的利弊</h4><p>好处：</p>
<ul>
<li>减少索引树占用的磁盘存储空间<ul>
<li>增加相同的数据页存放的索引值，提高查询效率</li>
</ul>
</li>
</ul>
<p>弊端：</p>
<ul>
<li>降低索引的区分度（基数），造成更多的扫描行数，性能会受影响</li>
<li>使用了前缀索引就无法使用<code>覆盖索引</code>，因为前缀索引匹配的索引结果是不精确的，还是需要回表</li>
</ul>
<p>那么如何能高效对字符串加索引呢？</p>
<ul>
<li>倒序存储。例如身份证加索引，可以在存储时倒序，则前缀就能具备较大的区分度<ul>
<li>弊端是不支持范围查询，且依然不能完全解决额外的扫描行数问题</li>
</ul>
</li>
<li>增加 hash 字段。存储字符串的哈希值，对哈希值加索引<ul>
<li>弊端是不支持范围查询，写入和查询时增加了额外的 CPU 计算损耗</li>
</ul>
</li>
</ul>
<h4 id="一些实际不会走索引的操作"><a href="#一些实际不会走索引的操作" class="headerlink" title="一些实际不会走索引的操作"></a>一些实际不会走索引的操作</h4><p>1、<code>如果对索引字段做了函数操作，可能破坏索引值的有序性，因此优化器会放弃走索引</code>，而是对普通索引树或主键索引树做全表扫描<br>2、当需要类型转换时，<code>MySQL只能默认将字符串转成数字</code>，所以如果表里索引字段是数字型，查询条件是字符串，那么 MySQL 默认类型转换后，依然能命中索引，但如果反过来，MySQL 就会加上强转函数，原因同问题 1，无法走索引而是扫全表，所以<code>拿不准时，使用字符串作为查询条件总是保险的</code><br>3、如果做多表级联查询时，假设优化器最终选择先查表 a 再查表 b，如果查表 b 时想命中索引，需要保证表 b 和表 a 的连接字段使用相同的字符集，或者表 b 的连接字段是 utf8mb4 字符集（这样不会强转表 b 的字段），否则 MySQL 会对表 b 的字段强转字符集，查询表 b 就会走全表扫描，原因同问题 1<br>目前 mysql 的两种字符集<code>utf8</code>、<code>utf8mb4</code>，其中后者是前者的超集，所以当需要字符集转换时，总是 utf8 要转成 utf8mb4 避免精度丢失</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><p>1、加全局锁有什么应用场景？加全局锁有什么风险？</p>
<ul>
<li>全库备份。风险是如果被长事务阻塞，全局锁后续的事务（DML、DDL 操作）也会被同步阻塞</li>
</ul>
<p>2、元数据锁的作用是？什么操作需要加元数据读锁、写锁？</p>
<ul>
<li>保证对表数据读取和写入时，表结构不会发生变化</li>
<li>DDL 操作加元数据写锁，DML 操作加元数据读锁</li>
</ul>
<p>3、DDL 操作造成长时间锁表的原因是什么？怎么解决？</p>
<ul>
<li>因为 DDL 操作加元数据写锁，而 DML 操作加元数据读锁，所以 DDL 长时间不释放元数据写锁时，会阻塞后续所有 DML 操作</li>
</ul>
<p>4、从 MySQL 锁的角度，说说 InnoDB 取代 MyISAM 的原因是什么？</p>
<ul>
<li>InnoDB 支持行锁，MyISAM 不支持，所以对于 MyISAM，所有可以加行锁的场景都会升级为表锁，严重影响 mysql 的并发度</li>
</ul>
<p>5、什么是行锁的二阶段协议？</p>
<ul>
<li>在一个事务里，行锁在需要的时候添加，在事务提交后才释放</li>
</ul>
<p>6、死锁检测的策略是什么？为什么死锁检测会造成热点行更新出现性能问题？</p>
<ul>
<li>当事务被锁时，检测和锁相关的每个事务是否可能被这中间的其他事务锁住，时间复杂度为 O(n²)，一旦检测到，主动回滚死锁链路里的一个事务</li>
<li>因为死锁检测的时间复杂度为 O(n²)，对于热点行，n 很大，死锁检测的性能会产生瓶颈，因此要避免热点行更新</li>
</ul>
<h3 id="正文-5"><a href="#正文-5" class="headerlink" title="正文"></a>正文</h3><p>根据加锁范围，Mysql 的锁分为三类：全局锁、表级锁、行锁<br>锁的类型分为读锁和写锁<br>读锁为共享锁，写锁为排它锁</p>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>MySQL 提供了加全局读锁（FlushTableWithReadLock，FTWRL）的方法，加全局读锁后，后续的任何 DML（增删改）、DDL(建表、修改表结构)和更新事务的提交都会被同步阻塞。加全局锁操作也会被前面进行中的事务阻塞，因此需要避免长事务，否则会导致后续的事务因为加全局锁操作被长时间阻塞<br>全局锁主要用于<code>全库备份</code>，加全局锁保证了所有表在备份时的一致性。当然也可以通过设置事务隔离级别为可重复读来实现，但前提是所有表都使用支持事务的存储引擎如 InnoDB，如果使用了不支持事务的 MyISAM，则只能使用全局锁来做全库备份</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>表级锁细分为表锁和元数据锁<br>对于支持行锁的存储引擎如 InnoDB，一般不使用表锁<br>元数据锁（MDL,MetaDataLock）保证在对表的读取和写入正确性，即不会在读取写入时执行任何 DDL 操作修改表结构<br>DML 操作需要加元数据读锁，DDL 操作需要加元数据写锁<br>如果 DDL 操作“时机不对”，很容易因为元数据写锁和读锁互斥，导致很多 DML 操作被阻塞，所以安全变更表结构需要做到以下几点：</p>
<ul>
<li>提前干掉长事务，否则 DDL 因为需要等待前面长事务释放元数据读锁而长时间阻塞，而 DDL 后续的 DML 操作也会同步阻塞，造成较长时间的锁表</li>
<li>对于热点表，设置一个等待获取元数据写锁的超时时间，如果超时拿不到则放弃，改为在“非热点时段”重新尝试</li>
</ul>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>对于不支持行锁的存储引擎，例如 MyISAM，并发写只能升级为表锁，这严重限制了数据库的并发度，所以这也是 InnoDB 取代 MyISAM 的重要原因，InnoDB 支持行锁</p>
<p>行锁的<code>二阶段协议</code>：<br>在 InnoDB 事务中，在需要的时候会加行锁，但直到事务结束才会释放行锁，这就要求在 InnoDB 事务中，尽量将影响并发度的操作放到后面以减少行锁占据的时间</p>
<p>死锁检测：<br>当两个事务各自依赖对方释放行锁，即循环等待时，就会产生死锁。解决死锁有两个方法：设置等待锁超时时间和<code>死锁检测</code>。前者超时时间很难定义清楚，容易造成误伤，因此通常采取死锁检测。<br>死锁检测的策略是：当一个事务被锁时，检测与锁相关的线程（包括持有锁的线程和与它竞争同一把锁的线程）是否可能被其他线程锁住，如此循环，如果判断出现了循环等待，就认为存在死锁，主动回滚死锁链条中的某一个事务来解开死锁。<br>需要注意，死锁检测的性能损耗会随并发度的增加而成倍増长。当 n 个线程并发竞争同一把行锁时，每一个线程的死锁检测时间复杂度是 O(n)，总的时间复杂度就是 O(n²)，会极大地占用 CPU 资源，这就是<code>热点行更新带来的性能问题</code>，解决的思路有两种：</p>
<ul>
<li>控制热点行更新的并发度</li>
<li>将热点行散列成多行来降低并发更新的概率</li>
</ul>
<h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><h3 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h3><p>1、什么是脏读、不可重复读、幻读？</p>
<ul>
<li>读未提交的事务对数据的变更，当事务回滚后，已读的数据失效，产生脏读</li>
<li>一个事务内相同查询条件，两次读取到数据不一致，称为不可重复读，通常是其他事务对数据做了变更</li>
<li>幻读和不可重复度类似，其他事务对数据做了增删，导致事务内相同查询条件，下次读取的记录数发生变化</li>
</ul>
<p>2、InnoDB 如何实现事务隔离？</p>
<ul>
<li>undoLog+MVCC 多版本并发控制。记录每次发生变更时，会在回滚日志 undoLog 记录数据版本，即修改后的值和对应的事务 id。不同事务隔离级别会在不同时刻创建视图数组，保存当前时刻已创建但未提交的事务数组。读取数据时，如果数据最新版本的事务 id 在视图数组内，就通过 undoLog 回滚到上一版本，直到回滚到不在视图数组里的那个版本，读取该版本的值，即只会读取创建视图数组时刻已提交的事务。称为 MVCC 多版本并发控制</li>
<li>对于可重复读 RR，创建视图数组的实际发生在事务启动时，即只会读事务启动前已提交的事务。对于读已提交 RC，执行每个 SQL 时创建视图数组，因此每次都能读取已提交的事务。读未提交即每次读取最新版本的数据，没用到视图数组。串行化对读写加锁，不会用到 MVCC</li>
<li>需要说明一点，如果读取到数据版本的事务 id 就是当前线程，直接读取，即事务内部的修改总是对自己可见</li>
</ul>
<p>3、什么是当前读？哪些 SQL 操作会使用当前读？</p>
<ul>
<li>update、delete 操作，或者 select…lock in share mode 或者 select… for update，做这些 sql 操作会触发当前读，读取最新版本的数据</li>
</ul>
<p>4、什么是 gap 锁？gap 锁为什么容易造成死锁？</p>
<ul>
<li>gap 锁用于限制在记录间插入新的数据记录。因为加 gap 锁没有任何限制，所以不同事务可能阻塞在对方加的 gap 锁上，产生死锁</li>
</ul>
<p>5、当前读的实现原理？</p>
<ul>
<li>RR 隔离级别下，因为要在事务内满足读一致性，对于当前读，需要在事务结束前，对”扫描到的记录加读锁、gap 锁”，如果是 update、delete 这种变更操作或者 select…for update，还会对扫描到的记录加写锁防止其他事务修改。加 gap 锁的目的也是防止新增满足条件的记录。</li>
<li>RC 隔离级别下，因为运行每次读提交，所以只会对满足条件的记录加读锁</li>
</ul>
<p>6、RR 级别的当前读什么情况下会造成大面积锁表？</p>
<ul>
<li>当 update、delete 这种变更操作或者 select…for update，没有命中索引时，会走主键索引全表扫描，RR 级别下对扫描到的记录加写锁，还会加 gap 锁，相当于锁表的效果</li>
</ul>
<p>7、MVCC 使用的回滚日志会一直保存吗？如果系统中存在长事务，会有什么问题？</p>
<ul>
<li>不会。只会保存到最老的一个事务需要回滚到的数据版本为止。如果存在长事务，undoLog 为了保证能回滚到该事务创建的视图数组之前的那个版本，需要维护很长的回滚日志</li>
</ul>
<h3 id="正文-6"><a href="#正文-6" class="headerlink" title="正文"></a>正文</h3><p>在事务执行过程中，需要控制其他事务更新数据后对当前事务查询数据的可见性级别，称为事务隔离，不同的可见性对应不同级别的事务隔离<br>理解事务隔离级别前需要先知道什么是脏读、幻读、不可重复读</p>
<h4 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h4><p>脏读<br>一个事务读到另一个事务尚未提交的修改，就是脏读<br>脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的就是垃圾数据</p>
<p>不可重复读<br>一个事务多次读取同一条记录，前后读取的数据不同，称为不可重复读<br>造成这种情况说明前后两次读取过程中记录被修改，可能是已提交事务对记录的修改，也可能是未提交事务的修改，这时后一次读取就是脏读</p>
<p>幻读<br>和不可重复读基本含义相同，只不过是针对其他事务的 insert 操作造成前后读的结果不一致，称为幻读</p>
<p>事务隔离就是解决上面所述多个事务同时进行时可能出现的脏读、不可重复读、幻读问题</p>
<h4 id="InnoDB-实现事务隔离"><a href="#InnoDB-实现事务隔离" class="headerlink" title="InnoDB 实现事务隔离"></a>InnoDB 实现事务隔离</h4><p>事务隔离的几个级别：</p>
<ul>
<li>读未提交：一个事务还未提交，他做的变更就能被其他事务看到</li>
<li>读提交：一个事务提交后，他做的变更才能被其他事务看到</li>
<li>可重复读：一个事务执行过程中看到的数据和他启动时看到的数据一致。这是 mysql 的默认隔离级别</li>
<li>串行化：读写都会加锁，当出现读写锁冲突，后访问的事务必须等前一个事务执行完才能继续执行</li>
</ul>
<p>InnoDB 对事务隔离的实现方式：undoLog+MVCC<br>每次数据更新，都会生成一个新的<code>数据版本</code>，保存最新的值和对应做了更新操作的事务 id。同时记录回滚日志<code>undoLog</code>，通过回滚日志能回退到上一个版本的值并拿到上一个版本对应的事务 id<br>根据不同的事务隔离级别，在不同时刻会创建<code>视图数组</code>。视图数组里并不是物理上的视图，数组里存储的其实是当前时刻已经启动但还未提交的事务 id。通过视图数组和读取到数据的事务 id 进行比对，来决定是读取当前数据，还是通过回滚日志继续回溯之前版本的数据并重复这一过程直至读到满足隔离级别的数据，这称为事务内的<code>一致性读</code>。InnoDB 在实现上使用的就是<code>多版本并发控制（MVCC）的一致性读视图</code></p>
<p>回滚日志不会一直存在，只会保留到能回滚到最老的一个事务可读取的记录版本为止。因此尽量避免使用长事务，因为这意味着系统里会存在很老的事务视图，在长事务提交前，回滚记录都必须保留，这会占据大量存储空间<br>另外需要注意，如果事务需要执行多次回滚才能拿到隔离级别下的数据，可能产生性能问题</p>
<p>针对不同的隔离级别，分别在以下时刻创建视图数组</p>
<ul>
<li>读未提交级别可以理解为没有任何事务隔离，所以没有用到视图数组</li>
<li>读提交(RC,ReadCommited)在执行每个 SQL 时创建</li>
<li>可重复读(RR,ReadRepeat)在事务启动时创建视图，所以整个事务期间读取的数据是一致的</li>
<li>串行化通过加锁来避免了不同事务并发访问数据，所以也不用视图数组</li>
</ul>
<p>当一个事务内部进行查询（读）操作时，视图数组和查询到的记录版本中的事务 id 比对规则如下：</p>
<ul>
<li>如果记录的最新版本对应的事务 id 就是当前事务，就可以读取值，即<code>事务内部对记录做的更新，对自己总是可见的</code></li>
<li>如果记录的最新版本对应的事务 id 不在视图数组内<ul>
<li>如果是在视图数组创建前已经提交的事务，就可以读取值</li>
<li>如果不是在视图数组创建前已经提交的事务，说明是之后创建的事务，不可以读取值，通过回滚日志访问上一个版本的记录，重复这个过程</li>
</ul>
</li>
<li>如果记录的最新版本对应的事务 id 在视图数组内，说明是在创建视图数组时还未提交的事务，不可以读取值，通过回滚日志访问上一个版本的记录，重复这个过程</li>
</ul>
<p>总结一下：事务可以读取到的值限定为两种情况：</p>
<ul>
<li>本次事务内部对记录的更新</li>
<li>创建视图数组前已经提交的事务对记录的更新</li>
</ul>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>与事务隔离实现的一致性读相对应的是当前读<br>事务里每次读取记录的最新值，称为当前读</p>
<p>哪些情况是当前读？</p>
<ul>
<li>事务里的 update、delete 操作就是当前读，然后更新<ul>
<li>因为是更新，所以需要加写锁</li>
</ul>
</li>
<li><code>select xx from t where ... lock in share mode</code><ul>
<li>只读，加读锁</li>
</ul>
</li>
<li><code>select xx from t where ... for update</code><ul>
<li>因为 for update 目的是更新，所以需要加写锁</li>
</ul>
</li>
</ul>
<p><code>gap锁</code>：gap 锁没有读写锁的概念，就是起到限制在相邻两行记录间插入数据的作用，且加 gap 锁不会被阻塞<br>但正是因为加 gap 锁不会阻塞，所以<code>gap锁很容易造成死锁</code>，因为两个事务很可能都阻塞在对方加的 gap 锁，就会产生死锁</p>
<p>当前读的实现原理：<br>在 RR 隔离级别下，对于只读型或更新型当前读，其语义是<code>需要事务内独占满足条件的记录</code>（更新操作还需要基于当前最新值进行更新），这需要满足：</p>
<ul>
<li>不允许在事务提交前，查询到的记录被修改，所以会加行读锁<ul>
<li>如果查询使用了索引覆盖，对于只读型当前读，只会对索引树上的记录加锁，不会对主键索引树上的整行记录加锁，但对于更新型，MySQL 认为你还是会更新数据的，所以依然对整行记录加锁</li>
</ul>
</li>
<li>不允许新增满足条件的记录，所以会对扫描到的记录间加 gap 锁<ul>
<li>如果允许新增记录，会造成主备数据不一致，原因是：当主库里更新型当前读 update 后又新增满足条件的记录，这些新增记录都不会被 update，但 binlog 里这些新增记录的 insert 在 update 前，如果备库拿 binLog 执行，这些新增记录就都会被 update，造成主备数据不一致</li>
<li>特别地，如果查询命中唯一索引，不会加 gap 锁，因为不会新增满足条件的记录</li>
</ul>
</li>
<li>更新型当前读还不允许满足条件的记录在事务提交前被其他线程读取，所以会对扫描到的行加行写锁</li>
</ul>
<p>RC 隔离级别下，因为允许读到其他事务的更新，所以相对于 RR，不会加 gap 锁，且只会对满足条件的记录加行锁，即加锁的范围相比 RR 小很多，这也是很多业务默认使用 RC 的原因</p>
<ul>
<li>RC 级别不加 gap 锁，因此需要处理主备数据不一致问题</li>
</ul>
<p>RR 隔离级别下，当前读可能造成大范围的锁表：</p>
<ul>
<li>当查询没命中索引，走主键索引树做全表扫描，且对主键索引树上扫描的行都加行锁和 gap 锁。如果是更新型当前读，行锁用的是写锁，这会大大降低数据库的并发度。所以当前读尽量要命中索引，减少 gap 锁和行锁的范围</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h3><p>1、InnoDB 中 changeBuffer 的作用是？changeBuffer 适用于读多还是写多的场景？</p>
<ul>
<li>写操作时，如果数据页未加载到内存中，会将数据变更先缓存在 changeBuffer</li>
<li>写多场景，changeBuffer 可以缓存同一数据页中的大量变更，数据页被加载到内存后，再更新到数据页，这种方式效率最高。所以适合于写多场景</li>
</ul>
<p>2、InnoDB 是如何实现数据更新的？</p>
<ul>
<li>如果数据页加载到内存，写数据页，事务提交后写 redoLog</li>
<li>如果数据页未加载到内存，写 changeBuffer，事务提交后写 redoLog</li>
</ul>
<p>3、什么是脏页？</p>
<ul>
<li>内存里的数据页还未刷入磁盘时，会出现内存磁盘数据不一致，称内存中的数据页为脏页</li>
</ul>
<p>4、哪些场景下会执行脏页 flush 到磁盘？</p>
<ul>
<li>redoLog 写满</li>
<li>内存满，无法加载进新的数据页</li>
<li>数据库不繁忙时</li>
<li>数据库正常关闭时</li>
</ul>
<p>5、为什么脏页 flush 时感觉 MySQL 性能有抖动</p>
<ul>
<li>因为需要将脏页刷入磁盘，涉及到大量 IO 操作</li>
</ul>
<p>6、使用唯一索引还是普通索引在写操作时性能更好？为什么？</p>
<ul>
<li>普通索引在写操作时性能更好。因为唯一索引要先校验记录唯一性，需要额外从磁盘加载数据页到内存，增加了大量 IO 开销</li>
</ul>
<p>7、InnoDB 加载新数据页到内存时，需要淘汰旧数据页，使用的是什么算法？</p>
<ul>
<li>LRU（最近最少使用），链表实现，最近访问的数据页放在头结点，淘汰尾结点</li>
</ul>
<p>8、对于历史数据表的全表扫描，会加载大量数据页到内存，影响查询时的内存命中率，LRU 算法针对这种场景是如何优化的？</p>
<ul>
<li>链表按 5 比 3 分为 Young 区和 Old 区，Young 在前。最近被加载的数据页先放在 Old 区，如果数据页下次被访问超过 1 秒，则移到 Young 区，这样临时加载的数据页因为不会二次访问，所以一直停在 Old 区，很快被淘汰，保证了内存缓存的都是活跃的数据页，提高查询时的内存命中率</li>
</ul>
<p>9、InnoDB 是如何实现数据删除的？</p>
<ul>
<li>只是逻辑删除，被标记删除的记录所在空间可以被后续新增记录复用</li>
</ul>
<p>10、哪些场景下可能造成存储空间的空洞？有什么解决办法？</p>
<ul>
<li>被逻辑删除的空间未被复用时产生空洞，这通常在插入的新数据无法存储在现有数据页，而进行页分裂时产生空洞</li>
<li>解决存储空洞的方法是重建表，即创建一个新表，按主键顺序重新插入一遍数据到新表</li>
</ul>
<p>11、什么是 OnlineDDL？</p>
<ul>
<li>DDL 期间对客户端无感知，依然可以正常执行 CRUD</li>
</ul>
<p>12、MyISAMcount*查询直接使用磁盘上记录的表的总行数，为什么 InnoDB 不行？</p>
<ul>
<li>MyISAM 不支持事务，所以可以简单地把总行数记在磁盘上。InnoDB 支持事务，不同事务执行期间因为存在事务隔离机制，所以 count*查询结果可能不同，因此不能简单地把总行数记在磁盘上</li>
</ul>
<p>13、InnoDB 如何实现 count 查询？count 的字段不同，性能上有什么差别？</p>
<ul>
<li>InnoDB 会扫全表并筛选事务可读的所有记录，由 Server 层统计行数后返给客户端</li>
<li>count*和 count1 都是性能最优的 count 查询，因为不涉及到记录上的字段解析和拷贝。count 字段需要字段解析和拷贝，所以性能不好</li>
</ul>
<p>14、如何解决表很大时，count 操作的性能问题？</p>
<ul>
<li>表里存储总行数，插入操作和总行数+1 做到一个事务里，尽量先插入后总行数+1，因为基于事务的二阶段提交协议，并发高的操作放到后面能尽可能减少锁竞争对事务的影响</li>
</ul>
<p>15、对于 order by 操作，InnoDB 的全字段排序和 rowId 排序各有什么优劣？什么条件下优先使用 rowId 排序？</p>
<ul>
<li>全字段排序需要排序内存空间足够大，rowId 排序每行记录只包括主键 id 和排序字段，对排序内存空间要求低，但排序后需要二次回表取完整字段数据，性能不如全字段排序</li>
<li>源表是内存临时表时，rowId 排序后，二次回表拿数据不走磁盘，直接从内存取，性能基本不受影响，这时优先使用 rowId 排序</li>
</ul>
<p>16、什么条件下，order by 操作对查询到的结果集不需要再做排序？</p>
<ul>
<li>查询条件+orderBy 命中联合索引时，普通索引树上就已经是排序后的结果了，无需再做排序。另外，如果查询又用到了索引覆盖，还不用回表，这种场景性能最优</li>
</ul>
<p>17、全表扫描会不会打满 MySQL 的数据库内存？</p>
<ul>
<li>不会，MySQL 服务端全表扫描时，采取边读边发的方式处理读到的记录，每次发送的记录数取决于网络带宽。所以不是全部读完再一次性发给客户端，不会产生 OOM</li>
</ul>
<h3 id="正文-7"><a href="#正文-7" class="headerlink" title="正文"></a>正文</h3><h4 id="InnoDB-更新-写-操作"><a href="#InnoDB-更新-写-操作" class="headerlink" title="InnoDB 更新(写)操作"></a>InnoDB 更新(写)操作</h4><p>在 InnoDB 引擎中，读取操作会将数据以数据页的维度从磁盘读取到内存，每个数据页默认 16KB。<br>更新操作时，如果数据页在内存中，直接更新内存，如果不在内存中，将更新操作缓存在一块称为<code>changeBuffer</code>的内存中，下次读取到数据页时，再执行更新操作到数据页中，称为<code>merge</code></p>
<p>changeBuffer 适用于写多读少的场景，因为在 merge 前，buffer 的更新操作显然是越多越好，如果是读写平均或者写少读多的场景，写完之后立刻再查询，不仅要频繁加载数据页到内存，还多了 merge 操作的代价，changeBuffer 反而起了副作用</p>
<p>无论是直接更新内存中的数据页，还是写 changeBuffer，都会把这些内存操作记录在 redoLog，这就是为什么 redoLog 具备<code>crash-safe</code>的能力，当数据库 crash 后重启并从磁盘加载数据页到内存后，依然能通过 redoLog 找回之前未执行到磁盘的操作，不会丢数据</p>
<p>因为这套内存缓存机制，内存中的数据页和磁盘中的数据页会出现不一致，称内存中的数据页为<code>脏页</code>。数据库会在一些情况下将内存数据页刷入磁盘，称为<code>flush</code><br>执行 flush 操作时会影响当前时刻的 SQL 执行效率，感觉就像是 MySQL 抖了一下，因此需要清楚哪些时刻会 flush：</p>
<ul>
<li>redoLog 写满时，需要预留日志空间，所以 redoLog 对应的更新操作需要 flush 到磁盘，redoLog 才能“放心地擦除这些日志”。注意，redoLog 写满时，所有更新操作都会阻塞，这也很好理解，因为写 redoLog 会失败</li>
<li>内存满时（通常是一个查询需要加载新的数据页造成），需要清空一些内存，对于脏页，就需要执行 flush，这时对于查询操作响应时间明显边长<ul>
<li>注意，这种脏页淘汰产生的 flush，不会擦除 redoLog 对应的日志（因为可能散落在不同的位置，实现很麻烦）。基于 redoLog 在重放时，会跳过已经 flush 到磁盘的操作</li>
</ul>
</li>
<li>数据库在认为不繁忙时，会执行 flush</li>
<li>数据库正常关闭时，所有脏页都需要 flush</li>
</ul>
<p>对于脏页 flush 产生的 MySQL 抖动性能问题，数据库提供了脏页 flush 的速率控制参数，可以综合磁盘的性能设置一个合理值来尽可能降低 flush 对性能的影响。同时 InnoDB 也会基于 redoLog 的写入速率和当前脏页比例，动态调整 flush 速率，在 redoLog 写入速率较快或脏页占比高时，会增加 flush 速率。</p>
<p>唯一索引和普通索引在查询时性能表现几乎一致，只不过普通索引在查询成功后，会多做一些指针移动和计算，寻找后续的记录是否也满足条件，这对于现代 CPU 来说不会有任何性能问题，但唯一索引和普通索引在数据更新时的性能有明显差距<br>对于使用唯一索引的更新操作，因为要校验唯一性，所以必然要将数据页从磁盘读取到内存中，这涉及到随机 IO 访问，是数据库成本最高的操作之一！校验无误后，更新内存中的数据页<br>由此可知，<code>唯一索引的更新不会使用changeBuffer</code>，但对于普通索引的更新，即使要更新的记录不在数据页中，可以使用 changeBuffer 避免加载数据页，因此在性能上优于唯一索引<br>因此，一般情况下，使用 changeBuffer 机制+普通索引，在更新操作的性能表现上优于唯一索引。如果业务不依赖数据库做唯一校验，推荐使用普通索引而非唯一索引</p>
<h4 id="InnoDB-查询-读-操作"><a href="#InnoDB-查询-读-操作" class="headerlink" title="InnoDB 查询(读)操作"></a>InnoDB 查询(读)操作</h4><p>查询请求在 InnoDB 层会优先查询<code>BufferPool</code>管理的内存数据页，使用<code>内存命中率</code>来表示可从 BufferPool 直接查到的概率，一般线上系统要稳定在 99%以上，BufferPoolSize 一般设为可用物理内存的 60%~80%<br>当查询不能命中内存时，就需要走磁盘，并将新的数据页加载到内存，同时淘汰一个旧数据页，淘汰算法使用的是<code>LRU</code>（LeastRecentUsed，最近最少使用），链表实现，头结点表示最近一次访问到的数据页</p>
<p>但如果做全表扫描一个历史数据表（平时没有查询调用），那么查询过程中就会有很多这张表的数据页被加载到 BufferPool，这必然造成内存命中率急剧下降，因此 InnoDB 对 LRU 算法做了优化：<br>链表按 5:3 比例分为 Young 区和 Old 区，Young 在前。每次需要加载到 BufferPool 的数据页，会被放在 Old 区，如果下一次访问数据页的时间间隔超过 1 秒（默认），则移到 Young 区，否则还是在 Old 区。这就保障了临时查询的数据页一直在 Old 区，很快会被替换掉。这样大表扫描的数据页只会短暂存在 Old 区，对内存命中率不会产生过度影响</p>
<h4 id="InnoDB-删除操作"><a href="#InnoDB-删除操作" class="headerlink" title="InnoDB 删除操作"></a>InnoDB 删除操作</h4><p>delete 操作不会对磁盘上的记录做物理删除(表文件大小不变)，只会标记为删除（逻辑删除），后续新增的记录可以复用这条记录的位置<br>由此可知，delete 后标记为“删除”的空间，如果未被复用，就会成为<code>空洞</code><br>另一方面，插入数据也可能造成空洞，当数据页不能存放新增的记录时，会进行<code>页分裂</code>成两个数据页，分裂出的新数据页会存储原数据页一部分数据，因此原数据页的这部分空间如果未被再利用，就会成为空洞<br>解决空洞的办法是<code>重建表</code>，命令是<code>alter table t engine=InnoDB,algorithm=inplace</code>，这是一个 DDL 操作。因为重建表会按主键顺序重新执行一遍插入操作而非业务过程中的随机插入、删除，所以不存在页分裂和逻辑删除，也就不存在空洞<br>InnoDB 在重建表时，先加 MDL 读锁防止其他 DDL 操作（DML 操作加的也是 MDL 读锁，所以依然能增删改查），然后生成一个临时文件存储表中的所有数据，生成过程中，对原表所有操作记录在 rowLog 日志文件，临时文件生成后，将 rowLog 所有操作应用到临时文件，最后用临时文件代替原表的数据文件，整个过程对客户端来说是无感知的，重建表期间依然可以进行增删改查，因此这种方式又称为<code>Online DDL</code></p>
<p>inplace 和 online 的区别<br>InnoDB 使用的这种 online 重建表，使用的临时文件也是 InnoDB 生成的，所以也是<code>inplace</code>（原地操作）的解决方案。另一种重建表的方式是在 Server 层新建一个真正的拷贝表（<code>altable table t engine=InnoDB,algorithm=copy</code>），这种方式不是 online 的，需要阻塞增删改查操作。但 inplace 方式和 online 效果并不是一定等价的，有些 inplace 方式的操作也不是 online 的</p>
<h4 id="count-操作的性能分析"><a href="#count-操作的性能分析" class="headerlink" title="count 操作的性能分析"></a>count 操作的性能分析</h4><p>MyISAM 因为不支持事务，所以可以很简单地把表的总行数写在磁盘上，count(<em>)时直接返回即可<br>对于支持事务的 InnoDB，因为事务中的读操作是事务隔离的，因此每个事务在 MVCC 的实现里，当前时刻可读取的表总行数可能是不同的。例如事务 A 查询 count(</em>)，而事务 B 同时新增了一条记录后查询 count(*)，在可重复度隔离级别下，事务 A 查到的总记录数就比事务 B 少一个。所以 InnoDB 不能简单地把总行数记在磁盘上</p>
<p>那么 InnoDB 是如何实现 count 查询呢？<br><code>InnoDB会扫全表并筛选事务可读的所有记录，由Server层统计行数后返给客户端</code>，这就是为什么当表很大时，count 操作会有性能问题<br>count 的字段不同，也会有性能差距，按性能从优到差排序后如下：</p>
<ul>
<li>count(*)，InnoDB 并不会把全部字段取出，而是专门做了优化，不取值，省去了整行数据解析和字段拷贝操作，性能是最优的</li>
<li>count(1)，每行记录都替换为 1 后返给 Server 层，因此性能和 count(*)基本相同</li>
<li>count(主键 id)，因为主键 id 不可能为空，则不需要对字段进行判空，把每行记录的 id 取出后返给 Server 层，需要数据解析和字段拷贝</li>
<li>count(字段)，因为字段可能为空，所以相对于 count(主键 id)，需要对扫到的字段进行额外判空校验，通过后将字段返给 Server 层，需要数据解析和字段拷贝</li>
</ul>
<p>所以结论是推荐使用 count(*)<br>随着数据变多，无法接受 count 操作的性能问题时，可以将行数存储在表里，每次插入操作后该值+1，这两步做到一个事务里，由事务隔离的数据读取一致性保证事务间查询 count 操作的正确性（不会出现事务能读到 N+1 行，但只能 count 出 N 行，类似这种 case）。<br>另外，事务里先插入后更新行数还是反过来呢？基于行锁的二阶段协议，应该后执行并发高的更新行数操作，最大程度减少事务里阻塞在行锁的时间</p>
<h4 id="order-by-操作的性能分析"><a href="#order-by-操作的性能分析" class="headerlink" title="order by 操作的性能分析"></a>order by 操作的性能分析</h4><p>对使用”order by field”的查询，MySQL 会对满足条件的数据集用一块<code>sort buffer</code>内存空间做排序（快排），当 sort buffer 不足时，会使用磁盘上的临时文件排序（归并排序）<br>排序时每行记录有多少字段，取决于排序内存大小，原则是排序时尽量<code>全字段排序</code>，这样排序后的结果直接返给 Server 层，性能较优。否则，使用<code>rowid排序</code>，即每行记录只有要排序的字段和主键 id，排序后还需要再回表拿到需要的字段数据，增加了磁盘访问次数，性能较差</p>
<p>不过有时也不需要对结果集再做排序，当查询条件+orderby 命中联合索引时，从索引树上就能拿到排序后的结果，只要回表拿到数据就能直接返回。如果查询利用了索引覆盖，还可以省去回表，性能是最优的</p>
<p>全字段排序相比于 rowid 排序，省去了二次回表的性能损耗，但如果回表不需要磁盘访问，例如源表是<code>内存临时表</code>，那么回表的性能损耗是很低的（只针对内存临时表，如果数据量更大时使用磁盘临时表，回表依然有性能损耗），这时<code>rowid排序</code>相比<code>全字段排序</code>更省空间，所以内存临时表的排序就优先使用 rowid 排序<br>例如 order by rand()随机排序，会使用临时表存储对要查询的字段调用 rand 函数生成的随机数，然后对临时表应用上面的排序流程。不过对于随机查询，不建议使用这种方式，因为涉及到生成临时表、随机数、排序，可以有一种性能更优的替代方案：count(*)取行数 N，基于行数计算随机数 X，用 limit X,1 查询到随机行，这种方式只会扫描 N+X+1 行</p>
<h4 id="全表扫描做了些什么"><a href="#全表扫描做了些什么" class="headerlink" title="全表扫描做了些什么"></a>全表扫描做了些什么</h4><p>当一个表很大时，做全表扫描会不会把数据库内存打满造成 OOM？必然不会，虽然做全表扫描查询，但 MySQL 服务端是边读边发的，每次查询的数据量依赖于网络通信的可传输 buffer 大小，所以不会造成 OOM<br>但这种方式对客户端是有要求的，默认客户端使用 mysql_store_result 接口，会将查询结果放入本地内存后就返回成功，但如果客户端使用 mysql_use_result 接口，会读一行处理一行，当处理逻辑耗时较长，导致服务端结果发不出去，就变成了长事务</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码-SpringBoot Starter实现原理</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81-SpringBoot%20Starter%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h1><p>在理解<code>springboot starter实现原理</code>前，需要掌握以下内容。</p>
<h2 id="SPI-机制加载三方工厂类"><a href="#SPI-机制加载三方工厂类" class="headerlink" title="SPI 机制加载三方工厂类"></a>SPI 机制加载三方工厂类</h2><p>springboot 通过<code>SpringFactoriesLoader</code>加载并实例化 classpath 下<code>META-INF/spring.factories</code>配置文件里 KV 方式声明的工厂实现类，key&#x3D;factoryClass 全路径，value 为实现类全路径。这些工厂实现类由第三方实现，并配置到<code>META-INF/spring.factories</code></p>
<p>SpringFactoriesLoader 是 JavaSPI 机制的一种实现方式，可按一定规则加载三方的实现类。如果想自己实现一套 SPI，可以借鉴 Spring 在这里的源码</p>
<p>源码入口：<code>org.springframework.core.io.support.SpringFactoriesLoader#loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</code><br>传入工厂类 class，方法内部加载 classpath 下<code>META-INF/spring.factories</code>文件，得到 Properties 对象，然后以传入的工厂类全类名为 key，获取所有三方实现的工厂类全路径 List，再反射得到三方工厂类实例 List</p>
<ul>
<li>测试代码：org.springframework.core.io.support.SpringFactoriesLoaderTests</li>
</ul>
<h2 id="Import-注解方式导入-bean"><a href="#Import-注解方式导入-bean" class="headerlink" title="@Import 注解方式导入 bean"></a>@Import 注解方式导入 bean</h2><p>@Import 导入的 bean 有这么几类：</p>
<ul>
<li>普通 bean</li>
<li>@Configuration 修饰的配置 bean<ul>
<li>@Configuration 修饰的类称为配置类，配置类里定义了需要注册到 Spring 容器的 bean。同时，配置类如果使用@Import 注解，也会把 Import 导入的 bean 注册到 beanFactory</li>
</ul>
</li>
<li>ImportBeanDefinitionRegistrar 注册器</li>
<li>实现 ImportSelector 接口指定要导入的类<ul>
<li>ImportSelector 一般会<code>配合注解实现bean的动态注册</code>。由类似@Enablexxx 注解引入@Import 注解，导入 ImportSelector 实现类，该实现类能拿到与@Enablexxx 平级的的所有注解，实现基于运行时获取的注解参数动态注册 bean。@Enablexxx 注解通常加在配置类上</li>
</ul>
</li>
</ul>
<p>@Import 一般加在配置类上，通过对配置类的解析，将@Import 导入的 bd 也注册到 bf，接下来从源码来具体分析。</p>
<h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h2><p><code>ConfigurationClassPostProcessor</code>是 Spring 自带的的 bfpp，对于注解驱动的 ac，在构建 bf 阶段将其 bd 注册到 bf。在 ac 初始化流程的后置处理 bf 阶段，加载 ConfigurationClassPostProcessor，并调用它的<code>postProcessBeanDefinitionRegistry</code>方法，以配置类（应用启动类） bean 为源头，解析并注册其他的 bd 到 bf</p>
<p>通过配置类注册的 bean 主要包含这么几类：</p>
<ul>
<li>ComponentScan 扫描的 bean</li>
<li>@Bean 方法定义的 bean</li>
<li>@Import 导入的 bean</li>
</ul>
<p>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 的主流程是：</p>
<p>先从 bf 筛选出所有配置类的 bd。因为注解驱动的 ac 指定了启动的配置类，该配置类的 bd 在构建 bf 时注册，所以这里当前只会筛选出该配置类的 bd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;</span><br><span class="line">	configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">			className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">		// Can reuse the pre-parsed metadata from the given BeanDefinition...</span><br><span class="line">		metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	// bean包含@Configuration注解，是FullConfigurationBean，bd的attr里打full标</span><br><span class="line">	if (isFullConfigurationCandidate(metadata)) &#123;</span><br><span class="line">		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">	&#125;</span><br><span class="line">	// bean包含@Component、@ComponentScan、@Import、@ImportResource注解，或@Bean方式注册的bean，是LiteConfigurationBean，bd的attr里打lite标</span><br><span class="line">	else if (isLiteConfigurationCandidate(metadata)) &#123;</span><br><span class="line">		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 <code>ConfigurationBeanParser</code> 对象，专门来解析配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser parser = new ConfigurationClassParser(</span><br><span class="line">				this.metadataReaderFactory, this.problemReporter, this.environment,</span><br><span class="line">				this.resourceLoader, this.componentScanBeanNameGenerator, registry);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">parser.parse(candidates);</span><br></pre></td></tr></table></figure>

<p>ConfigurationBeanParser 读取配置类 bd，创建<code>ConfigurationClass</code>对象来封装配置类的注解信息，然后开始真正的解析工作</p>
<ul>
<li>解析阶段还会将解析到的一些信息添加到 ConfigurationClass 对象，包括@ImportResource 指定的 bd 配置文件路径、@Import 导入的 ImportBeanDefinitionRegistrar 等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processConfigurationClass(new ConfigurationClass(metadata, beanName));</span><br></pre></td></tr></table></figure>

<p>1、如果配置类使用了@PropertySource 注解，读取注解，将应用配置文件添加到 ac 的 environment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">		sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">		org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">	if (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class="line">		processPropertySource(propertySource);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +</span><br><span class="line">				&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">Resource resource = this.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      if (this.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">	propertySources.addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1);</span><br><span class="line">	propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、获取并注册@ComponentScan 注解指定的包路径下的所有 bd，对于@Component 和@Configuration 修饰的 bean，都当做配置 bean，将其 bd 封装成 ConfigurationClass 对象，以该 bean 为源头再次解析并注册通过它引入的 bd，即这里会产生方法递归，回到步骤 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">		sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">if (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">		!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">	for (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">		// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><br><span class="line">		// 扫描@ComponentScan路径下的bean，得到beanDefinition</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">				this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">		// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><br><span class="line">		for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">			BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">			if (bdCand == null) &#123;</span><br><span class="line">				bdCand = holder.getBeanDefinition();</span><br><span class="line">			&#125;</span><br><span class="line">			// 校验bean是否为ConfigurationBean，然后对ConfigurationBean打标</span><br><span class="line">			if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class="line">				// 如果是ConfigurationBean，再递归执行解析流程</span><br><span class="line">				parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、深度遍历配置类的所有注解，找到所有@Import 注解，将导入类封装为 SourceClass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   private Set&lt;SourceClass&gt; getImports(SourceClass sourceClass) throws IOException &#123;</span><br><span class="line">	Set&lt;SourceClass&gt; imports = new LinkedHashSet&lt;&gt;();</span><br><span class="line">	Set&lt;SourceClass&gt; visited = new LinkedHashSet&lt;&gt;();</span><br><span class="line">	collectImports(sourceClass, imports, visited);</span><br><span class="line">	return imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、开始处理导入类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), true);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果导入类是 ImportSelector 类型，实例化后回调它的 selectImports 方法获取导入 bean 的类路径，将这些待导入 bean 封装为 sourceClass，回到步骤四继续递归处理这些导入类<ul>
<li>selectImports 方法的入参是引入@Import 注解的配置类上的所有注解信息，因此实现 selectImports 时，可以基于配置类注解信息动态选择要导入哪些 bean</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">    // Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span><br><span class="line">    Class &lt; ?&gt;candidateClass = candidate.loadClass();</span><br><span class="line">    // 反射实例化ImportSelector</span><br><span class="line">    ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">    // 执行ImportSelector的自省注入</span><br><span class="line">    ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);</span><br><span class="line">    if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) &#123;</span><br><span class="line">        this.deferredImportSelectors.add(new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 回调selectImports方法得到业务层想要通过Import注册的bean，传入Import所属ConfigurationBean的注解信息</span><br><span class="line">        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">        // 加载selectImports返回的ImportClass，封装为SourceClass</span><br><span class="line">        Collection &lt; SourceClass &gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">        // 递归处理ImportClass</span><br><span class="line">        processImports(configClass, currentSourceClass, importSourceClasses, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果导入类是 ImportBeanDefinitionRegistrar，实例化注册器 registrar，然后添加到引入该@Import 注解的配置类的 ConfigurationClass 对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">    candidateClass = candidate.loadClass();</span><br><span class="line">    ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar) BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">    ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);</span><br><span class="line">    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果都不是，说明导入的是普通 bean，将导入 bean 封装成 ConfigurationClass 对象，回到步骤 1 当做配置类递归解析<ul>
<li>还会为@Import 导入的 bean 缓存”导入该 Bean 的配置类上所有注解”，如果导入 bean 实现了<code>ImportAware</code>（Import 自省），bean 初始化前置处理时，<code>ImportAwareBeanPostProcessor</code>会从 ConfigurationClassParser 拿到导入 bean 所属的配置类上所有注解，通过自省接口传递给导入 bean。<code>不过导入bean必须用@Configuration注解修饰!</code></li>
<li>最佳实践：@Import 导入@Configuraion 修饰的配置 Bean，该 Bean 通过 Import 自省方式拿到引入@Import 注解的配置类上所有注解参数，在该配置 Bean 的@Bean 方式实例化 bean 时作为动态参数传入</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    // 维护ImportClass和引入@Import的配置类注解信息，当ImportClass在bean加载的初始化前置处理阶段，自省获取引入它的配置类注解信息，see ImportAwareBeanPostProcessor</span><br><span class="line">    this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">    // 如果不是ImportSelector也不是ImportBeanDefinitionRegistrar，当做配置类重新解析</span><br><span class="line">    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    if (bean instanceof ImportAware) &#123;</span><br><span class="line">        ImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);</span><br><span class="line">        AnnotationMetadata importingClass = ir.getImportingClassFor(bean.getClass().getSuperclass().getName());</span><br><span class="line">        if (importingClass != null) &#123; ((ImportAware) bean).setImportMetadata(importingClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、将配置类 ImportResource 注解指定的配置文件路径添加到 ConfigurationClass 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">if (importResource != null) &#123;</span><br><span class="line">    String[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class="line">    Class &lt; ?extends BeanDefinitionReader &gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class="line">    for (String resource: resources) &#123;</span><br><span class="line">        String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">        configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、将配置类里使用@Bean 的方法添加到 ConfigurationClass 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set &lt; MethodMetadata &gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">for (MethodMetadata methodMetadata: beanMethods) &#123;</span><br><span class="line">    configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、如果配置类有父类，回到步骤 1 继续解析父类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">    String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">    if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">        this.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">        // Superclass found, return its annotation metadata and recurse</span><br><span class="line">        return sourceClass.getSuperClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、ConfigurationClass 添加到 ConfigurationClassParser</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.configurationClasses.put(configClass, configClass);</span><br></pre></td></tr></table></figure>

<p>9、从 ConfigurationClassParser 取出所有 ConfigurationClass，注册 bd 以及它引入的 bd</p>
<p>ConfigurationClass 可能的来源：</p>
<ul>
<li>@ComponentScan 扫描的@Component 和@Configuration</li>
<li>@Import 导入的普通 bean，也可能是 ImportSelector 方式指定的普通 bean</li>
</ul>
<p>这里注册的 bd 只包括@Import 导入的 bean 和@Bean 方式创建的 bean，@ComponentScan 扫到的 bean 在解析 ConfigurationClass 的过程中已经注册了</p>
<ul>
<li>【@Bean 方法、ImportBeanDefinitionRegistrar、@ImportResource 指定的配置文件】会添加到其所属的配置类 ConfigurationClass，然后在这里从 ConfigurationClass 取出并注册 bd</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (configClass.isImported()) &#123;</span><br><span class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">&#125;</span><br><span class="line">for (BeanMethod beanMethod: configClass.getBeanMethods()) &#123;</span><br><span class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br></pre></td></tr></table></figure>

<p>注册@Bean 方法指定的 bd 时，如果使用了@Conditional 注解，加载 Condition 类，调用 matches 方法，返回 true 才会注册到 bf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) &#123;</span><br><span class="line">    ConfigurationClass configClass = beanMethod.getConfigurationClass();</span><br><span class="line">    MethodMetadata metadata = beanMethod.getMetadata();</span><br><span class="line">    String methodName = metadata.getMethodName();</span><br><span class="line">    if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        configClass.skippedBeanMethods.add(methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>condition 类我们一般继承 ConfigurationCondition，实现它的方法<code>getConfigurationPhase</code>指定 condition 作用的阶段，对于@Bean 时使用的 condition，我们指定 condition 作用的阶段为<code>ConfigurationPhase.REGISTER_BEAN</code>，这样在注册@Bean 的 bd 时该 condition 才会生效并被回调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    List &lt; Condition &gt; conditions = new ArrayList();</span><br><span class="line">    Iterator var4 = this.getConditionClasses(metadata).iterator();</span><br><span class="line"></span><br><span class="line">    while (var4.hasNext()) &#123;</span><br><span class="line">        String[] conditionClasses = (String[]) var4.next();</span><br><span class="line">        String[] var6 = conditionClasses;</span><br><span class="line">        int var7 = conditionClasses.length;</span><br><span class="line"></span><br><span class="line">        for (int var8 = 0; var8 &lt; var7; ++var8) &#123;</span><br><span class="line">            String conditionClass = var6[var8];</span><br><span class="line">            Condition condition = this.getCondition(conditionClass, this.context.getClassLoader());</span><br><span class="line">            conditions.add(condition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnnotationAwareOrderComparator.sort(conditions);</span><br><span class="line">    var4 = conditions.iterator();</span><br><span class="line"></span><br><span class="line">    Condition condition;</span><br><span class="line">    ConfigurationPhase requiredPhase;</span><br><span class="line">    do &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (!var4.hasNext()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            condition = (Condition) var4.next();</span><br><span class="line">            requiredPhase = null;</span><br><span class="line">            if (condition instanceof ConfigurationCondition) &#123;</span><br><span class="line">                requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ( requiredPhase != null &amp;&amp; requiredPhase != phase );</span><br><span class="line">    &#125; while ( condition . matches ( this . context , metadata ));</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 ConfigurationCondition 的实现类指定作用的阶段为<code>ConfigurationPhase.PARSE_CONFIGURATION</code>，则 condition 在配置类解析阶段生效，如果返回 false，则直接跳过该配置类，也就是说，既不会注册该配置类，也不会注册由该配置类间接引入的 bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException &#123;</span><br><span class="line">    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>ConfigurationClassParser 从@Configuration 配置类里二次解析由它引入的 bean，包括@ComponentScan 方式、@Bean 方式和@Import 导入方式，并将@ComponentScan 扫到的 bean 的 bd 注册到 bf<br>ConfigurationClassPostProcessor 负责把 ConfigurationClassParser 解析得到的@Import 方式导入的 bean 和@Bean 方式注册的 bean 的 bd 注册到 bf。同时，@Import 方式导入的 Bean 能通过 Import 自省获取导入它的配置类上所有注解</p>
<h3 id="简易流程图"><a href="#简易流程图" class="headerlink" title="简易流程图"></a>简易流程图</h3><p><img src="/images/Spring1.png"></p>
<h3 id="详细流程图"><a href="#详细流程图" class="headerlink" title="详细流程图"></a>详细流程图</h3><p><img src="/images/ConfigurationClassPostProcessor.png"></p>
<h1 id="springboot-start-实现原理"><a href="#springboot-start-实现原理" class="headerlink" title="springboot start 实现原理"></a>springboot start 实现原理</h1><p>sb 应用的启动类的<code>@SpringBootApplication</code>注解的元注解包括<code>@EnableAutoConfiguration</code>和<code>@SpringBootConfiguration</code>，@SpringBootConfiguration 的元注解包括@Configuration，因此 sb 应用的启动类就是一个配置类<br>@EnableAutoConfiguration 的元注解包括<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>，因此 AutoConfigurationImportSelector 能拿到@EnableAutoConfiguration 注解的参数，实现动态注册 bean 到 sb 应用。不过 AutoConfigurationImportSelector 并没有这么做，而是使用 SpringFactoriesLoader 提供的 spi 机制来注册用户的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected List &lt; String &gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List &lt; String &gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用工具类<code>SpringFactoriesLoader</code>的 loadFactoryNames 方法，获取 cp 路径下<code>META-INF/spring.factories</code>配置文件里指定 key&#x3D;<code>this.getSpringFactoriesLoaderFactoryClass()</code>对应的类路径。<code>getSpringFactoriesLoaderFactoryClass()</code>方法的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class &lt; ?&gt;getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    return EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，这里的 key&#x3D;org.springframework.boot.autoconfigure.EnableAutoConfiguration</p>
<p>总结：</p>
<p>SpringBoot 启动类作为配置类，通过<code>@EnableAutoConfiguration</code>的元注解<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>，动态注册 cp 路径下<code>META-INF/spring.factories</code>配置文件里 key&#x3D;org.springframework.boot.autoconfigure.EnableAutoConfiguration 对应的 value bean，即用户配置类 bean。这种通过 spi 方式动态注册用户 bean 的机制称为 springboot-starter</p>
<p><img src="/images/spring2.png"></p>
<p>因此，如果希望外部 sb 应用能注册自己提供的 bean，可以利用 springboot-starter 机制。只需要创建一个配置类定义外部应用依赖该 starter 的组件 bean，然后在 starter 包的<code>META-INF/spring.factories</code>配置文件里指定 key&#x3D;org.springframework.boot.autoconfigure.EnableAutoConfiguration，value&#x3D;{配置类全路径}。外部 sb 应用依赖 starter 包后，就会通过 starter 机制注册配置类和由它引入的 bean 到 bf</p>
<p>starter 机制其实也是 sb 提倡的<code>约定大于配置</code>思想的体现，约定好 SpringFactoriesLoader 加载 starter 配置类声明文件的文件名和路径，sb 就会自动注册配置 bean 和由它引入的 bean。否则你定义一个配置类声明文件路径，它又定义一个，增加了复杂度和做决定的成本，通过约定产生的规范减少这种开销，也不失灵活性，所以一定限度的规范约束是能大大提高生产力的！</p>
<h1 id="Enable-机制动态注册-bean"><a href="#Enable-机制动态注册-bean" class="headerlink" title="@Enable 机制动态注册 bean"></a>@Enable 机制动态注册 bean</h1><p>动态注册外部 bean 其实有很多方式，其实从根上都是基于@Import 注解来做文章。与 starter 机制类似的还有一种@Enable 机制动态注册 bean，它们的区别是 ImportSelector 的实现逻辑不同。</p>
<p>@Enable 机制可以不依赖<code>@EnableAutoConfiguration</code>注解，在包中自定义一个注解如<code>@EnableMyApp</code>，然后把<code>@Import(&#123;XXImportSelector.class&#125;)</code>作为元注解，<code>XXImportSelector</code>里指定包对外提供的组件 bean。外部应用只要在自己的配置类中加上我们的<code>@EnableMyApp</code>注解，就可以将包下的组件 bean 注册到 bf</p>
<p>其实这种通过自定义@EnableXXX 注解引入 ImportSelector 来动态注册组件 bean 的方式在 Spring 中也有实际案例，<code>@EnableTransactionManagement</code>自动注册事务组件，<code>@EnableCaching</code>自动注册缓存组件</p>
<p>和 starter 机制最大的区别是，starter 是按约定的路径无脑注册 bean，而这种@Enable 机制能通过注解参数在运行时动态决定加载哪些 bean。前面说过，ImportSelector 可以获取引入它的配置类上的所有注解信息，自然也能拿到引入它的@EnableXXX 注解的参数，然后通过注解参数动态控制要注册的 bean。<code>@EnableTransactionManagement</code>和<code>@EnableCaching</code>这两个注解都包含参数<code>AdviceMode mode() default AdviceMode.PROXY;</code>，AdviceModeImportSelector 负责拿到这个 mode 枚举，提供模板方法传递给子类 selector，子类基于不同枚举 mode 选择要动态注册哪些组件 bean</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码-Spring容器</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81-Spring%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在讲 beanFactory 架构时说过，接口<code>ConfigurableBeanFactory</code>表明 bean 工厂是可配置的，为了让用户能方便的配置 bean 工厂，Spring 设计了代表 Spring 容器的顶级接口<code>ApplicationContext</code>。如果说 bean 工厂负责管理 bean 的生命周期，提供的扩展能力是对 bean 的定制，那么 Spring 容器则站在更高的维度，提供对 bean 工厂的定制能力以及应用维度的事件发布和消费能力等：</p>
<ul>
<li>支持多种 Spring 配置方式来构建 beanFactory</li>
<li>轻松定制 beanFactory</li>
<li>支持应用事件广播和监听</li>
</ul>
<h1 id="ApplicationContext-架构"><a href="#ApplicationContext-架构" class="headerlink" title="ApplicationContext 架构"></a>ApplicationContext 架构</h1><h2 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>顶层接口，用来指代一个 Spring 容器，<code>getAutowireCapableBeanFactory</code>方法用来获取一个可依赖注入的 bean 工厂，可见 Spring 容器的核心就是包了一个基础的 bean 工厂</p>
<h3 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h3><p>继承<code>ApplicationContext</code>，描述一个可配置 beanFactory 的 Spring 容器，定义配置方法，例如添加 bfpp<code>addBeanFactoryPostProcessor</code>、添加应用事件监听器<code>addApplicationListener</code></p>
<ul>
<li>类比<code>ConfigurableBeanFactory</code>，描述的是可配置的 bean 工厂，实现对 bean 加载过程的定制，例如给 bean 工厂配置 bpp。对于 Spring 容器而言，它的可配置体现在对 bean 工厂本身的定制化，因此提供的扩展是 bean 工厂处理器 bfpp。需要说明的是，bfpp 虽然定制的是 bean 工厂，但最终还是通过 bean 工厂影响 bean，本质上还是对 bean 加载过程的定制</li>
</ul>
<p>定义核心方法<code>refresh</code>，用来刷新（初始化）Spring 容器。大部分具体的 Spring 容器实现类都会在构造函数里调用该方法实现容器的初始化<br>定义核心方法<code>close</code>，关闭 Spring 容器时调用</p>
<h3 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h3><p><code>ConfigurableApplicationContext</code>的实现类，描述了一个可配置的 Spring 容器，它做到了这些事情：</p>
<ul>
<li>可添加 bfpp、应用事件监听器</li>
<li>实现了<code>refresh</code>方法，框定了 Spring 容器初始化的流程，该方法的实现后面会详细介绍</li>
<li>实现了<code>close</code>方法，框定了 Spring 容器关闭的流程，执行所有单例 bean 的销毁生命周期</li>
</ul>
<p>ConfigurableApplicationContext 在 refresh 方法里定义了一些模板方法，需要子类在容器初始化过程中做这些事情：</p>
<ul>
<li>实现模板方法<code>refreshBeanFactory</code>，构建一个 DefaultListableBeanFactory。根据对该方法的不同实现方式，可以将子类容器分为两大类，<code>Refreshable 的容器和 Generic 的容器</code>，区别是 Refreshable 容器真正实现了该模板方法，所以每次调用 refresh 方法，都会重新构建 bf，而 Generic 容器做了个空实现，实际在构造函数里先构建好 bf，所以调用 refresh 方法不会再重新构建 bf</li>
<li>实现模板方法<code>closeBeanFactory</code>，Spring 容器关闭时调用。这个目前子类容器也没有特殊的实现</li>
<li>实现模板方法<code>postProcessBeanFactory</code>，容器初始化过程中后置处理构建好的 bf</li>
</ul>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><p>基于 XML 构建 bf 的 refreshable 的 Spring 容器，实现 refreshBeanFactory 方法，每次调用 refresh 都会基于 xml 构建 bf</p>
<h3 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a>AnnotationConfigWebApplicationContext</h3><p>基于注解构建 bf 的 refreshable 的 Spring 容器，实现 refreshBeanFactory 方法，每次调用 refresh 都会基于 配置类 构建 bf</p>
<h3 id="GenericXmlApplicationContext"><a href="#GenericXmlApplicationContext" class="headerlink" title="GenericXmlApplicationContext"></a>GenericXmlApplicationContext</h3><p>基于 XML 构建 bf 的 generic 的 Spring 容器，refreshBeanFactory 方法做空实现，构造函数里基于 xml 构建 bf，调用 refresh 不会再次构建 bf</p>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p>基于 注解 构建 bf 的 generic 的 Spring 容器，refreshBeanFactory 方法做空实现，构造函数里基于 配置类 构建 bf，调用 refresh 不会再次构建 bf</p>
<h2 id="基于注解构建-bf-的说明"><a href="#基于注解构建-bf-的说明" class="headerlink" title="基于注解构建 bf 的说明"></a>基于注解构建 bf 的说明</h2><p>如果是基于注解的 Spring 容器，无论是 refreshable 的还是 generic 的，注册业务 bean 的 bd 前，都会提前向 bf 注册支持注解驱动的一些内部 bean 的 bd，重点有这么几个 bean：</p>
<ul>
<li>ConfigurationClassPostProcessor<ul>
<li>负责注册通过配置类 bean（@Configuration 修饰）间接定义的所有 bd 到 bf</li>
</ul>
</li>
<li>AutowiredAnnotationBeanPostProcessor<ul>
<li>bpp，依赖注入阶段加载并注入@Autowired 修饰的 bean，解析得到@Value 的实际值并注入到成员变量</li>
</ul>
</li>
<li>CommonAnnotationBeanPostProcessor<ul>
<li>bpp，依赖注入阶段加载并注入@Resource 修饰的 bean</li>
</ul>
</li>
</ul>
<p>see：org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ApplicationContext 架构的 UML 类图：<br><img src="/spring/ApplicationContext%E7%B1%BB%E5%9B%BE.jpg"></p>
<p>综上，<code>ApplicationContext</code>架构主要使用了<code>适配器模式</code>、<code>模板模式</code></p>
<ul>
<li><code>ApplicationContext</code>通过在内部持有一个<code>DefaultListableBeanFactory</code>，适配了 BeanFactory 接口</li>
<li>Spring 容器的刷新主流程在上层抽象类的 refresh 方法中实现。同时定义创建 bean 工厂的模板方法<code>refreshBeanFactory</code>，有两套 bean 工厂创建流程，分别由子类<code>AbstractRefreshableApplicationContext</code>和<code>GenericApplicationContext</code>实现<ul>
<li><code>AbstractRefreshableApplicationContext</code>类和<code>GenericApplicationContext</code>类都有自己的子类，分别支持 xml 方式和注解方式的 beanDefinition 注册</li>
</ul>
</li>
</ul>
<h1 id="初始化-Spring-容器"><a href="#初始化-Spring-容器" class="headerlink" title="初始化 Spring 容器"></a>初始化 Spring 容器</h1><p>容器在实例化完成后，一般会接着调用 refresh 方法初始化，或者直接在构造函数里就调用 refresh 方法，下面详述容器初始化流程</p>
<h2 id="定制系统变量"><a href="#定制系统变量" class="headerlink" title="定制系统变量"></a>定制系统变量</h2><p>回调模板方法<code>initPropertySources</code>，由三方实现，可以添加系统变量、设置哪些系统变量是必须的（不存在直接抛异常）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Initialize any placeholder property sources in the context environment.</span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line">// Validate that all properties marked as required are resolvable:</span><br><span class="line">// see ConfigurablePropertyResolver#setRequiredProperties</span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void validateRequiredProperties() &#123;</span><br><span class="line">	MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();</span><br><span class="line">	for (String key : this.requiredProperties) &#123;</span><br><span class="line">		if (this.getProperty(key) == null) &#123;</span><br><span class="line">			ex.addMissingRequiredProperty(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!ex.getMissingRequiredProperties().isEmpty()) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：applicationcontext.RequiredPropertyTest</p>
<h2 id="构建-DefaultListableBeanFactory"><a href="#构建-DefaultListableBeanFactory" class="headerlink" title="构建 DefaultListableBeanFactory"></a>构建 DefaultListableBeanFactory</h2><p>构建 Spring 容器的 DefaultListableBeanFactory，提供<code>refreshBeanFactory</code>模板方法，由子类实现，创建一个已经完成 beanDefinition 解析和注册的 bean 工厂。上面说过，只有 refreshable 的 Spring 容器在这里构建 bf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显式配置-DefaultListableBeanFactory"><a href="#显式配置-DefaultListableBeanFactory" class="headerlink" title="显式配置 DefaultListableBeanFactory"></a>显式配置 DefaultListableBeanFactory</h2><h3 id="注册-SPEL-解析器"><a href="#注册-SPEL-解析器" class="headerlink" title="注册 SPEL 解析器"></a>注册 SPEL 解析器</h3><p>显式注册解析 SpEL 的<code>StandardBeanExpressionResolver</code>，该 resolver 会在 bean 属性赋值前被调用来解析配置属性的 SpEL 表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br></pre></td></tr></table></figure>

<h3 id="注册属性编辑注册器"><a href="#注册属性编辑注册器" class="headerlink" title="注册属性编辑注册器"></a>注册属性编辑注册器</h3><p>显式注册<code>ResourceEditorRegistrar</code>，注册器会在 Bean 加载阶段被调用，给 BeanWrapper 注册一些 IO 类型的<code>PropertyEditor</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void registerCustomEditors(PropertyEditorRegistry registry) &#123;</span><br><span class="line">	ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);</span><br><span class="line">	doRegisterEditor(registry, Resource.class, baseEditor);</span><br><span class="line">	doRegisterEditor(registry, ContextResource.class, baseEditor);</span><br><span class="line">	doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));</span><br><span class="line">	doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));</span><br><span class="line">	doRegisterEditor(registry, File.class, new FileEditor(baseEditor));</span><br><span class="line">	doRegisterEditor(registry, Path.class, new PathEditor(baseEditor));</span><br><span class="line">	doRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));</span><br><span class="line">	doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));</span><br><span class="line"></span><br><span class="line">	ClassLoader classLoader = this.resourceLoader.getClassLoader();</span><br><span class="line">	doRegisterEditor(registry, URI.class, new URIEditor(classLoader));</span><br><span class="line">	doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));</span><br><span class="line">	doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));</span><br><span class="line"></span><br><span class="line">	if (this.resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">		doRegisterEditor(registry, Resource[].class,</span><br><span class="line">				new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户想添加自定义的<code>PropertyEditor</code>，可以简单覆盖<code>PropertyEditorSupport</code>的<code>setAsText</code>方法来自定义一个<code>PropertyEditor</code>，再创建它的注册器<code>PropertyEditorRegistrar</code>，然后配置一个<code>CustomEditorConfigurer</code>Bean，在 propertyEditorRegistrars 属性中加入这个 Registrar。<code>CustomEditorConfigurer</code>是 bfpp，在 beanFactory 后置处理中将<code>PropertyEditorRegistrar</code>注册到 BeanFactory</p>
<h3 id="注册-ApplicationContextAwareProcessor"><a href="#注册-ApplicationContextAwareProcessor" class="headerlink" title="注册 ApplicationContextAwareProcessor"></a>注册 ApplicationContextAwareProcessor</h3><p>显式注册 bpp：<code>ApplicationContextAwareProcessor</code>，它的作用是 bean 前置初始化时，为 bean 自动注入 Aware 方式指定的 Spring 容器组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">	if (bean instanceof Aware) &#123;</span><br><span class="line">		if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">			((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册-ApplicationListenerDetector"><a href="#注册-ApplicationListenerDetector" class="headerlink" title="注册 ApplicationListenerDetector"></a>注册 ApplicationListenerDetector</h3><p>显式注册 bpp：<code>ApplicationListenerDetector</code>，作用是对于类型为<code>ApplicationListener</code>子类的 bean，后置初始化处理时注册到 ApplicationContext。这些应用事件监听器最终会被注册到事件组播器<code>ApplicationEventMulticaster</code>。Spring 容器关闭时，<code>ApplicationListenerDetector</code>会在 bean 销毁前置回调时，将其从<code>ApplicationEventMulticaster</code>里移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">	if (bean instanceof ApplicationListener) &#123;</span><br><span class="line">		// potentially not detected as a listener by getBeanNamesForType retrieval</span><br><span class="line">		Boolean flag = this.singletonNames.get(beanName);</span><br><span class="line">		if (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">			// singleton bean (top-level or inner): register on the fly</span><br><span class="line">			this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeforeDestruction(Object bean, String beanName) &#123;</span><br><span class="line">	if (bean instanceof ApplicationListener) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			ApplicationEventMulticaster multicaster = this.applicationContext.getApplicationEventMulticaster();</span><br><span class="line">			multicaster.removeApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">			multicaster.removeApplicationListenerBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IllegalStateException ex) &#123;</span><br><span class="line">			// ApplicationEventMulticaster not initialized yet - no need to remove a listener</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册-environment-相关-bean-到-BeanFactory"><a href="#注册-environment-相关-bean-到-BeanFactory" class="headerlink" title="注册 environment 相关 bean 到 BeanFactory"></a>注册 environment 相关 bean 到 BeanFactory</h3><p>注册 ConfigurableEnvironment 到 bf<br>通过 environment 可以拿到 map 类型的 JVM 参数和系统环境变量，这两个 map 也一并注册到 bf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">	beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">	// JVM参数</span><br><span class="line">	beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line">if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">	// 环境变量</span><br><span class="line">	beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后置处理-bf"><a href="#后置处理-bf" class="headerlink" title="后置处理 bf"></a>后置处理 bf</h2><h3 id="提供模板方法后置处理-bf"><a href="#提供模板方法后置处理-bf" class="headerlink" title="提供模板方法后置处理 bf"></a>提供模板方法后置处理 bf</h3><p>提供模板方法 postProcessBeanFactory，由<code>AbstractApplicationContext</code>的子类（可由用户实现）覆写，后置处理 beanFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postProcessBeanFactory(beanFactory);</span><br></pre></td></tr></table></figure>

<h3 id="调用-bfpp-执行-bean-工厂后置处理"><a href="#调用-bfpp-执行-bean-工厂后置处理" class="headerlink" title="调用 bfpp 执行 bean 工厂后置处理"></a>调用 bfpp 执行 bean 工厂后置处理</h3><h4 id="bfpp-的来源"><a href="#bfpp-的来源" class="headerlink" title="bfpp 的来源"></a>bfpp 的来源</h4><p>1、调用方法<code>addBeanFactoryPostProcessor</code>显式注册到 AbstractApplicationContext</p>
<ul>
<li>注意，Spring 提供的容器没有调该方法添加任何 bfpp，可以理解为是给用户自定义容器用的。但要保证该方法必须在 refresh 方法前被调用，否则不起作用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor) &#123;</span><br><span class="line">	Assert.notNull(postProcessor, &quot;BeanFactoryPostProcessor must not be null&quot;);</span><br><span class="line">	this.beanFactoryPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、通过 bd 走 bean 加载流程得到的 bfpp。<code>AbstractApplicationContext</code>会从 bf 的全局 bd 里枚举 bfpp 的 beanName，然后加载 bfpp</p>
<ul>
<li>这细分为两类，一类是用户自己注册的 BeanFactoryPostProcessor bean，另一类是 Spring 注册内部的 bfpp 的 bd 到 bf，<code>ConfigurationClassPostProcessor</code>就是这种方式注册的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line">for (String ppName : postProcessorNames) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	beanPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bfpp-的调用顺序"><a href="#bfpp-的调用顺序" class="headerlink" title="bfpp 的调用顺序"></a>bfpp 的调用顺序</h4><p>1、调用显式注册的<code>BeanDefinitionRegistryPostProcessor</code>的子类的<code>postProcessBeanDefinitionRegistry</code>方法</p>
<ul>
<li>BeanDefinitionRegistryPostProcessor 是 bfpp 的子接口，定义<code>postProcessBeanDefinitionRegistry</code>方法，预处理 bd</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">	if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">		BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">				(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">		registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">		registryProcessors.add(registryProcessor);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		regularPostProcessors.add(postProcessor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、加载并调用 bd 注册到 bf 的<code>BeanDefinitionRegistryPostProcessor</code>的子类的<code>postProcessBeanDefinitionRegistry</code>方法</p>
<ul>
<li>优先排序并执行实现了 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor<ul>
<li>排序使用的 comparator：<code>AnnotationAwareOrderComparator</code></li>
</ul>
</li>
<li>排序执行实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor</li>
<li>排序执行剩下的 BeanDefinitionRegistryPostProcessor</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			// 执行Spring注册的BeanDefinitionRegistryPostProcessor，这里会执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line">			// 因为ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry会注册从ConfigurationBean发现的所有bean</span><br><span class="line">			// 所以需要筛选出新增的BeanDefinitionRegistryPostProcessor，调用它的postProcessBeanDefinitionRegistry</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line">			boolean reiterate = true;</span><br><span class="line">			while (reiterate) &#123;</span><br><span class="line">				reiterate = false;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">				for (String ppName : postProcessorNames) &#123;</span><br><span class="line">					if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						reiterate = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">				registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">				currentRegistryProcessors.clear();</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>3、调用 BeanDefinitionRegistryPostProcessor 子类的 postProcessBeanFactory 方法，后置处理 bfpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<p>4、调用显示注册的 bfpp 的 postProcessBeanFactory 方法，后置处理 bfpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<p>5、加载并调用 bd 注册到 bf 的 bfpp 的 postProcessBeanFactory 方法，后置处理 bfpp</p>
<ul>
<li>会 skip 上面已经调用过的 BeanDefinitionRegistryPostProcessor 子类和显示注册的 bfpp</li>
<li>依然是先排序后执行，优先 PriorityOrdered，其次 Ordered，再次剩下的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      String[] postProcessorNames =</span><br><span class="line">		beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line">// Ordered, and the rest.</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">for (String ppName : postProcessorNames) &#123;</span><br><span class="line">	if (processedBeans.contains(ppName)) &#123;</span><br><span class="line">		// skip - already processed in first phase above</span><br><span class="line">	&#125;</span><br><span class="line">	else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">		priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">		orderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">	orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">	nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<h4 id="bfpp-的应用场景举例"><a href="#bfpp-的应用场景举例" class="headerlink" title="bfpp 的应用场景举例"></a>bfpp 的应用场景举例</h4><p><code>ConfigurationClassPostProcessor</code></p>
<ul>
<li>它是<code>BeanDefinitionRegistryPostProcessor</code>的子类。基于注解的 Spring 容器会在构建 bf 阶段将 bd 注册进去。它的 postProcessBeanDefinitionRegistry 方法负责把配置类 bean 间接引入的所有 bean 的 bd 注册到 bf</li>
</ul>
<p><code>CustomEditorConfigurer</code></p>
<ul>
<li>用户可以配置这个 bean，bf 后置处理阶段，间接注册一组自定义的<code>PropertyEditorRegistrar</code>到 bf</li>
<li>测试代码：populatebean.propertyeditor.PropertyEditorTest</li>
</ul>
<p><code>PropertySourcesPlaceholderConfigurer</code></p>
<ul>
<li>Spring 解析标签”context:property-placeholder”，注册 PPC：PropertySourcesPlaceholderConfigurer。bf 后置处理阶段，将 bd.pv 里定义的占位符替换为实际值<ul>
<li>占位符替换优先级：JVM 参数-&gt;系统环境变量-&gt;应用配置文件</li>
</ul>
</li>
<li>测试代码：populatebean.value.ValueTest#testPPC</li>
</ul>
<h2 id="加载并添加配置的-bpp-到-bf"><a href="#加载并添加配置的-bpp-到-bf" class="headerlink" title="加载并添加配置的 bpp 到 bf"></a>加载并添加配置的 bpp 到 bf</h2><p>bpp 的来源只能通过配置方式，这也体现了 Spring 容器的定位，是面向 bf，而非面向 bean，所以如果需要 bpp，只能配置，不能直接通过 Spring 容器添加</p>
<ul>
<li>优先注册实现了<code>PriorityOrdered</code>、<code>Ordered</code>接口的 bpp</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line">... ...</span><br><span class="line">for (String ppName : postProcessorNames) &#123;</span><br><span class="line">	if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		priorityOrderedPostProcessors.add(pp);</span><br><span class="line">		if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">		orderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">... ...</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">... ...</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br></pre></td></tr></table></figure>

<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>基于注解的 Spring 容器，例如<code>AnnotationConfigApplicationContext</code>，在构造函数里就会给 bf 注册<code>AutowiredAnnotationBeanPostProcessor</code>的 bd，然后在这个阶段加载并将其添加到 bf。该 bpp 的作用是在 bean 加载的依赖注入阶段，解析得到@Value 的实际值或者加载@Autowired 修饰的 依赖 bean，并反射注入</p>
<ul>
<li>对于@Value，如果使用占位符，使用 StringValueResolver 来解析，如果使用 spel，使用 Spring 容器的 spel 解析器来解析</li>
</ul>
<h2 id="获取并添加应用事件组播器-ApplicationEventMulticaster-到-Spring-容器"><a href="#获取并添加应用事件组播器-ApplicationEventMulticaster-到-Spring-容器" class="headerlink" title="获取并添加应用事件组播器 ApplicationEventMulticaster 到 Spring 容器"></a>获取并添加应用事件组播器 ApplicationEventMulticaster 到 Spring 容器</h2><p>如果 bf 有组播器的 bd，即用户注册了一个自己的组播器 bean，则直接加载后作为 Spring 容器的应用事件组播器。否则 new 一个 Spring 提供的默认组播器<code>SimpleApplicationEventMulticaster</code></p>
<ul>
<li>Spring 容器发布应用事件时使用组播器，它通过观察者模式组播应用事件给注册到它的事件监听器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">	this.applicationEventMulticaster =</span><br><span class="line">			beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">	beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h3><p>作为 Spring 容器默认的事件组播器，有如下特性：</p>
<ul>
<li><p>如果 set 线程池，回调监听器的任务提交到线程池中执行</p>
</li>
<li><p>会筛选与应用事件匹配的<code>ApplicationListener</code>，再回调来处理事件，筛选规则是：</p>
<ul>
<li>如果<code>ApplicationListener</code>是<code>GenericApplicationListener</code>，调用它的 supportsEventType 和 supportsSourceType 判断事件类型和事件载体类型是否满足</li>
<li>否则，使用适配器模式包装成一个<code>GenericApplicationListenerAdapter</code>。如果<code>ApplicationListener</code>是<code>SmartApplicationListener</code>，调用它的 supportsEventType 和 supportsSourceType 判断事件类型和事件源对象类型是否满足，否则，只要<code>ApplicationEvent</code>的类型为 ApplicationListener 泛型指定事件类型或子类型即可</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   protected boolean supportsEvent(</span><br><span class="line">		ApplicationListener&lt;?&gt; listener, ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType) &#123;</span><br><span class="line"></span><br><span class="line">	GenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ?</span><br><span class="line">			(GenericApplicationListener) listener : new GenericApplicationListenerAdapter(listener));</span><br><span class="line">	return (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：applicationcontext.ApplicationListenerTest</p>
<h2 id="将显式添加到容器的-ApplicationListener-添加到组播器"><a href="#将显式添加到容器的-ApplicationListener-添加到组播器" class="headerlink" title="将显式添加到容器的 ApplicationListener 添加到组播器"></a>将显式添加到容器的 ApplicationListener 添加到组播器</h2><p>添加应用事件监听器<code>ApplicationListener</code>到组播器<code>ApplicationEventMulticaster</code></p>
<ul>
<li><code>ApplicationListener</code>的来源渠道同 bfpp，显式添加到 Spring 容器 或配置为 bean。这里只将显式添加到 Spring 容器的 listener 注册到<code>ApplicationEventMulticaster</code><ul>
<li>配置的 listener bean，通过前面介绍的 bpp：<code>ApplicationListenerDetector</code>，在 bean 后置初始化处理时添加到<code>ApplicationEventMulticaster</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void registerListeners() &#123;</span><br><span class="line">	// 显式注册到Spring容器的监听器，注册到应用事件组播器</span><br><span class="line">	for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">		getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 通过注册的BD走bean加载的监听器，beanName注册到应用事件组播器</span><br><span class="line">	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class="line">	for (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加属性占位符解析器-StringValueResolver-到-bf"><a href="#添加属性占位符解析器-StringValueResolver-到-bf" class="headerlink" title="添加属性占位符解析器 StringValueResolver 到 bf"></a>添加属性占位符解析器 StringValueResolver 到 bf</h2><p>StringValueResolver 把@Value 注解表达式中的“占位符”替换为实际值。如果 bean 工厂不存在占位符解析器<code>StringValueResolver</code>，则添加一个 lambda 表达式实现的匿名 resolver 到 bf，底层使用<code>PropertySourcesPropertyResolver</code>解析@Value 注解表达式中的占位符</p>
<ul>
<li>注意，只有@Value 表达式用占位符，即”${xxx}”书写，才会依赖 StringValueResolver</li>
<li>解析@Value 并注入是通过上面介绍的 bpp：AutowiredAnnotationBeanPostProcessor</li>
<li>解析占位符用到的配置源包括：JVM 参数、系统环境变量、应用配置文件，优先级为<ul>
<li>JVM 参数</li>
<li>系统环境变量</li>
<li>应用配置文件</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">	beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h3><p>如果 Spring 容器基于 XML 配置，且通过标签”context:property-placeholder”注册了<code>PropertySourcesPlaceholderConfigurer</code>，在 bf 后置处理时，就会添加一个 Lambda 写的匿名<code>StringValueResolver</code>到 bf，同时解析并替换 bd.pv 中的占位符。因此，上面判断 beanFactory.hasEmbeddedValueResolver() 就返回 true，不会再次添加 StringValueResolver</p>
<p>PropertySourcesPlaceholderConfigurer 给 bf 添加的 StringValueResolver 的配置源可以包含额外指定的应用配置文件</p>
<p>除了 xml 方式注册 PropertySourcesPlaceholderConfigurer，因为它就是一个 bfpp，所以也可以用户自己将其配置成 bean，添加一些 k-v 或者直接为 location 设置应用配置文件资源，作为配置源</p>
<p>测试代码：</p>
<ul>
<li>populatebean.value.ValueTest#testPPC2</li>
<li>org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests#replacementFromEnvironmentProperties</li>
<li>org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests#localPropertiesViaResource</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">	if (this.propertySources == null) &#123;</span><br><span class="line">		this.propertySources = new MutablePropertySources();</span><br><span class="line">		if (this.environment != null) &#123;</span><br><span class="line">			this.propertySources.addLast(</span><br><span class="line">				new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) &#123;</span><br><span class="line">					@Override</span><br><span class="line">					@Nullable</span><br><span class="line">					public String getProperty(String key) &#123;</span><br><span class="line">						return this.source.getProperty(key);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">					new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">			if (this.localOverride) &#123;</span><br><span class="line">				this.propertySources.addFirst(localPropertySource);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				this.propertySources.addLast(localPropertySource);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new BeanInitializationException(&quot;Could not load properties&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));</span><br><span class="line">	this.appliedPropertySources = this.propertySources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,</span><br><span class="line">		final ConfigurablePropertyResolver propertyResolver) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">	propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);</span><br><span class="line">	propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);</span><br><span class="line">	propertyResolver.setValueSeparator(this.valueSeparator);</span><br><span class="line"></span><br><span class="line">	StringValueResolver valueResolver = strVal -&gt; &#123;</span><br><span class="line">		String resolved = (this.ignoreUnresolvablePlaceholders ?</span><br><span class="line">				propertyResolver.resolvePlaceholders(strVal) :</span><br><span class="line">				propertyResolver.resolveRequiredPlaceholders(strVal));</span><br><span class="line">		if (this.trimValues) &#123;</span><br><span class="line">			resolved = resolved.trim();</span><br><span class="line">		&#125;</span><br><span class="line">		return (resolved.equals(this.nullValue) ? null : resolved);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	beanFactoryToProcess.embeddedValueResolvers.add(valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没注册 PropertySourcesPlaceholderConfigurer，则 xml 的<property>标签里指定的占位符不会被替换，因为依赖注入阶段不会对 bd.pv 中的 value 做占位符解析处理。测试代码：</p>
<ul>
<li>populatebean.value.ValueTest</li>
</ul>
<h2 id="加载单例-beans"><a href="#加载单例-beans" class="headerlink" title="加载单例 beans"></a>加载单例 beans</h2><p>预加载所有非懒加载的单例到 beanFactory（好处是提前暴露 bean 配置的错误）</p>
<ul>
<li>如果加载的 bean 实现了<code>SmartInitializingSingleton</code>接口，加载后回调 afterSingletonsInstantiated 方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">	RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">	if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">		if (isFactoryBean(beanName)) &#123;</span><br><span class="line">			... ...</span><br><span class="line">		else &#123;</span><br><span class="line">			getBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">	Object singletonInstance = getSingleton(beanName);</span><br><span class="line">	if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">		SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">		... ...</span><br><span class="line">		smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-容器初始化后置处理"><a href="#Spring-容器初始化后置处理" class="headerlink" title="Spring 容器初始化后置处理"></a>Spring 容器初始化后置处理</h2><p>此时 Spring 容器初始化流程已经结束，接下来进行的是容器初始化后置处理</p>
<h3 id="回调-SmartLifecycle-Bean-的-start-方法"><a href="#回调-SmartLifecycle-Bean-的-start-方法" class="headerlink" title="回调 SmartLifecycle Bean 的 start 方法"></a>回调 SmartLifecycle Bean 的 start 方法</h3><blockquote>
<p>有些 bean 在 Spring 容器初始化完成后要执行一些生命周期钩子函数</p>
</blockquote>
<p>如果用户注册了实现<code>LifecycleProcessor</code>接口的 bean，优先从 bd 获取并加载该 bean 作为 Spring 容器的生命周期处理器，否则创建默认的<code>DefaultLifecycleProcessor</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void initLifecycleProcessor() &#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		this.lifecycleProcessor =</span><br><span class="line">				beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();</span><br><span class="line">		defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">		this.lifecycleProcessor = defaultProcessor;</span><br><span class="line">		beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 LifecycleProcessor#onRefresh 方法，默认调用 DefaultLifecycleProcessor 的 onRefresh 方法，内部调用 startBeans 方法，参数 autoStartupOnly&#x3D;true<br>该方法先将实现了<code>SmartLifecycle</code>接口的 bean 分组，然后按分组号排序后，从小到大以组为维度调用组内部 SmartLifecycle bean 的 start 方法</p>
<ul>
<li>SmartLifecycle bean 的 isAutoStartup 方法必须返回 true，才会回调 start 方法</li>
<li>如果调用 DefaultLifecycleProcessor#start 方法，参数 autoStartupOnly&#x3D;false，会对所有的<code>SmartLifecycle</code>和<code>Lifeclcye</code>bean，分组后回调 start 方法</li>
<li>通过<code>Phased</code>接口获得分组号，如果 SmartLifecycle bean 未实现该接口，则为 0 号<ul>
<li>Spring 容器 close 时，按分组号从大到小回调 stop 方法，与 start 方法顺序相反</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getLifecycleProcessor().onRefresh();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void startBeans(boolean autoStartupOnly) &#123;</span><br><span class="line">	Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">	Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;&gt;();</span><br><span class="line">	lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">		if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">			int phase = getPhase(bean);</span><br><span class="line">			LifecycleGroup group = phases.get(phase);</span><br><span class="line">			if (group == null) &#123;</span><br><span class="line">				group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">				phases.put(phase, group);</span><br><span class="line">			&#125;</span><br><span class="line">			group.add(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	if (!phases.isEmpty()) &#123;</span><br><span class="line">		List&lt;Integer&gt; keys = new ArrayList&lt;&gt;(phases.keySet());</span><br><span class="line">		Collections.sort(keys);</span><br><span class="line">		for (Integer key : keys) &#123;</span><br><span class="line">			phases.get(key).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void doStart(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, String beanName, boolean autoStartupOnly) &#123;</span><br><span class="line">	Lifecycle bean = lifecycleBeans.remove(beanName);</span><br><span class="line">	if (bean != null &amp;&amp; bean != this) &#123;</span><br><span class="line">		String[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);</span><br><span class="line">		// 优先启动所有Lifycycle bean依赖的lifecycle beans</span><br><span class="line">		for (String dependency : dependenciesForBean) &#123;</span><br><span class="line">			doStart(lifecycleBeans, dependency, autoStartupOnly);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!bean.isRunning() &amp;&amp;</span><br><span class="line">				(!autoStartupOnly || !(bean instanceof SmartLifecycle) || ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// 启动lifecycle bean</span><br><span class="line">				bean.start();</span><br><span class="line">			&#125;</span><br><span class="line">			... ...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组播-Spring-容器初始化完成事件"><a href="#组播-Spring-容器初始化完成事件" class="headerlink" title="组播 Spring 容器初始化完成事件"></a>组播 Spring 容器初始化完成事件</h3><p>通过<code>ApplicationEventMulticaster</code>组播<code>ApplicationContext</code>的刷新完成事件<code>ContextRefreshedEvent</code>到注册的<code>ApplicationListener</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">protected void publishEvent(Object event, @Nullable ResolvableType eventType) &#123;</span><br><span class="line">	Assert.notNull(event, &quot;Event must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	ApplicationEvent applicationEvent;</span><br><span class="line">	if (event instanceof ApplicationEvent) &#123;</span><br><span class="line">		applicationEvent = (ApplicationEvent) event;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		applicationEvent = new PayloadApplicationEvent&lt;&gt;(this, event);</span><br><span class="line">		if (eventType == null) &#123;</span><br><span class="line">			eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">	getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>综上，可以总结出 ApplicationContext 具备这些定制和扩展能力：</p>
<ul>
<li>支持 SPEL<ul>
<li>显式注册表达式解析器到 beanFactory</li>
</ul>
</li>
<li>支持自定义 bean 属性编辑器<ul>
<li>通过 bfpp 后置处理时把属性编辑注册器注册到 beanFactory</li>
</ul>
</li>
<li>支持自定义 BeanFactoryPostProcessor<ul>
<li>显式注册或配置方式自定义 bfpp</li>
</ul>
</li>
<li>支持自定义 BeanPostProcessor<ul>
<li>配置方式发现自定义 bpp</li>
</ul>
</li>
<li>支持自定义发布和监听应用事件<ul>
<li>配置方式自定义事件组播器，否则 Spring 容器提供默认的组播器</li>
</ul>
</li>
<li>支持 Spring 容器在启动或停止时刻回调 LifeCycle bean 对应的生命周期方法</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码-aop</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81-aop/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了避免一些公共代码每次都要在 bean 里单独添加，提出了 aop 的解决方案，使用面向切面编程的思想，统一处理 bean 中与业务逻辑无关的公共代码</p>
<h1 id="注册-APC-的-BD"><a href="#注册-APC-的-BD" class="headerlink" title="注册 APC 的 BD"></a>注册 APC 的 BD</h1><h2 id="xml-方式"><a href="#xml-方式" class="headerlink" title="xml 方式"></a>xml 方式</h2><p>xml 方式通过配置<code>&lt;aop:aspectj-autoproxy/&gt;</code>启用 AOP，在 bean 注册里介绍过，这属于 Spring 的自定义标签，命名空间是 aop，标签是 aspectj-autoproxy。Spring 会通过 aop 命名空间 Handler：<code>AopNamespaceHandler</code>，获取 aspectj-autoproxy 标签的解析器<code>AspectJAutoProxyBeanDefinitionParser</code>，执行 parse 方法解析标签，调用方法<code>AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary</code>注册自动代理创建器（APC）的 bd 到 beanFactory</p>
<ul>
<li>这里注册的 APC 是<code>AnnotationAwareAspectJAutoProxyCreator</code><ul>
<li>它是一个 <code>SmartInstantiationAwareBeanPostProcessor</code>，Spring 容器初始化阶段加载并注册到 beanFactory</li>
</ul>
</li>
<li>Spring 定义了三个自动代理 APC，如果还注册了其他的 APC，根据优先级来决定最终注册哪个 APC 的 bd 到 beanFactory。不同的 APC，创建 aop 代理的过程有所差异<ul>
<li>优先级：<code>AnnotationAwareAspectJAutoProxyCreator</code> &gt; <code>AspectJAwareAdvisorAutoProxyCreator</code> &gt; <code>InfrastructureAdvisorAutoProxyCreator</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">	// 主要是注册APC的bd到beanFactory</span><br><span class="line">	AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">	extendBeanDefinition(element, parserContext);</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">		ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line"></span><br><span class="line">	// 注册自动代理创建器APC的bd到beanFactory</span><br><span class="line">	BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">			parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">	// APC的bd增加一些自定义逻辑控制属性，包括是否强制使用CGLIB代理、是否暴露代理类给用户使用</span><br><span class="line">	useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">	registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">		BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">	return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static BeanDefinition registerOrEscalateApcAsRequired(</span><br><span class="line">		Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	// 如果已存在APC（自动代理创建器）的bd，按APC优先级决定最终使用的APC</span><br><span class="line">	if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">		BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">		if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">			int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">			int requiredPriority = findPriorityForClass(cls);</span><br><span class="line">			if (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">				apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);</span><br><span class="line">	beanDefinition.setSource(source);</span><br><span class="line">	beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">	beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">	registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">	return beanDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int findPriorityForClass(@Nullable String className) &#123;</span><br><span class="line">	for (int i = 0; i &lt; APC_PRIORITY_LIST.size(); i++) &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = APC_PRIORITY_LIST.get(i);</span><br><span class="line">		if (clazz.getName().equals(className)) &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = new ArrayList&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">	// Set up the escalation list...</span><br><span class="line">	APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">	APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">	APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>APC 的 bd.pv 增加一些逻辑控制属性</p>
<ul>
<li>是否强制使用 CGLIB 代理<ul>
<li>如果 aspectj-autoproxy 标签的 proxy-target-class 属性为 true，强制使用 CGLIB 为目标对象创建代理</li>
<li>CGLIB 是在运行期依赖 ASM 操作字节码生成目标类的子类来实现代理，能代理除 final 方法（不能被 override）外的所有方法，且性能更好</li>
<li>JDK 动态代理是 Spring 默认使用的动态代理，在运行期创建接口实现类来代理目标类，因此只能代理接口方法</li>
</ul>
</li>
<li>是否支持暴露代理类<ul>
<li>如果 aspectj-autoproxy 标签的 expose-proxy 属性为 true，支持暴露代理类<ul>
<li>目的是解决某些场景下无法代理方法的问题：例如被代理类方法 a 内部又调用了它的另一个方法 b，该方法 b 的调用是无法被代理的，需要显式调用 AopContext.currentProxy 获取代理类来调用方法 b</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) &#123;</span><br><span class="line">	if (sourceElement != null) &#123;</span><br><span class="line">		boolean proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">		if (proxyTargetClass) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">		&#125;</span><br><span class="line">		boolean exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">		if (exposeProxy) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">	if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">		BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">		definition.getPropertyValues().add(&quot;proxyTargetClass&quot;, Boolean.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">	if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">		BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">		definition.getPropertyValues().add(&quot;exposeProxy&quot;, Boolean.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>注解方式开启 aop 需要使用注解：<code>@EnableAspectJAutoProxy</code>。它会 import 一个 bd 注册器：<code>AspectJAutoProxyRegistrar</code>，由它向 bf 注册 apc。和 xml 方式本质一样，都会通过调用方法<code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary</code>来注册 apc。然后读取@EnableAspectJAutoProxy 注解的属性，填充到注册的 apc 的 bd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><br><span class="line">	 * of the @&#123;@link EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span><br><span class="line">	 * &#123;@code @Configuration&#125; class.</span><br><span class="line">	 */</span><br><span class="line">    @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        if (enableAspectJAutoProxy != null) &#123;</span><br><span class="line">            if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="APC-创建-bean-代理类"><a href="#APC-创建-bean-代理类" class="headerlink" title="APC 创建 bean 代理类"></a>APC 创建 bean 代理类</h1><p>通过上面的分析，使用<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>@EnableAspectJAutoProxy</code>启用 AOP，默认使用的 APC 就是<code>AnnotationAwareAspectJAutoProxyCreator</code>，它是一个 bpp：<code>SmartInstantiationAwareBeanPostProcessor</code>，在 bean 加载过程中完成对目标 bean 的代理。<br>其实所有的 APC 都是 bpp：SmartInstantiationAwareBeanPostProcessor，基于 bpp 的回调钩子来为 bean 创建 aop 代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport</span><br><span class="line">		implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面会介绍 APC 在 bean 加载过程中如何为 bean 创建 aop 代理类。在分析源码前，先说一下预备知识：</p>
<ul>
<li>aop 模块的核心 bean 是<code>Advisor</code>增强容器，它包括增强器<code>Advice</code>和切点<code>Pointcut</code>。增强器 Advice 实现具体的增强逻辑，切点 PointCut 用于判断是否与 bean 方法匹配，只有匹配上的 bean 才会被 aop 代理<ul>
<li><code>Advisor</code>其实只包含<code>Advice</code>，它的子类<code>PointcutAdvisor</code>引入了<code>Pointcut</code>，所以增强容器真正指的是<code>PointcutAdvisor</code>，下文不区分<code>Advisor</code>和<code>PointcutAdvisor</code></li>
</ul>
</li>
</ul>
<h2 id="bean-前置实例化处理"><a href="#bean-前置实例化处理" class="headerlink" title="bean 前置实例化处理"></a>bean 前置实例化处理</h2><p>入口：org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessBeforeInstantiation</p>
<p>bean 前置实例化处理主要做了两件事：</p>
<ul>
<li>缓存不需要被代理增强的 bean<ul>
<li>用于做 aop 代理的 bean，包括 Advisor、Advice、Pointcut 的实现类</li>
<li>使用@Aspect 修饰的切面类</li>
</ul>
</li>
<li>加载并筛选所有 advisor bean<ul>
<li>特别的，AnnotationAwareAspectJAutoProxyCreator 会为@Aspect 切面类中每个增强方法创建增强容器 advisor</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">	// 缓存无需增强代理的bean</span><br><span class="line">	this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) &#123;</span><br><span class="line">	boolean retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">			Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">			Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">			AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">	return retVal || hasAspectAnnotation(beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean hasAspectAnnotation(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">	return (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	for (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">		if (advisor instanceof AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">				((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return super.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findCandidateAdvisors 是 aop 的核心方法，它会返回当前 APC 下的所有候选 advisor。<code>AbstractAdvisorAutoProxyCreator</code>里首次定义并给出了基础实现，它会加载所有 Advisor bean</p>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>继承<code>AbstractAdvisorAutoProxyCreator</code>，并重写 findCandidateAdvisors 方法。它在父类的基础上，还会对@Aspect 修饰的切面 bean 的每个增强方法，创建对应的增强容器 Advisor，类型为<code>InstantiationModelAwarePointcutAdvisor</code>，作为候选 advisor。这些 advisor 只会创建一次，然后放到 map 缓存在 APC</p>
<ul>
<li>增强方法是@Around、@Before、@After、@AfterReturning、@AfterThrowing 其中之一的注解修饰的方法，实现具体的增强逻辑</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Advisor&gt; buildAspectJAdvisors() &#123;</span><br><span class="line">	... ...</span><br><span class="line">	// 获取所有beanName</span><br><span class="line">	String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">						this.beanFactory, Object.class, true, false);</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		... ...</span><br><span class="line">		if (this.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">			... ...</span><br><span class="line">			// 把切面中的每个增强方法（@Around、@Before、@After、@AfterReturning、@AfterThrowing之一的注解修饰）封装为一个增强容器advisor（advisor包括pointcut切点类、advice增强类）</span><br><span class="line">			for (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">				... ...</span><br><span class="line">				Advisor advisor = new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">				if (advisor != null) &#123;</span><br><span class="line">					advisors.add(advisor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			... ...</span><br><span class="line">			this.advisorsCache.put(beanName, advisors);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line">	return advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载完候选 advisor bean 后，调用模板方法<code>isEligibleBean</code>，筛选 advisor bean。</p>
<ul>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code>返回 true，不过滤 advisor bean。</li>
<li><code>InfrastructureAdvisorAutoProxyCreator</code>筛选的是 role&#x3D;ROLE_INFRASTRUCTURE 的基础设施 advisor bean</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findCandidateAdvisors() &#123;</span><br><span class="line">	// 从beanFactory加载所有advisor类型增强器bean</span><br><span class="line">	... ...</span><br><span class="line">	advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				this.beanFactory, Advisor.class, true, false);</span><br><span class="line">	... ...</span><br><span class="line">	for (String name : advisorNames) &#123;</span><br><span class="line">		// 不同的APC实现类区分要返回哪些候选advisors，例如InfrastructureAdvisorAutoProxyCreator只会返回role=ROLE_INFRASTRUCTURE的基础设施advisor bean</span><br><span class="line">		if (isEligibleBean(name)) &#123;</span><br><span class="line">			advisors.add(this.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">	return advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bean-后置初始化处理"><a href="#bean-后置初始化处理" class="headerlink" title="bean 后置初始化处理"></a>bean 后置初始化处理</h2><p>入口：org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</p>
<h3 id="跳过无需代理的-bean"><a href="#跳过无需代理的-bean" class="headerlink" title="跳过无需代理的 bean"></a>跳过无需代理的 bean</h3><p>读缓存，如果 bean 无需代理（说明是 aop 组件 bean），直接返回</p>
<ul>
<li>bean 前置实例化处理时，已经将无需代理的 bean 加入缓存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// aop组件bean和@Aspect定义的切面类不需要被代理</span><br><span class="line">if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取与当前-bean-匹配的增强容器-advisor"><a href="#获取与当前-bean-匹配的增强容器-advisor" class="headerlink" title="获取与当前 bean 匹配的增强容器 advisor"></a>获取与当前 bean 匹配的增强容器 advisor</h3><p>调用 getAdvicesAndAdvisorsForBean 方法获取与当前 bean 匹配的 advisor。如果存在，则 bean 需要被代理，否则不用代理。缓存 bean 是否需要代理的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line">if (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">	// bean需要被代理</span><br><span class="line">	this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">	// 创建代理</span><br><span class="line">	Object proxy = createProxy(</span><br><span class="line">			bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">	// 缓存代理类</span><br><span class="line">	this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">	return proxy;</span><br><span class="line">&#125;</span><br><span class="line">// bean无需代理</span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">return bean;</span><br></pre></td></tr></table></figure>

<p>getAdvicesAndAdvisorsForBean 方法内部调用 findEligibleAdvisors 方法查找与 bean 匹配的 advisors，主要逻辑为：</p>
<ul>
<li>findCandidateAdvisors 方法获取所有增强容器 advisor bean，<code>AnnotationAwareAspectJAutoProxyCreator</code>还会解析 Aspect 注解修饰的切面类生成的增强容器 advisor，然后调用模板方法<code>isEligibleBean</code>判断 advisor 是否符合条件，AnnotationAwareAspectJAutoProxyCreator 返回 true，InfrastructureAdvisorAutoProxyCreator 筛选的是 role&#x3D;ROLE_INFRASTRUCTURE 的基础设施 advisor bean。该方法上面重点介绍过</li>
<li>逐个遍历 advisor，筛选与 bean 方法匹配成功的增强容器 advisor<ul>
<li>基于增强容器 advisor 的切点<code>Pointcut</code>的方法匹配器<code>MethodMatcher</code>，逐一匹配 bean 的所有方法，匹配成功则 advisor 可用于代理 bean</li>
</ul>
</li>
<li>如果存在基于 Aspect 切面类生成的增强器 advisor：<code>InstantiationModelAwarePointcutAdvisor</code>，bean 的增强器链表首部添加一个 Spring 自带的增强器<code>DefaultPointcutAdvisor</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">	// 获取所有xml定义的增强容器advisor 和 解析Aspect注解修饰的切面类生成的增强容器advisor</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	// 筛选与bean方法匹配成功的增强容器advisor</span><br><span class="line">	// 基于增强容器advisor的切点pointCut的方法匹配器methodMatcher，逐一匹配bean的所有方法，匹配成功则advisor可用于代理bean</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	// 如果存在基于Aspect切面类生成的增强器advisor：`InstantiationModelAwarePointcutAdvisor`，bean的增强器链表首部添加一个Spring自带的增强器`DefaultPointcutAdvisor`</span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	if (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	return eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">	// 切点匹配任何方法时</span><br><span class="line">	if (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 获取bean的所有方法（包括实现的接口里定义的所有方法）</span><br><span class="line">	 * 基于切点PointCut的方法匹配器methodMatcher，对每个bean实现的方法做匹配，如果匹配上，说明当前增强器可以应用于这个bean</span><br><span class="line">	 */</span><br><span class="line">	... ...</span><br><span class="line">	classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">	for (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">		Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">		for (Method method : methods) &#123;</span><br><span class="line">			if (introductionAwareMethodMatcher != null ?</span><br><span class="line">					introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">					methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Advisor advisor : advisors) &#123;</span><br><span class="line">	if (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">		foundAspectJAdvice = true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">	advisors.add(0, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isAspectJAdvice(Advisor advisor) &#123;</span><br><span class="line">	return (advisor instanceof InstantiationModelAwarePointcutAdvisor ||</span><br><span class="line">		advisor.getAdvice() instanceof AbstractAspectJAdvice ||</span><br><span class="line">		(advisor instanceof PointcutAdvisor &amp;&amp;</span><br><span class="line">		((PointcutAdvisor) advisor).getPointcut() instanceof AspectJExpressionPointcut));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-aop-代理类"><a href="#创建-aop-代理类" class="headerlink" title="创建 aop 代理类"></a>创建 aop 代理类</h3><p>创建 aop 代理，作为 bean 初始化后置处理返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建代理</span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">// 缓存代理类</span><br><span class="line">this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">return proxy;</span><br></pre></td></tr></table></figure>

<p>下面看下创建 aop 代理的具体实现</p>
<p>创建代理工厂，从 apc bean 复制一些控制属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(this);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void copyFrom(ProxyConfig other) &#123;</span><br><span class="line">	Assert.notNull(other, &quot;Other ProxyConfig object must not be null&quot;);</span><br><span class="line">	this.proxyTargetClass = other.proxyTargetClass;</span><br><span class="line">	this.optimize = other.optimize;</span><br><span class="line">	this.exposeProxy = other.exposeProxy;</span><br><span class="line">	this.frozen = other.frozen;</span><br><span class="line">	this.opaque = other.opaque;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 proxyFactory.proxyTargetClass&#x3D;false，动态决定是否设为 true</p>
<ul>
<li>如果被代理 bean 的 bd 的 preserveTargetClass&#x3D;true，则 proxyFactory.proxyTargetClass&#x3D;true</li>
<li>如果被代理的 bean 没有实现用户自定义接口，proxyFactory.proxyTargetClass&#x3D;true。否则，将被代理 bean 实现的所有接口添加到 proxyFactory</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">	// 如果被代理bean的bd的preserveTargetClass=true，则proxyFactory.proxyTargetClass=true</span><br><span class="line">	if (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">		proxyFactory.setProxyTargetClass(true);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 如果被代理的bean没有实现用户自定义接口，proxyFactory.proxyTargetClass=true。否则，将被代理bean实现的所有接口添加到proxyFactory</span><br><span class="line">		evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean shouldProxyTargetClass(ConfigurableListableBeanFactory beanFactory, @Nullable String beanName) &#123;</span><br><span class="line">	if (beanName != null &amp;&amp; beanFactory.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">		BeanDefinition bd = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">		return Boolean.TRUE.equals(bd.getAttribute(PRESERVE_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void evaluateProxyInterfaces(Class&lt;?&gt; beanClass, ProxyFactory proxyFactory) &#123;</span><br><span class="line">	Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader());</span><br><span class="line">	boolean hasReasonableProxyInterface = false;</span><br><span class="line">	for (Class&lt;?&gt; ifc : targetInterfaces) &#123;</span><br><span class="line">		// 如果bean实现了用户自定义的接口，hasReasonableProxyInterface = true</span><br><span class="line">		// isConfigurationCallbackInterface=true说明interface是Spring提供的回调接口</span><br><span class="line">		if (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp; ifc.getMethods().length &gt; 0) &#123;</span><br><span class="line">			hasReasonableProxyInterface = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (hasReasonableProxyInterface) &#123;</span><br><span class="line">		for (Class&lt;?&gt; ifc : targetInterfaces) &#123;</span><br><span class="line">			proxyFactory.addInterface(ifc);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		proxyFactory.setProxyTargetClass(true);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面筛选得到的匹配<code>Advisor</code>添加到 proxyFactory &amp;&amp; 被代理 bean 添加到 proxyFactory</p>
<ul>
<li>如果筛选得到的是<code>MethodInterceptor</code>（Advice 的子接口），将<code>MethodInterceptor</code>包装成<code>DefaultPointcutAdvisor</code><ul>
<li>aop 表征增强逻辑的<code>Advice</code>，在真正执行时都被适配为它的子类<code>MethodInterceptor</code></li>
<li><code>DefaultPointcutAdvisor</code>的<code>Pointcut</code>匹配所有方法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	for (int i = 0; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">		// 如果是MethodInterceptor，包装成DefaultPointcutAdvisor</span><br><span class="line">		advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">	return advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException &#123;</span><br><span class="line">	if (adviceObject instanceof Advisor) &#123;</span><br><span class="line">		return (Advisor) adviceObject;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!(adviceObject instanceof Advice)) &#123;</span><br><span class="line">		throw new UnknownAdviceTypeException(adviceObject);</span><br><span class="line">	&#125;</span><br><span class="line">	Advice advice = (Advice) adviceObject;</span><br><span class="line">	if (advice instanceof MethodInterceptor) &#123;</span><br><span class="line">		// So well-known it doesn&#x27;t even need an adapter.</span><br><span class="line">		return new DefaultPointcutAdvisor(advice);</span><br><span class="line">	&#125;</span><br><span class="line">	for (AdvisorAdapter adapter : this.adapters) &#123;</span><br><span class="line">		// Check that it is supported.</span><br><span class="line">		if (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">			return new DefaultPointcutAdvisor(advice);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	throw new UnknownAdviceTypeException(advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实际的 aop 代理类：JDK 动态代理或 CgLIB 动态代理</p>
<ul>
<li><code>ProxyFactory</code>继承<code>AdvisedSupport</code>，封装了代理上下文（被代理类、增强容器、代理配置属性等），用于控制创建 aop 代理的逻辑</li>
<li>无特殊配置下，如果 bean 实现了用户自定义接口，创建 JDK 动态代理，否则创建 CgLIB 动态代理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">	// 如果被代理bean没实现用户自定义接口 || 被代理bean的bd.preserveTargetClass=true || apc的bd.proxyTargetClass=true</span><br><span class="line">	if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		if (targetClass == null) &#123;</span><br><span class="line">			throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">				&quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		... ...</span><br><span class="line">		return new ObjenesisCglibAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 如果实现了用户自定义接口，创建JDK动态代理</span><br><span class="line">		return new JdkDynamicAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代理类执行方法代理"><a href="#代理类执行方法代理" class="headerlink" title="代理类执行方法代理"></a>代理类执行方法代理</h1><p>这里介绍的是 JDK 动态代理<br>入口：org.springframework.aop.framework.JdkDynamicAopProxy#invoke</p>
<h2 id="获取方法的拦截器-MethodInterceptor-列表"><a href="#获取方法的拦截器-MethodInterceptor-列表" class="headerlink" title="获取方法的拦截器 MethodInterceptor 列表"></a>获取方法的拦截器 MethodInterceptor 列表</h2><p>获取被代理方法的方法拦截器<code>MethodInterceptor</code>列表</p>
<ul>
<li>从 bean 匹配的所有增强容器中，通过切点的<code>MethodMatcher</code>筛选出与当前方法匹配的增强容器<code>Advisor</code></li>
<li>通过适配器模式，使用一个适配器类把增强<code>Advice</code>包装为方法拦截器<code>MethodInterceptor</code><ul>
<li>aop 的表征增强逻辑的<code>Advice</code>，在真正执行时都被适配为它的子类<code>MethodInterceptor</code></li>
</ul>
</li>
<li>缓存被代理方法与拦截器<code>MethodInterceptor</code>列表的映射</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">	if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">		// Add it conditionally.</span><br><span class="line">		PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">		if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">			MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">			// 在原始bean匹配的所有增强器advisor里筛选与当前调用方法匹配的advisor</span><br><span class="line">			// 然后取出advice，适配成MethodInterceptor</span><br><span class="line">			if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">				MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				if (mm.isRuntime()) &#123;</span><br><span class="line">					// Creating a new object instance in the getInterceptors() method</span><br><span class="line">					// isn&#x27;t a problem as we normally cache created chains.</span><br><span class="line">					for (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">						interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123;</span><br><span class="line">	List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3);</span><br><span class="line">	Advice advice = advisor.getAdvice();</span><br><span class="line">	if (advice instanceof MethodInterceptor) &#123;</span><br><span class="line">		interceptors.add((MethodInterceptor) advice);</span><br><span class="line">	&#125;</span><br><span class="line">	// 部分类型的增强advice本身不是拦截器methodInterceptor类型</span><br><span class="line">	// 通过适配器将advice包装为拦截器</span><br><span class="line">	for (AdvisorAdapter adapter : this.adapters) &#123;</span><br><span class="line">		if (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">			interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (interceptors.isEmpty()) &#123;</span><br><span class="line">		throw new UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">	&#125;</span><br><span class="line">	return interceptors.toArray(new MethodInterceptor[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">	MethodCacheKey cacheKey = new MethodCacheKey(method);</span><br><span class="line">	List&lt;Object&gt; cached = this.methodCache.get(cacheKey);</span><br><span class="line">	if (cached == null) &#123;</span><br><span class="line">		// 获取被代理方法的拦截器列表</span><br><span class="line">		cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">				this, method, targetClass);</span><br><span class="line">		// 缓存代理方法与拦截器列表的映射</span><br><span class="line">		this.methodCache.put(cacheKey, cached);</span><br><span class="line">	&#125;</span><br><span class="line">	return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建代理方法上下文"><a href="#创建代理方法上下文" class="headerlink" title="创建代理方法上下文"></a>创建代理方法上下文</h2><p>创建一个代理方法上下文<code>MethodInvocation</code></p>
<ul>
<li>封装执行被代理方法的上下文，包括原始 bean、被代理方法、入参，以及上一步获取的方法拦截器列表（用于执行代理逻辑）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个代理方法调用上下文</span><br><span class="line">MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br></pre></td></tr></table></figure>

<h2 id="执行方法代理"><a href="#执行方法代理" class="headerlink" title="执行方法代理"></a>执行方法代理</h2><p>调用代理方法上下文 MethodInvocation 的 proceed 方法执行方法代理，实际调用：org.springframework.aop.framework.ReflectiveMethodInvocation#proceed。回调拦截器增强方法的过程是通过<code>递归</code>实现的，下面具体分析。</p>
<p>顺序回调方法拦截器列表里每个<code>MethodInterceptor</code>的 invoke 方法，传入代理方法上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">			this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">...</span><br><span class="line">return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br></pre></td></tr></table></figure>

<p>注意，<code>MethodInvocation</code>的 proceed 方法是一个递归调用，<code>MethodInterceptor</code>的实现类会在合适的时机执行增强逻辑以及继续递归调用 MethodInvocation 的 proceed 方法，以此保证了所有方法拦截器的增强逻辑都会被执行到</p>
<ul>
<li>所谓“拦截方法在合适时机执行增强逻辑”，例如前置@Before 增强对应的拦截器<code>MethodBeforeAdviceInterceptor</code>就会在回调代理方法前执行增强逻辑。@After 增强对应的拦截器<code>AspectJAfterAdvice</code>就会先回调代理方法，返回后再执行增强逻辑</li>
</ul>
<p>MethodBeforeAdviceInterceptor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">	this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">	return mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectJAfterAdvice：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		return mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		invokeAdviceMethod(getJoinPointMatch(), null, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有方法拦截器的 invoke 方法都被调用了，则反射调用被代理方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">	return invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，因为<code>MethodInvocation</code>的 proceed 方法是递归调用的，所以会逆序从每个方法拦截器向上 return，回溯过程中可能有些拦截器的增强逻辑才被调用，例如上面介绍的<code>AspectJAfterAdvice</code></p>
<p>前面提到，APC 在初始化后置处理为 bean 创建动态代理的过程中，会寻找与当前 bean 匹配的增强容器 advisor，如果存在来自 Aspect 切面类生成的增强容器，会为 bean 的增强容器链表首部添加一个通配的增强容器<code>DefaultPointcutAdvisor</code>。该 advisor 的增强 advice 是<code>ExposeInvocationInterceptor</code>（interceptor 是 advice 的子接口），它的执行逻辑是将当前代理方法调用上下文 MethodInvocation 写 ThreadLocal，方便在该方法拦截器链上的其他拦截器通过其获取调用上下文，所以要放在拦截器链首部第一个执行</p>
<ul>
<li>@Aspect 切面类，其增强方法的入参是拿不到 MethodInvocation 的。入参是<code>ProceedingJoinPoint</code>、<code>JoinPoint</code>，所以如果要拿到 MethodInvocation 需要调用<code>org.springframework.aop.interceptor.ExposeInvocationInterceptor#currentInvocation</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">// 将当前代理方法调用上下文写ThreadLocal，方便在该方法拦截器链上的其他拦截器获取当前代理方法调用上下文</span><br><span class="line">public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">    MethodInvocation oldInvocation = invocation.get();</span><br><span class="line">    invocation.set(mi);</span><br><span class="line">    try &#123;</span><br><span class="line">        return mi.proceed();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        invocation.set(oldInvocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static MethodInvocation currentInvocation() throws IllegalStateException &#123;</span><br><span class="line">    MethodInvocation mi = (MethodInvocation) invocation.get();</span><br><span class="line">    if (mi == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;No MethodInvocation found: Check that an AOP invocation is in progress, and that the ExposeInvocationInterceptor is upfront in the interceptor chain. Specifically, note that advices with order HIGHEST_PRECEDENCE will execute before ExposeInvocationInterceptor!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建-aop-的几种姿势"><a href="#创建-aop-的几种姿势" class="headerlink" title="创建 aop 的几种姿势"></a>创建 aop 的几种姿势</h1><p>上面说了 aop 是如何注册自己最重要的组件 bean：apc，以及 apc 是如何为 bean 创建 aop 代理类的。接下来介绍我们在自己的应用中如何创建 aop。一般有两种方式</p>
<h2 id="Aspect-方式"><a href="#Aspect-方式" class="headerlink" title="@Aspect 方式"></a>@Aspect 方式</h2><p>如果使用这种 AspectJ 注解方式，通过上面的分析，我们知道需要依赖 APC：AnnotationAwareAspectJAutoProxyCreator，来解析@Aspect 修饰的切面类，动态注册 advisor。因此需要引入这个 apc，xml 通过<code>&lt;aop:aspectj-autoproxy/&gt;</code>，注解方式使用<code>@EnableAspectJAutoProxy</code></p>
<h2 id="注册自定义的-advisor-bean"><a href="#注册自定义的-advisor-bean" class="headerlink" title="注册自定义的 advisor bean"></a>注册自定义的 advisor bean</h2><p>我们也可以自己注册自定义的 advisor bean，当然这也需要 bf 里有 apc 来把这些 advisor bean 搂出来。<br>如果我们依然使用<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>@EnableAspectJAutoProxy</code>来注册 APC：AnnotationAwareAspectJAutoProxyCreator，那么我们的 advisor bean 会被搂出来，因为他不会做任何过滤。<br>如果我们不想使用 AnnotationAwareAspectJAutoProxyCreator，而是 InfrastructureAdvisorAutoProxyCreator，那么可以通过 Import 的方式导入 bd 注册器：<code>AutoProxyRegistrar</code>，且配置类的注解里必须包含参数 mode（值为 AdviceMode.PROXY） 和 proxyTargetClass（Boolean 类型），则 AutoProxyRegistrar 会向 bf 注册 InfrastructureAdvisorAutoProxyCreator。<br>此时我们在配置 advisor bean 时，需要增加注解：<code>@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</code>，来标识我们的 advisor bean 是基础设施 bean，否则不会被搂出来。</p>
<p>advisor 的基类我们一般选择<code>PointcutAdvisor</code>，它包含两部分：advice 和 pointCut</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Advisor &#123;</span><br><span class="line">    Advice getAdvice();</span><br><span class="line"></span><br><span class="line">    boolean isPerInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PointcutAdvisor extends Advisor &#123;</span><br><span class="line">    Pointcut getPointcut();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自定义的 advisor 一般继承<code>AbstractPointcutAdvisor</code>，它实现了 Ordered，我们可以给自定义的 advisor 指定 order 来决定 advisor 在代理方法里执行的先后顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPointcutAdvisor implements PointcutAdvisor, Ordered, Serializable &#123;</span><br><span class="line">    private Integer order;</span><br><span class="line"></span><br><span class="line">    public AbstractPointcutAdvisor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrder(int order) &#123;</span><br><span class="line">        this.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        if (this.order != null) &#123;</span><br><span class="line">            return this.order;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Advice advice = this.getAdvice();</span><br><span class="line">            return advice instanceof Ordered ? ((Ordered)advice).getOrder() : 2147483647;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>先看 PointCut 的定义，可以发现切的规则分为两部分：按类型切和按方法切</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Pointcut &#123;</span><br><span class="line">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">    ClassFilter getClassFilter();</span><br><span class="line"></span><br><span class="line">    MethodMatcher getMethodMatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 提供了一些好用的 PointCut 抽象类我们可以直接继承来用</p>
<h4 id="StaticMethodMatcherPointcut"><a href="#StaticMethodMatcherPointcut" class="headerlink" title="StaticMethodMatcherPointcut"></a>StaticMethodMatcherPointcut</h4><p>如果我们只关心按方法切，类型不 care。可以继承<code>StaticMethodMatcherPointcut</code>，它默认的 ClassFilter 为 true（不过你也可以指定 ClassFilter），即不过滤 class。我们继承并重写 matches 方法来过滤出要切的方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher implements Pointcut &#123;</span><br><span class="line">    private ClassFilter classFilter;</span><br><span class="line"></span><br><span class="line">    public StaticMethodMatcherPointcut() &#123;</span><br><span class="line">        this.classFilter = ClassFilter.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClassFilter(ClassFilter classFilter) &#123;</span><br><span class="line">        this.classFilter = classFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassFilter getClassFilter() &#123;</span><br><span class="line">        return this.classFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final MethodMatcher getMethodMatcher() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NameMatchMethodPointcut"><a href="#NameMatchMethodPointcut" class="headerlink" title="NameMatchMethodPointcut"></a>NameMatchMethodPointcut</h4><p>NameMatchMethodPointcut 是 StaticMethodMatcherPointcut 的子类，它维护一组注册给它的方法名 List，只要方法名在维护的 List 里，就切方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NameMatchMethodPointcut extends StaticMethodMatcherPointcut implements Serializable &#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">        Iterator var3 = this.mappedNames.iterator();</span><br><span class="line"></span><br><span class="line">        String mappedName;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (!var3.hasNext()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mappedName = (String)var3.next();</span><br><span class="line">        &#125; while(!mappedName.equals(method.getName()) &amp;&amp; !this.isMatch(method.getName(), mappedName));</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isMatch(String methodName, String mappedName) &#123;</span><br><span class="line">        return PatternMatchUtils.simpleMatch(mappedName, methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AnnotationMatchingPointcut"><a href="#AnnotationMatchingPointcut" class="headerlink" title="AnnotationMatchingPointcut"></a>AnnotationMatchingPointcut</h4><p>如果我们想要切被特定注解修饰的 class 或 method，可以使用<code>AnnotationMatchingPointcut</code>，通过构造函数指定类上、方法上需要的注解 class 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AnnotationMatchingPointcut implements Pointcut &#123;</span><br><span class="line">    private final ClassFilter classFilter;</span><br><span class="line">    private final MethodMatcher methodMatcher;</span><br><span class="line"></span><br><span class="line">    public AnnotationMatchingPointcut(Class&lt;? extends Annotation&gt; classAnnotationType) &#123;</span><br><span class="line">        this.classFilter = new AnnotationClassFilter(classAnnotationType);</span><br><span class="line">        this.methodMatcher = MethodMatcher.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnnotationMatchingPointcut(Class&lt;? extends Annotation&gt; classAnnotationType, Class&lt;? extends Annotation&gt; methodAnnotationType) &#123;</span><br><span class="line">        Assert.isTrue(classAnnotationType != null || methodAnnotationType != null, &quot;Either Class annotation type or Method annotation type needs to be specified (or both)&quot;);</span><br><span class="line">        if (classAnnotationType != null) &#123;</span><br><span class="line">            this.classFilter = new AnnotationClassFilter(classAnnotationType);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.classFilter = ClassFilter.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (methodAnnotationType != null) &#123;</span><br><span class="line">            this.methodMatcher = new AnnotationMethodMatcher(methodAnnotationType);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.methodMatcher = MethodMatcher.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>Advice 表示代理的增强逻辑，但它是个空接口，我们的 advice 一般都实现<code>MethodInterceptor</code>这个子接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MethodInterceptor extends Interceptor &#123;</span><br><span class="line">    Object invoke(MethodInvocation var1) throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot-方式"><a href="#SpringBoot-方式" class="headerlink" title="SpringBoot 方式"></a>SpringBoot 方式</h2><p>SpringBoot 引入 jar 包：spring-boot-autoconfigure，该 jar 包下定义了很多 SpringBoot 应用需要的配置类，在 Spring 容器初始化过程中，会自动注册配置类：<code>AopAutoConfiguration</code>。这就是 SpringBoot 的 starter 机制，另一篇里有详细介绍。<br>AopAutoConfiguration 会引入注解 EnableAspectJAutoProxy，所以 SpringBoot 应用自带 APC：AnnotationAwareAspectJAutoProxyCreator，因此无论是@Aspect 声明的切面类或者我们自定义的 advisor 都会生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123;EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class&#125;)</span><br><span class="line">@ConditionalOnProperty(</span><br><span class="line">    prefix = &quot;spring.aop&quot;,</span><br><span class="line">    name = &#123;&quot;auto&quot;&#125;,</span><br><span class="line">    havingValue = &quot;true&quot;,</span><br><span class="line">    matchIfMissing = true</span><br><span class="line">)</span><br><span class="line">public class AopAutoConfiguration &#123;</span><br><span class="line">    public AopAutoConfiguration() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @EnableAspectJAutoProxy(</span><br><span class="line">        proxyTargetClass = true</span><br><span class="line">    )</span><br><span class="line">    @ConditionalOnProperty(</span><br><span class="line">        prefix = &quot;spring.aop&quot;,</span><br><span class="line">        name = &#123;&quot;proxy-target-class&quot;&#125;,</span><br><span class="line">        havingValue = &quot;true&quot;,</span><br><span class="line">        matchIfMissing = true</span><br><span class="line">    )</span><br><span class="line">    public static class CglibAutoProxyConfiguration &#123;</span><br><span class="line">        public CglibAutoProxyConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @EnableAspectJAutoProxy(</span><br><span class="line">        proxyTargetClass = false</span><br><span class="line">    )</span><br><span class="line">    @ConditionalOnProperty(</span><br><span class="line">        prefix = &quot;spring.aop&quot;,</span><br><span class="line">        name = &#123;&quot;proxy-target-class&quot;&#125;,</span><br><span class="line">        havingValue = &quot;false&quot;,</span><br><span class="line">        matchIfMissing = false</span><br><span class="line">    )</span><br><span class="line">    public static class JdkDynamicAutoProxyConfiguration &#123;</span><br><span class="line">        public JdkDynamicAutoProxyConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码-bean加载</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81-bean%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓 bean 加载，即创建 bean 实例，由 bean 工厂实现，包括 bean 实例化、依赖注入和初始化过程</p>
<p>入口：org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</p>
<p>bean 加载有如下几个关键点需要注意。</p>
<h2 id="关于-bean-作用域"><a href="#关于-bean-作用域" class="headerlink" title="关于 bean 作用域"></a>关于 bean 作用域</h2><ul>
<li>常见的 bean 作用域有单例 singleton 和原型 prototype，单例 bean 需要保证全局唯一，原型 bean 每次加载都生成新的实例</li>
<li>单例 bean 全局唯一性使用 bean 工厂的 HashMap 缓存保证</li>
</ul>
<h2 id="关于循环依赖"><a href="#关于循环依赖" class="headerlink" title="关于循环依赖"></a>关于循环依赖</h2><p>Spring 解决循环依赖使用 <code>EarlyReference</code> 机制，能利用该机制的就允许存在循环依赖，否则不允许，bean 加载阶段抛异常</p>
<ul>
<li>对于单例 bean，Spring 支持 setter 依赖注入产生的循环依赖，不支持构造器注入产生的循环依赖，在 bpp 钩子函数里被代理的 bean 也不支持循环依赖<ul>
<li>Spring 解决单例 bean 的 setter 注入循环依赖使用<code>earlyReference</code>（实例化完成但还未初始化的 bean）机制，通过 earlySingletonObjectsMap 提前暴露 bean 的 earlyReference，依赖它的 beans 注入的是 earlyReference</li>
<li>对于构造器注入产生的循环依赖，bean 实例化的前提就是循环依赖的 beans 也加载完成。所以加载依赖 beans 不能用到 earlyReference 机制，造成递归加载 bean 直到堆栈溢出，所以 Spring 不支持构造器注入的循环依赖。Spring 通过将加载中的 beanName 加入 <code>singletonsCurrentlyInCreationSet</code> 来检测是否存在这种场景的循环依赖，一旦 bean 未实例化完成（拿不到 earlyReference）又需要再次加载，就抛异常</li>
<li>如果当 bean 在实例化完成后又在 bpps 的一些钩子函数里被代理，则依赖它的 beans 无法注入真正的 bean 实例。因此 Spring 不支持在 bpp 钩子函数里被代理的 bean 存在循环依赖，一旦发现会抛异常</li>
</ul>
</li>
<li>原型 bean 不支持循环依赖<ul>
<li>如果存在循环依赖，bean 加载就会一直递归下去直到堆栈溢出，所以<code>Spring不支持原型bean循环依赖</code></li>
</ul>
</li>
<li>depends-on 指定的前置依赖 bean，不能存在循环依赖，否则也会出现递归加载 bean 的情况，因为这时 bean 还未实例化，无法利用 earlyReference 机制</li>
</ul>
<h2 id="bean-加载过程中回调的一些-bpp-钩子函数（按调用顺序排序）"><a href="#bean-加载过程中回调的一些-bpp-钩子函数（按调用顺序排序）" class="headerlink" title="bean 加载过程中回调的一些 bpp 钩子函数（按调用顺序排序）"></a>bean 加载过程中回调的一些 bpp 钩子函数（按调用顺序排序）</h2><ul>
<li>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation<ul>
<li>bean 前置实例化处理，用于代替 Spring 直接加载 bean，返回被代理的 bean</li>
</ul>
</li>
<li>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition<ul>
<li>修改 rootBeanDefinition，bean 实例化完成后执行</li>
</ul>
</li>
<li>SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference<ul>
<li>指定单例 bean 暴露的 earlyReference，否则就是 bean 实例自身。bean 实例化完成后执行</li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation<ul>
<li>bean 后置实例化处理，可用于填充 bean 属性，返回 false 则跳过 Spring 依赖注入和其他 bpp 的填充属性阶段</li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor#postProcessPropertyValues<ul>
<li>修改存储在 beanDefinition 的 property 标签声明的属性，pvs 里的属性值 set 给 bean 前执行</li>
<li><code>AutowiredAnnotationBeanPostProcessor</code>是一个<code>InstantiationAwareBeanPostProcessor</code>，postProcessPropertyValues 方法里实现@Autowired 和@Value 的依赖注入</li>
</ul>
</li>
<li>BeanPostProcessor#postProcessBeforeInitialization<ul>
<li>bean 前置初始化处理，可以返回代理 bean</li>
</ul>
</li>
<li>BeanPostProcessor#postProcessAfterInitialization<ul>
<li>bean 后置初始化处理，可以返回代理 bean</li>
</ul>
</li>
</ul>
<h1 id="bean-加载"><a href="#bean-加载" class="headerlink" title="bean 加载"></a>bean 加载</h1><h2 id="加载前"><a href="#加载前" class="headerlink" title="加载前"></a>加载前</h2><h3 id="尝试从单例缓存获取"><a href="#尝试从单例缓存获取" class="headerlink" title="尝试从单例缓存获取"></a>尝试从单例缓存获取</h3><p>从单例缓存或 earlyReference 缓存获取单例 bean</p>
<ul>
<li>优先取单例（一级）缓存，如果单例 bean 加载完成这里就直接取出来用，保障单例全局唯一</li>
<li>如果单例缓存没有，从二级缓存拿 earlyReference，拿到了也直接用，作为依赖注入，解决循环依赖问题</li>
<li>如果二级缓存也没有，从三级缓存拿到 earlyReference 的工厂类，调用工厂方法得到 earlyReference，再放到二级缓存<ul>
<li>三级缓存如果也没有，说明 bean 还没被实例化，因此无法从缓存直接获取</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">	// 检查缓存中是否存在实例</span><br><span class="line">	Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">	// 缓存中不存在且单例在创建中，说明单例存在循环依赖</span><br><span class="line">	if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">			if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">				if (singletonFactory != null) &#123;</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					// 解决单例模式下的循环依赖，还在实例化过程中的单例，先放到earlySingletonObjects缓存</span><br><span class="line">					this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					this.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>如果从缓存拿到 bean，会接着调用 <code>getObjectForBeanInstance</code> 拿到真正的 bean，这里主要是为了 FactoryBean 服务。如果三级缓存拿到的 bean 不是 FactoryBean 类型，就直接返回了</p>
<p>先说 FactoryBean 的加载流程。applicationContext 初始化阶段加载单例 bean 时，会从 bd 拿到 beanClass 判断类型，如果是 FactoryBean，getBean 传入的 beanName 前面要加上“&amp;”，以保证确实想要加载 FactoryBean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isFactoryBean(beanName)) &#123;</span><br><span class="line">	Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">	if (bean instanceof FactoryBean) &#123;</span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">		boolean isEagerInit;</span><br><span class="line">		if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">			isEagerInit = AccessController.doPrivileged(</span><br><span class="line">					(PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">					getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">					((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">		&#125;</span><br><span class="line">		if (isEagerInit) &#123;</span><br><span class="line">			getBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	getBean(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FactoryBean 的加载流程其实和普通 bean 没区别，也要经历实例化-三级缓存-依赖注入-初始化这几个阶段，以及不同阶段的 bpp 钩子回调。getBean 传入的&amp;，在 bean 加载阶段会干掉<br>加载完得到 FactoryBean 实例，返回前还要调用 getObjectForBeanInstance 方法，它的逻辑是这样：</p>
<ul>
<li>如果不是 FactoryBean 类型就返回了</li>
<li>如果是<ul>
<li>传入的 beanName 以“&amp;”开头，也直接返回 FactoryBean 实例</li>
<li>不以“&amp;”开头，调用 getObject 方法拿到 realBean 并缓存在 bf 的 factoryBeanObjectCache</li>
</ul>
</li>
</ul>
<p>所以，applicationContext 在 getBean 时传入了“&amp;”，确保返回的就是 FactoryBean 实例。这时和 realBean 一点关系都没有。不过如果 FactoryBean 是 SmartFactoryBean，且 eagerInit 方法返回 true，会调用 getBean 方法传入 FactoryBean 的 beanName，注意此时没有“&amp;”。先从三级缓存先拿到 FactoryBean 实例，然后调用 getObjectForBeanInstance 方法，根据上面的逻辑，会调用 getObject 方法得到 realBean，然后执行 bpp 的 postProcessAfterInitialization 后置初始化回调，最后缓存在 factoryBeanObjectCache，key&#x3D;FactoryBean 的 beanName，value 为 realBean 实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">	// 缓存不存在，调用工厂方法获取bean实例</span><br><span class="line">	object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">	// Only post-process and store if not put there already during getObject() call above</span><br><span class="line">	// (e.g. because of circular reference processing triggered by custom getBean calls)</span><br><span class="line">	Object alreadyThere = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">	if (alreadyThere != null) &#123;</span><br><span class="line">		object = alreadyThere;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (shouldPostProcess) &#123;</span><br><span class="line">			if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				// Temporarily return non-post-processed object, not storing it yet..</span><br><span class="line">				return object;</span><br><span class="line">			&#125;</span><br><span class="line">			beforeSingletonCreation(beanName);</span><br><span class="line">			try &#123;</span><br><span class="line">				// 尽可能保证所有bean初始化后都调用注册的BeanPostProcessor的postProcessAfterInitialization方法进行处理</span><br><span class="line">				object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;</span><br><span class="line">				throw new BeanCreationException(beanName,</span><br><span class="line">						&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">				afterSingletonCreation(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (containsSingleton(beanName)) &#123;</span><br><span class="line">			this.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里你会发现，FactoryBean 和普通 bean 的加载流程并无差异。只是如果你想通过 getBean 拿到 FactoryBean 实例，需要加“&amp;”，否则拿到的是 realBean。<br>realBean 和普通的 bean 完全不同，不会放在三级缓存里，且只有通过 getBean 方法传入 factoryBean 的 beanName 才能拿到，首次获取调用 getObject 并缓存在 bf 的 factoryBeanObjectCache</p>
<p>当我们将 realBean 按 byType 注入到其他 bean，在依赖注入阶段，Spring 会根据 realBean 的类型到 BeanDefinition 里匹配类型，如果是 FactoryBean 类型，匹配的是 getObject 返回的 realBean 类型。所以最后会匹配上 FacotoryBean，然后调用 getBean 方法传入 FactoryBean 的 beanName，这时拿到的就是 realBean 并注入</p>
<ul>
<li>测试代码：instantiation.before.factorybean.FactoryBeanTest#factoryBeanTest</li>
</ul>
<h3 id="循环依赖异常检测"><a href="#循环依赖异常检测" class="headerlink" title="循环依赖异常检测"></a>循环依赖异常检测</h3><h4 id="原型-bean-循环依赖检测"><a href="#原型-bean-循环依赖检测" class="headerlink" title="原型 bean 循环依赖检测"></a>原型 bean 循环依赖检测</h4><p>如果是原型 bean，加载过程中发生重复加载，说明存在循环依赖，这会导致堆栈溢出，因此需要直接抛异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">	throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="depends-on-循环依赖检测"><a href="#depends-on-循环依赖检测" class="headerlink" title="depends-on 循环依赖检测"></a>depends-on 循环依赖检测</h4><p>检测和 depends-on 前置依赖 bean 是否存在循环依赖</p>
<ul>
<li>存在循环依赖抛异常。因为 bean 还没被实例化，不能依赖 earlyReference 机制来解决循环依赖问题，先加载前置依赖的 bean 又会回过头来加载自己，导致无限递归堆栈溢出</li>
<li>不存在则先加载前置依赖 bean</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">if (dependsOn != null) &#123;</span><br><span class="line">	for (String dep : dependsOn) &#123;</span><br><span class="line">		// 前置依赖的bean也依赖自己，产生循环依赖</span><br><span class="line">		if (isDependent(beanName, dep)) &#123;</span><br><span class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// 建立产生依赖的bean和被依赖的bean之间的关联关系，维护在bean工厂</span><br><span class="line">		registerDependentBean(dep, beanName);</span><br><span class="line">		try &#123;</span><br><span class="line">			// 加载前置依赖的bean</span><br><span class="line">			getBean(dep);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					&quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单例-bean-循环依赖检测"><a href="#单例-bean-循环依赖检测" class="headerlink" title="单例 bean 循环依赖检测"></a>单例 bean 循环依赖检测</h4><p>spring 解决循环依赖是通过三级缓存和 earlyReference 机制，如果三级缓存拿不到 bean，且<code>singletonsCurrentlyInCreation</code>中包含该 beanName（说明 bean 正在加载中），证明 bean 存在无法通过 earlyReference 解决的循环依赖，直接抛异常，否则会导致递归加载 bean 直到堆栈溢出</p>
<ul>
<li>这种情况一般是构造器依赖产生的循环依赖，此时 bean 还没实例化，自然不在 earlyReference 缓存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line">    throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bean-实例化"><a href="#bean-实例化" class="headerlink" title="bean 实例化"></a>bean 实例化</h2><p>Spring 实例化 bean 分为三种情况</p>
<ul>
<li>bpp 实例化前置处理直接实例化 bean</li>
<li>使用指定的 factory-method 方法反射实例化</li>
<li>使用构造函数反射实例化</li>
</ul>
<h3 id="bean-实例化前置处理"><a href="#bean-实例化前置处理" class="headerlink" title="bean 实例化前置处理"></a>bean 实例化前置处理</h3><p>如果存在<code>InstantiationAwareBeanPostProcessor</code>，回调 postProcessBeforeInstantiation 方法执行实例化前置处理，直接获取 bean 实例，如果不为空，再调用 bpp 后置初始化处理，最后放入单例缓存，不参与其他的加载流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">	Object bean = null;</span><br><span class="line">	if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">		// Make sure bean class is actually resolved at this point.</span><br><span class="line">		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">			if (targetType != null) &#123;</span><br><span class="line">				// bean实例化前置处理</span><br><span class="line">				bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">				if (bean != null) &#123;</span><br><span class="line">					// 如果bean实例化前置处理返回了bean实例，则调用bean初始化后置处理器</span><br><span class="line">					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 标记bean是否在实例化前置处理中生成</span><br><span class="line">		mbd.beforeInstantiationResolved = (bean != null);</span><br><span class="line">	&#125;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>determineTargetType 方法会确保拿到正确的 bean 类型，对于普通 bean，类型就是他自己，但如果是 factory-method 方式配置的 bean，类型是 factory-method 方法的返回类型</p>
<h3 id="实例化-factory-method-方式配置的-bean"><a href="#实例化-factory-method-方式配置的-bean" class="headerlink" title="实例化 factory-method 方式配置的 bean"></a>实例化 factory-method 方式配置的 bean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">	return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>factory-method 方式的 bean 配置分为两种</p>
<ul>
<li>xml 配置方式显式指定工厂类和工厂方法<ul>
<li>bd.beanClass&#x3D;工厂类 class，bd.factoryMethodName&#x3D;配置指定的方法名，bd.factoryBeanName&#x3D;null</li>
<li>从 bd.beanClass 拿到工厂类，反射获取与 factoryMethodName 匹配的方法，然后反射调用该方法得到 bean 实例</li>
<li>注意，这种方式工厂类不会作为 bean</li>
</ul>
</li>
<li>@Bean 注解方式<ul>
<li>bd.factoryBeanName&#x3D;工厂类，bd.factoryMethodName&#x3D;@Bean 修饰的方法名，bd.beanClass&#x3D;null</li>
<li>拿到 factoryBeanName 加载工厂 bean，拿到工厂 bean 的 class，反射获取与 factoryMethodName 匹配的方法，然后反射调用该方法得到 bean 实例</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String factoryBeanName = mbd.getFactoryBeanName();</span><br><span class="line">if (factoryBeanName != null) &#123;</span><br><span class="line">	if (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,</span><br><span class="line">				&quot;factory-bean reference points back to the same bean definition&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	factoryBean = this.beanFactory.getBean(factoryBeanName);</span><br><span class="line">	if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">		throw new ImplicitlyAppearedSingletonException();</span><br><span class="line">	&#125;</span><br><span class="line">	factoryClass = factoryBean.getClass();</span><br><span class="line">	isStatic = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	// It&#x27;s a static factory method on the bean class.</span><br><span class="line">	if (!mbd.hasBeanClass()) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,</span><br><span class="line">				&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	factoryBean = null;</span><br><span class="line">	// xml的factory-method配置方式，从beanClass里反射生成factory，调用工厂方法得到bean实例</span><br><span class="line">	factoryClass = mbd.getBeanClass();</span><br><span class="line">	isStatic = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：instantiation.ing.factorymethod.FactoryMethodTest</p>
<h3 id="调用构造函数实例化-bean"><a href="#调用构造函数实例化-bean" class="headerlink" title="调用构造函数实例化 bean"></a>调用构造函数实例化 bean</h3><p>如果 bean 没有指定 factory-method，则反射调用构造函数实例化 bean。选取构造函数有如下逻辑：</p>
<p>满足以下任意条件，使用有参构造函数实例化（构造函数的匹配规则没细看）</p>
<ul>
<li>xml 配置了构造参数</li>
<li>加载 bean 时传入了构造参数</li>
<li><code>SmartInstantiationAwareBeanPostProcessor</code>指定了候选构造函数集</li>
<li>xml 配置的 autowireMode&#x3D;AUTOWIRE_CONSTRUCTOR</li>
</ul>
<p>注意，有参构造函数实例化前，会先加载依赖 bean，以及解析 SPEL 表达式的值</p>
<p>否则使用无参构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">		mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">	return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line">return instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure>

<h3 id="BeanWrapper-包装-bean-实例"><a href="#BeanWrapper-包装-bean-实例" class="headerlink" title="BeanWrapper 包装 bean 实例"></a>BeanWrapper 包装 bean 实例</h3><p>实例化后的 Bean 使用<code>BeanWrapper</code>包装，作用是支持编辑 bean 实例的 property 属性。<br>Spring 在创建 beanWrapper 后调用 registerCustomEditors 方法，内部回调 beanFactory 里注入的所有<code>PropertyEditorRegistrar</code>属性编辑注册器，将用户自定义的<code>PropertyEditor</code>属性编辑器注册到 beanWrapper。</p>
<ul>
<li><code>BeanWrapper</code>本身是一个<code>PropertyEditorRegistry</code>属性编辑器注册中心</li>
<li>beanFactory 可以持有多个<code>PropertyEditorRegistrar</code>注册器，每个 registrar 在注册方法里可以注册多个<code>PropertyEditor</code>给 BeanWrapper</li>
<li><code>PropertyEditor</code>可以编辑 xml 配置里 property 标签指定的 bean 属性字面量，或者将字面量转换为 bean 的实际属性类型</li>
<li>测试代码：populatebean.propertyeditor.PropertyEditorTest</li>
</ul>
<p>PropertyEditorRegistrar 是通过 bfpp 机制注入到 beanFactory 的。我们可以注册一个 bfpp：<code>CustomEditorConfigurer</code>，将 PropertyEditorRegistrar 注入给这个 bfpp，由它再后置处理 beanFactory 时注入到 beanFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class="line">registerCustomEditors(bw);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void registerCustomEditors(PropertyEditorRegistry registry) &#123;</span><br><span class="line">	PropertyEditorRegistrySupport registrySupport =</span><br><span class="line">			(registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);</span><br><span class="line">	if (registrySupport != null) &#123;</span><br><span class="line">		registrySupport.useConfigValueEditors();</span><br><span class="line">	&#125;</span><br><span class="line">	if (!this.propertyEditorRegistrars.isEmpty()) &#123;</span><br><span class="line">		for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// 调用beanFactory的注册器propertyEditorRegistrars，注册PropertyEditor到BeanWrapper</span><br><span class="line">				registrar.registerCustomEditors(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeanCreationException ex) &#123;</span><br><span class="line">				...</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!this.customEditors.isEmpty()) &#123;</span><br><span class="line">		this.customEditors.forEach((requiredType, editorClass) -&gt;</span><br><span class="line">				registry.registerCustomEditor(requiredType, BeanUtils.instantiateClass(editorClass)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bpp-处理-BD"><a href="#bpp-处理-BD" class="headerlink" title="bpp 处理 BD"></a>bpp 处理 BD</h3><p>回调<code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</code>处理 beanDefinition</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) &#123;</span><br><span class="line">	for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">		if (bp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">			bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴露-earlyReference"><a href="#暴露-earlyReference" class="headerlink" title="暴露 earlyReference"></a>暴露 earlyReference</h3><p>提前暴露一个可获取单例 earlyReference 的工厂，放入三级缓存（singletonFactories），循环依赖时回调工厂方法拿到 earlyReference，放入二级缓存（earlySingletonObjects）</p>
<ul>
<li>一级缓存是 singletonObjects</li>
<li>earlyReference 的工厂方法里回调 bpp 的方法<code>SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference</code>，允许定制 earlyReference</li>
<li>通过二级缓存能判断 bean 是否存在循环依赖。这也是为什么不直接缓存 earlyReference 的原因</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">	// 工厂方法生成earlyReference，如果有SmartInstantiationAwareBeanPostProcessor，回调bpp得到earlyReference</span><br><span class="line">	// 这就是为啥用工厂来返回earlyReference而不是直接把bean放到earlySingleton缓存的原因</span><br><span class="line">	addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;</span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">		for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">	Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);</span><br><span class="line">	synchronized (this.singletonObjects) &#123;</span><br><span class="line">		if (!this.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">			this.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">			this.earlySingletonObjects.remove(beanName);</span><br><span class="line">			this.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bpp-后置实例化处理"><a href="#bpp-后置实例化处理" class="headerlink" title="bpp 后置实例化处理"></a>bpp 后置实例化处理</h3><p>回调<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</code>方法执行 bean 实例化后置处理，允许在 Spring 依赖注入前为 bean 属性赋值。返回 false 会跳过回调其他 bpp 实例化后置处理方法，也会跳过 bean 依赖注入阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">	for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">		if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">			InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">			if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="按-autowireMode-加载依赖-bean"><a href="#按-autowireMode-加载依赖-bean" class="headerlink" title="按 autowireMode 加载依赖 bean"></a>按 autowireMode 加载依赖 bean</h3><p>根据 xml 里 bean 配置的<code>autowiredMode</code>，byType 或 byName 加载不在 property 标签声明的 bean，存储在一个汇总的 propertyValueMap 里。最后的注入就是基于这个汇总的 pvMap，之所以这么做，是不想让非 property 标签描述的属性存储到 bd.pv 中。即，bd 应该是对 bean 配置的最纯粹的描述。</p>
<ul>
<li>如果不给 bean 配置 autowiredMode，不在 property 标签声明的属性不会做依赖注入</li>
<li>byType 注入时，会筛选出所有类型匹配或是类型的子类或实现这个接口类型的 beans。如果超过一个候选 bean，选择<code>@Primary</code>注解修饰的 bean，否则抛出 NoUniqueBeanDefinitionException 异常</li>
<li>property 标签中声明的 bean，以<code>RuntimeBeanReference</code>类型存储在 beanDefinition.propertyValues 中，在属性赋值前也会加载 bean</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);</span><br><span class="line"></span><br><span class="line">int resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">	MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line">	// Add property values based on autowire by name if applicable.</span><br><span class="line">	if (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">		autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">	&#125;</span><br><span class="line">	// Add property values based on autowire by type if applicable.</span><br><span class="line">	if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">		autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">	&#125;</span><br><span class="line">	pvs = newPvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void autowireByName(</span><br><span class="line">	String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">	// 返回没有用&lt;property&gt;声明的引用类型属性名</span><br><span class="line">	String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">	for (String propertyName : propertyNames) &#123;</span><br><span class="line">		// beanFactory是否包含bean定义或者bean已经加载并缓存在beanFactory</span><br><span class="line">		if (containsBean(propertyName)) &#123;</span><br><span class="line">			Object bean = getBean(propertyName);</span><br><span class="line">			pvs.add(propertyName, bean);</span><br><span class="line">			registerDependentBean(propertyName, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void autowireByType(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">	Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">	if (autowiredArgument != null) &#123;</span><br><span class="line">		// 依赖的bean实例添加到属性</span><br><span class="line">		pvs.add(propertyName, autowiredArgument);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,</span><br><span class="line">	@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	// 按类型查找与之匹配的bean，如果依赖的bean已经加载完成，从BeanFactory里获取bean实例，否则只加载依赖的beanClass</span><br><span class="line">	Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	// 如果按类型查找到超过一个可注入的bean，@Primary修饰的bean优先作为候选</span><br><span class="line">	// 不存在@Primary修饰的bean，则抛异常NoUniqueBeanDefinitionException</span><br><span class="line">	if (matchingBeans.size() &gt; 1) &#123;</span><br><span class="line">		autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">		if (autowiredBeanName == null) &#123;</span><br><span class="line">			if (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">				return descriptor.resolveNotUnique(type, matchingBeans);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// In case of an optional Collection/Map, silently ignore a non-unique case:</span><br><span class="line">				// possibly it was meant to be an empty collection of multiple regular beans</span><br><span class="line">				// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	// 说明依赖的bean还未加载完成，调用BeanFactory.getBean加载bean</span><br><span class="line">	// 循环依赖时，返回的是earlyBean</span><br><span class="line">	if (instanceCandidate instanceof Class) &#123;</span><br><span class="line">		instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);</span><br><span class="line">	&#125;</span><br><span class="line">	Object result = instanceCandidate;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解驱动的依赖注入"><a href="#注解驱动的依赖注入" class="headerlink" title="注解驱动的依赖注入"></a>注解驱动的依赖注入</h3><p>回调<code>InstantiationAwareBeanPostProcessor.postProcessPropertyValues</code>方法</p>
<ul>
<li>如果存在<code>AutowiredAnnotationBeanPostProcessor</code>，回调该 bpp，注入@Autowired 修饰的依赖 bean、注入@Value 修饰的实际值<ul>
<li>只有基于注解驱动的 Spring 容器，例如<code>AnnotationConfigApplicationContext</code>，才会在容器的初始化阶段将 AutowiredAnnotationBeanPostProcessor 的 BD 注册到 beanFactory，然后在容器的 refresh 阶段加载注册的 bpp，注入到 beanFactory。因此如果是 xml 驱动的 Spring 容器，不能支持@Autowired、@Value 方式的依赖注入</li>
<li>@Value 如果用占位符，使用<code>bf.embeddedValueResolvers</code>解析得到实际值，如果用 spel 表达式，使用<code>bd.beanExpressionResolver</code>解析得到实际值。Spring 容器会给 bf 添加这两个 resolver 的默认实现。如果解析占位符，有优先级，默认是 JVM 参数-环境变量-系统配置文件</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (hasInstAwareBpps) &#123;</span><br><span class="line">	for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">		if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">			InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">			// 回调`InstantiationAwareBeanPostProcessor.postProcessPropertyValues`方法修改beanDefinition.propertyValues</span><br><span class="line">			// 回调`AutowiredAnnotationBeanPostProcessor`，注入@Autowired的依赖、注入计算后的@Value表达式（SPEL、环境变量占位符）的值</span><br><span class="line">			pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">			if (pvs == null) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PropertyValues postProcessPropertyValues(</span><br><span class="line">	PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	// 寻找使用@Value注解或者@Autowired注解的属性</span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">	try &#123;</span><br><span class="line">		// 解析使用@Value注解或者@Autowired注解的属性值，并赋值给bean</span><br><span class="line">		metadata.inject(bean, beanName, pvs);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanCreationException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, @Nullable PropertyValues pvs) &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">		// 寻找使用@Value注解或者@Autowired注解的属性</span><br><span class="line">		AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">		if (ann != null) &#123;</span><br><span class="line">			if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Autowired annotation is not supported on static fields: &quot; + field);</span><br><span class="line">				&#125;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			boolean required = determineRequiredStatus(ann);</span><br><span class="line">			currElements.add(new AutowiredFieldElement(field, required));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">	if (ao.getAnnotations().length &gt; 0) &#123;  // autowiring annotations have to be local</span><br><span class="line">		for (Class&lt;? extends Annotation&gt; type : this.autowiredAnnotationTypes) &#123;</span><br><span class="line">			AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type);</span><br><span class="line">			if (attributes != null) &#123;</span><br><span class="line">				return attributes;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public AutowiredAnnotationBeanPostProcessor() &#123;</span><br><span class="line">	this.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">	this.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析-bd-pv-中的-value"><a href="#解析-bd-pv-中的-value" class="headerlink" title="解析 bd.pv 中的 value"></a>解析 bd.pv 中的 value</h3><p>经过上面这些步骤，注解驱动的依赖都已经注入了，还没注入的都存储在汇总的 propertyValueMap 中（包括 bd.pv，即<property>标签配置的依赖）。在注入给 bean 之前，还要对 map 里的 value 做最后解析</p>
<ul>
<li>1、如果 value 使用了 SPEL 表达式，计算得到结果<ul>
<li>使用注册到 beanFactory 的<code>BeanExpressionResolver</code>（ApplicationContext 在 refresh 初始化阶段会注册<code>StandardBeanExpressionResolver</code>）解析 SPEL 表达式</li>
</ul>
</li>
<li>2、byName 加载 property 标签中声明的依赖 bean</li>
<li>3、使用与 bean 属性类型匹配的 BeanWrapper.PropertyEditor 对 property 标签的属性字面量编辑或转换为 bean 的实际属性类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object resolveValueIfNecessary(Object argName, @Nullable Object value) &#123;</span><br><span class="line">	// bean的依赖引用类型在beanDefinition.propertyValues里的属性类型是RuntimeBeanReference</span><br><span class="line">	if (value instanceof RuntimeBeanReference) &#123;</span><br><span class="line">		RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">		// 如果依赖的属性是引用bean，byName从beanFactory获取bean</span><br><span class="line">		return resolveReference(argName, ref);</span><br><span class="line">	&#125;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	else if (value instanceof TypedStringValue) &#123;</span><br><span class="line">		TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">		// 使用beanExpressionResolver解析xml配置的表达式字面量</span><br><span class="line">		// ApplicationContext给beanFactory注册的beanExpressionResolver是StandardBeanExpressionResolver，它内部使用SpelParser解析spel表达式</span><br><span class="line">		Object valueObject = evaluate(typedStringValue);</span><br><span class="line">		return valueObject;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,</span><br><span class="line">	@Nullable Class&lt;T&gt; requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException &#123;</span><br><span class="line">	// Custom editor for this type?</span><br><span class="line">	// 寻找该类型的自定义属性编辑器</span><br><span class="line">	PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	if (editor != null &amp;&amp; !(convertedValue instanceof String)) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			editor.setValue(convertedValue);</span><br><span class="line">    		Object newConvertedValue = editor.getValue();</span><br><span class="line">			if (newConvertedValue != convertedValue) &#123;</span><br><span class="line">				convertedValue = newConvertedValue;</span><br><span class="line">				editor = null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (convertedValue instanceof String) &#123;</span><br><span class="line">		if (editor != null) &#123;</span><br><span class="line">			String newTextValue = (String) convertedValue;</span><br><span class="line">			return doConvertTextValue(oldValue, newTextValue, editor);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (String.class == requiredType) &#123;</span><br><span class="line">			returnValue = convertedValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		editor.setValue(oldValue);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;&#125;</span><br><span class="line">	editor.setAsText(newTextValue);</span><br><span class="line">	return editor.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行注入"><a href="#执行注入" class="headerlink" title="执行注入"></a>执行注入</h3><p>最后基于 汇总的 propertyValueMap，填充 bean 属性值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 基于bd.pv，填充bean属性值</span><br><span class="line">bw.setPropertyValues(new MutablePropertyValues(deepCopy));</span><br></pre></td></tr></table></figure>

<h2 id="bean-初始化"><a href="#bean-初始化" class="headerlink" title="bean 初始化"></a>bean 初始化</h2><h3 id="自省注入"><a href="#自省注入" class="headerlink" title="自省注入"></a>自省注入</h3><p>bean 如果是自省的，回调 bean 的自省方法注入 Spring 组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void invokeAwareMethods(String beanName, Object bean) &#123;</span><br><span class="line">	if (bean instanceof Aware) &#123;</span><br><span class="line">		if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">			((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">			ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">			if (bcl != null) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bpp-初始化前置处理"><a href="#bpp-初始化前置处理" class="headerlink" title="bpp 初始化前置处理"></a>bpp 初始化前置处理</h3><p>回调<code>BeanPostProcessor.postProcessBeforeInitialization</code>执行 bean 初始化前置处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">	throws BeansException &#123;</span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		if (current == null) &#123;</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调-afterPropertiesSet"><a href="#回调-afterPropertiesSet" class="headerlink" title="回调 afterPropertiesSet"></a>回调 afterPropertiesSet</h3><p>如果 bean 实现 InitializingBean 接口，调用 bean 的 afterPropertiesSet 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果bean实现InitializingBean接口，调用bean的afterPropertiesSet方法</span><br><span class="line">boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class="line">if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">	((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调-init"><a href="#回调-init" class="headerlink" title="回调 init"></a>回调 init</h3><p>xml 配置或@Bean 方式指定了 bean 的 init 方法时回调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 反射调用bean的init方法（init方法声明在bean的xml定义文件）</span><br><span class="line">if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">	String initMethodName = mbd.getInitMethodName();</span><br><span class="line">	if (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">			!(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">			!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">		invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bpp-初始化后置处理"><a href="#bpp-初始化后置处理" class="headerlink" title="bpp 初始化后置处理"></a>bpp 初始化后置处理</h3><p>回调<code>BeanPostProcessor.postProcessAfterInitialization</code>执行 bean 初始化后置处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123;</span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		if (current == null) &#123;</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加载后"><a href="#加载后" class="headerlink" title="加载后"></a>加载后</h2><h3 id="earlyReference-可靠性检测"><a href="#earlyReference-可靠性检测" class="headerlink" title="earlyReference 可靠性检测"></a>earlyReference 可靠性检测</h3><p>当 bean 在 bpp 的前置&#x2F;后置处理时被代理，且 bean 存在循环依赖（earlyReference 能拿到 bean），则其他 beans 注入的 earlyReference 已失效，即 Spring 为循环依赖提供的 earlyReference 机制失效，抛 BeanCurrentlyInCreationException 异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">	// 查询singletonEarlyReference</span><br><span class="line">	Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">	// earlyReference不为空说明存在循环依赖</span><br><span class="line">	if (earlySingletonReference != null) &#123;</span><br><span class="line">		// exposedObject == bean 说明bean未被bpps在初始化处理时代理</span><br><span class="line">		if (exposedObject == bean) &#123;</span><br><span class="line">			exposedObject = earlySingletonReference;</span><br><span class="line">		&#125;</span><br><span class="line">		// bean已被代理，与earlySingletonReference不一致，依赖该bean的其他beans拿到的并不是真正的bean</span><br><span class="line">		// allowRawInjectionDespiteWrapping=true表示允许这种情况，默认为false</span><br><span class="line">		else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">			// 依赖当前bean的其他已加载的beans</span><br><span class="line">			String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">			Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">			// 筛除typeCheckOnly加载的dependentBeans</span><br><span class="line">			for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">				// org.springframework.beans.factory.support.AbstractBeanFactory.getBean(java.lang.String) 方法加载bean不是typeCheckOnly</span><br><span class="line">				// 所以如果依赖当前bean的其他beans是调用getBean加载的，就是actualDependentBeans了</span><br><span class="line">				if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">					actualDependentBeans.add(dependentBean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 有其他已加载的beans依赖当前bean，且当前bean已被代理，则抛异常</span><br><span class="line">			if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">				throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">						&quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">						StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">						&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">						&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">						&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">						&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持-bean-销毁回调"><a href="#支持-bean-销毁回调" class="headerlink" title="支持 bean 销毁回调"></a>支持 bean 销毁回调</h3><p>bean 配置销毁回调有这些方式：</p>
<ul>
<li>bean 实现 DisposableBean 接口</li>
<li>xml 里显示指定 destroy-method</li>
<li>@Bean 里显示指定 destroy-method</li>
<li>存在 <code>DestructionAwareBeanPostProcessor</code> 支持 bean 的销毁回调<ul>
<li>requiresDestruction 方法传入 bean，返回 true</li>
</ul>
</li>
</ul>
<p>Spring 会为配置销毁回调的单例 bean 创建对应的销毁适配器<code>DisposableBeanAdapter</code>，并缓存在 BeanFactory，key&#x3D;beanName</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">	AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);</span><br><span class="line">	if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">		if (mbd.isSingleton()) &#123;</span><br><span class="line">		registerDisposableBean(beanName,</span><br><span class="line">				new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			... ...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">	return (bean.getClass() != NullBean.class &amp;&amp;</span><br><span class="line">			(DisposableBeanAdapter.hasDestroyMethod(bean, mbd) || (hasDestructionAwareBeanPostProcessors() &amp;&amp;</span><br><span class="line">					DisposableBeanAdapter.hasApplicableProcessors(bean, getBeanPostProcessors()))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public static boolean hasDestroyMethod(Object bean, RootBeanDefinition beanDefinition) &#123;</span><br><span class="line">	if (bean instanceof DisposableBean || bean instanceof AutoCloseable) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	String destroyMethodName = beanDefinition.getDestroyMethodName();</span><br><span class="line">	if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName)) &#123;</span><br><span class="line">		return (ClassUtils.hasMethod(bean.getClass(), CLOSE_METHOD_NAME) ||</span><br><span class="line">				ClassUtils.hasMethod(bean.getClass(), SHUTDOWN_METHOD_NAME));</span><br><span class="line">	&#125;</span><br><span class="line">	return StringUtils.hasLength(destroyMethodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring 容器调用 close 方法关闭时，会调用所有 DisposableBeanAdapter 的 destroy 方法执行 bean 的销毁流程：</p>
<ul>
<li>如果存在 DestructionAwareBeanPostProcessor 支持 bean 销毁，回调 bpp 的 bean 销毁前置回调方法</li>
<li>如果 bean 实现了 DisposableBean 接口，回调 destroy 方法</li>
<li>如果 bean 配置了 destroy-method，回调配置的 destroy-method 方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">	if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123;</span><br><span class="line">		for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123;</span><br><span class="line">			processor.postProcessBeforeDestruction(this.bean, this.beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (this.invokeDisposableBean) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Invoking destroy() on bean with name &#x27;&quot; + this.beanName + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					((DisposableBean) this.bean).destroy();</span><br><span class="line">					return null;</span><br><span class="line">				&#125;, this.acc);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				((DisposableBean) this.bean).destroy();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			String msg = &quot;Invocation of destroy method failed on bean with name &#x27;&quot; + this.beanName + &quot;&#x27;&quot;;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.warn(msg, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				logger.warn(msg + &quot;: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (this.destroyMethod != null) &#123;</span><br><span class="line">		invokeCustomDestroyMethod(this.destroyMethod);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (this.destroyMethodName != null) &#123;</span><br><span class="line">		Method methodToCall = determineDestroyMethod(this.destroyMethodName);</span><br><span class="line">		if (methodToCall != null) &#123;</span><br><span class="line">			invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存单例-bean"><a href="#缓存单例-bean" class="headerlink" title="缓存单例 bean"></a>缓存单例 bean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">	synchronized (this.singletonObjects) &#123;</span><br><span class="line">		this.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">		this.singletonFactories.remove(beanName);</span><br><span class="line">		this.earlySingletonObjects.remove(beanName);</span><br><span class="line">		this.registeredSingletons.add(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/spring/bean%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png"></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码-bean注册</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81-bean%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>bean 定义分为两大类，一种是在资源文件里定义 bean，另一种是注解方式。<br>资源文件可以是 groovy 文件、properties 文件或者 xml 文件，本文介绍 Spring 是如何注册在 xml 里定义的 beanDefinition。</p>
<h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><p>Spring 定义接口 Resource 来表示资源文件。通过 Resource 能拿到文件的输入流、File 对象等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">	File getFile() throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface InputStreamSource &#123;</span><br><span class="line"></span><br><span class="line">	InputStream getInputStream() throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h1><p>ClassPathResource 表示从类路径 ClassPath 下加载的资源文件。看下它的构造函数。</p>
<p>构造函数 1：</p>
<ul>
<li>第一个参数是资源文件在 classpath 下的路径<ul>
<li>这里通常传入的就是 bean 定义的资源文件，例如 xml 文件</li>
<li>不需要以”&#x2F;“开头</li>
</ul>
</li>
<li>第二个参数是 CL，如果传 null，由 ClassUtils 取默认的<code>线程上下文加载器</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public ClassPathResource(String path, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">	Assert.notNull(path, &quot;Path must not be null&quot;);</span><br><span class="line">	String pathToUse = StringUtils.cleanPath(path);</span><br><span class="line">	if (pathToUse.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">		pathToUse = pathToUse.substring(1);</span><br><span class="line">	&#125;</span><br><span class="line">	this.path = pathToUse;</span><br><span class="line">	this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数 2：</p>
<ul>
<li>如果构造函数传入 Class，则资源文件必须在传入 Class 所在包路径下，path 是资源文件在 Class 所在包下的相对路径，也不用以”&#x2F;“开头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public ClassPathResource(String path, @Nullable Class&lt;?&gt; clazz) &#123;</span><br><span class="line">	Assert.notNull(path, &quot;Path must not be null&quot;);</span><br><span class="line">	this.path = StringUtils.cleanPath(path);</span><br><span class="line">	this.clazz = clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 CL 加载得到类路径下的资源文件输入流</p>
<ul>
<li>如果构造 ClassPathResource 时传入了 Class，则加载资源文件输入流的是加载 Class 的 ClassLoader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public InputStream getInputStream() throws IOException &#123;</span><br><span class="line">	InputStream is;</span><br><span class="line">	if (this.clazz != null) &#123;</span><br><span class="line">		is = this.clazz.getResourceAsStream(this.path);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (this.classLoader != null) &#123;</span><br><span class="line">		is = this.classLoader.getResourceAsStream(this.path);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		is = ClassLoader.getSystemResourceAsStream(this.path);</span><br><span class="line">	&#125;</span><br><span class="line">	if (is == null) &#123;</span><br><span class="line">		throw new FileNotFoundException(getDescription() + &quot; cannot be opened because it does not exist&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：<br>beandefinition.BeanDefinitionTests#testClassPathResource</p>
<h1 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h1><p>BeanDefinitionReader 是 beanDefinition 的解析注册器，负责读取资源文件 Resource 并解析得到 beanDefinition，然后注册到 bean 工厂</p>
<ul>
<li>每种资源文件（xml、groovy、properties 类型）都有对应的 BeanDefinitionReader 实现类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BeanDefinitionReader &#123;</span><br><span class="line"></span><br><span class="line">	BeanDefinitionRegistry getRegistry();</span><br><span class="line"></span><br><span class="line">	int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h1><p>XmlBeanDefinitionReader 是 xml 方式定义 beanDefinition 的解析注册器，它会按 xml 格式解析 Resource 得到 beanDefinition</p>
<ul>
<li>xml 文件一般放在 ClassPath 下，所以 Resource 的类型是 ClassPathResource</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    super(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 loadBeanDefinitions 方法开始 bd 的解析和注册流程。</p>
<h2 id="解析-xml"><a href="#解析-xml" class="headerlink" title="解析 xml"></a>解析 xml</h2><p>解析 xml 直接使用 jdk 自带的工具类：</p>
<ul>
<li>把 xml 文件输入流包装为 InputSource 对象</li>
<li>使用 DocumentBuilder 解析 InputSource 得到 Document 对象<ul>
<li>通过 Document 可以方便获取 xml 的标签元素</li>
<li>DTD 和 XSD 是两种常用的 XML 文档格式定义规范，在 xml 文件头部指定，目前主流的都使用 XSD 规范。构造 DocumentBuilder 时指定按哪种规范来校验和解析 xml</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    try &#123;</span><br><span class="line">        InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="line">            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">    return builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 Document 对象说明 xml 解析完成。</p>
<h2 id="构建-beanDefinition"><a href="#构建-beanDefinition" class="headerlink" title="构建 beanDefinition"></a>构建 beanDefinition</h2><p>调用 BeanDefinitionDocumentReader 的 registerBeanDefinitions 方法完成 beanDefinition 的构建和注册流程</p>
<ul>
<li>DefaultBeanDefinitionDocumentReader 是 BeanDefinitionDocumentReader 的默认实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">        int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">        // 由DocumentReader负责读取Document并注册bd到beanFactory</span><br><span class="line">        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">        return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建 beanDefiniton 前，需要先从 document 拿到根 root 元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">doRegisterBeanDefinitions(root);</span><br></pre></td></tr></table></figure>

<p>构建 beanDefinition 的过程拆解如下。</p>
<h3 id="profile-环境隔离"><a href="#profile-环境隔离" class="headerlink" title="profile 环境隔离"></a>profile 环境隔离</h3><p>如果根标签是 Spring 的 beans 标签，读取 profile 属性指定的环境标，如果与当前环境标匹配，则注册 beans 标签内定义的 bean，否则忽略这些 bean</p>
<ul>
<li>根标签的命名空间是“<a href="http://www.springframework.org/schema/beans%E2%80%9D%EF%BC%8C%E8%AF%B4%E6%98%8E%E6%A0%B9%E6%A0%87%E7%AD%BE%E6%98%AFSpring%E7%9A%84beans%E6%A0%87%E7%AD%BE">http://www.springframework.org/schema/beans”，说明根标签是Spring的beans标签</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">	// 如果beans使用profile加载机制，则跳过不需要在当前环境加载的beans</span><br><span class="line">	String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">	if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">		String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">				profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">						&quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acceptsProfiles 方法遍历所有 profile 属性指定的环境标，只要有一个 profile 环境标在当前环境标中，就认为匹配成功，可以注册 bean</p>
<p>当前环境标有两部分组成：activeProfiles 和 defaultProfiles</p>
<ul>
<li>ActiveProfiles 集合是从系统变量或环境变量里，通过 key&#x3D;<code>spring.profiles.active</code>拿到 value，按”,”分隔后的集合。默认的 ActiveProfiles 为空，可以通过几种方式指定环境标：<ul>
<li>显式添加到系统属性：<code>System.setProperty(&quot;spring.profiles.active&quot;, &quot;development&quot;);</code></li>
<li>web.xml 里配置 spring.profiles.active 到 context-param</li>
<li>使用注解：@ActiveProfiles(“test”)</li>
</ul>
</li>
<li>DefaultProfiles 集合类似，只不过 key&#x3D;<code>spring.profiles.default</code>。Spring 默认有一个预留 reserved 的 DefaultProfile&#x3D;”default”，如果用户有通过环境变量设置了，则替换</li>
</ul>
<p>profile 环境标和当前环境标匹配规则为：优先匹配 activeProfiles，如果 activeProfiles 为空，再匹配 defaultProfiles</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean acceptsProfiles(String... profiles) &#123;</span><br><span class="line">	Assert.notEmpty(profiles, &quot;Must specify at least one profile&quot;);</span><br><span class="line">	for (String profile : profiles) &#123;</span><br><span class="line">		if (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(0) == &#x27;!&#x27;) &#123;</span><br><span class="line">			if (!isProfileActive(profile.substring(1))) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (isProfileActive(profile)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean isProfileActive(String profile) &#123;</span><br><span class="line">	validateProfile(profile);</span><br><span class="line">	Set&lt;String&gt; currentActiveProfiles = doGetActiveProfiles();</span><br><span class="line">	return (currentActiveProfiles.contains(profile) ||</span><br><span class="line">			(currentActiveProfiles.isEmpty() &amp;&amp; doGetDefaultProfiles().contains(profile)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：beandefinition.BeanDefinitionTests#testProfile</p>
<h3 id="前置和后置钩子"><a href="#前置和后置钩子" class="headerlink" title="前置和后置钩子"></a>前置和后置钩子</h3><p>DefaultBeanDefinitionDocumentReader 提供了钩子函数，在 bd 注册前和注册后回调，用户可以继承<code>DefaultBeanDefinitionDocumentReader</code>来自定义逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, this.delegate);</span><br><span class="line">postProcessXml(root);</span><br></pre></td></tr></table></figure>

<p>测试代码：beandefinition.BeanDefinitionTests#customDefaultBeanDefinitionDocumentReader</p>
<h3 id="处理子标签"><a href="#处理子标签" class="headerlink" title="处理子标签"></a>处理子标签</h3><p>如果是 beans 命名空间，遍历 beans 的所有子标签，读取并构建 beanDefinition，然后注册<br>如果不是 beans 命名空间，说明是用户自定义的 xml，走自定义标签处理流程。不过目标也是读取并构建 beanDefinition，然后注册</p>
<ul>
<li>debug 发现，孩子节点是行维度的，空行或者注释的行，也是一个孩子。所以 xml 文件尽量写得紧凑些，避免产生一些无用的孩子节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		// beans-&gt;bean-&gt;property</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			if (node instanceof Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					// 解析自定义标签，生成BeanDefinition并注册到beanFactory</span><br><span class="line">					// beans标签的解析由Spring完成，自定义标签的解析由用户自定义parser完成</span><br><span class="line">					// 例如&lt;myname:user .../&gt;，myname就是命名空间，Spring通过命名空间找到handler，通过handler找到标签user对应的parser完成自定义标签的解析和注册</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans 的子标签目前有四个：import、alias、bean、beans（嵌套方式），重点是解析 bean 标签</p>
<ul>
<li>对于 import 子标签，加载 resource 属性指定的资源文件，然后再重新调用 xmlBeanDefinitionReader#loadBeanDefinitions 方法，走一遍解析 xml 并注册 bean</li>
<li>对于 alias 子标签，别名与 beanName 的映射关系注册到 bf<ul>
<li>测试代码：beandefinition.BeanDefinitionTests#testBeanNameAlias</li>
</ul>
</li>
<li>对于嵌套 beans 标签，当做根标签处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 加载import resource指定的bean定义文件，注册beanDefinition到beanFactory</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 别名与beanName的映射关系注册到beanFactory</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 注册beanDefinition到beanFactory</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">	// 注册嵌套式定义的beans到beanFactory。嵌套式即beans标签里还嵌套了beans标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		// recurse</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析-bean-标签"><a href="#解析-bean-标签" class="headerlink" title="解析 bean 标签"></a>解析 bean 标签</h3><p>对于 bean 标签，需要解析得到 beanDefinition 并注册</p>
<p>先确定 beanName 和别名</p>
<ul>
<li>beanName 优先取 id 属性，为空再取 name 属性按”,”或”;”分隔后的第一个字符串。如果 name 属性也空，由 spring 生成 BeanName，格式为：{类的全路径名}#0，别名为：类的全路径名</li>
<li>别名取 name 属性按”,”或”;”分隔后的多个字符串，如果 beanName 用了第一个字符串，则别名要把它排掉</li>
</ul>
<p>注意，getBean 方法可以传入别名，但 getBeanDefinition 方法只能传入 beanName，不认别名。测试代码：beandefinition.BeanDefinitionTests#testBeanName</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; aliases = new ArrayList&lt;&gt;();</span><br><span class="line">if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">	String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">	aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line">// 如果bean的id为空，取第一个name作为beanName</span><br><span class="line">if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">	beanName = aliases.remove(0);</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot; + beanName +</span><br><span class="line">				&quot;&#x27; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 bean 标签的属性和子标签，封装到 BeanDefinition</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bd最基本的属性是CL加载的bean类对象</span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">// bean的各种框架属性封装到bd</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">// 解析bean的meta子标签属性（bean属性之外的键值对）并添加到bd。通过bd的getMetadataAttribute可以获取meta属性</span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">// 解析lookup-method。bean方法声明一个父类返回结果，实际返回bean在lookup-method中声明</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">// 解析replaced-method。replaced-method用于完全替换bean方法的实现</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">// 解析bean的constructor-arg子标签得到构造函数参数，添加到bd.constructorArgumentValues</span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">// 解析bean的property子标签得到业务属性，添加到bd.propertyValues。如果属性值是一个ref，封装成RuntimeBeanReference，如果是一个value，封装成TypedStringValue</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">// 解析bean的qualifier子标签，添加到bd.qualifiers。qualifier的作用是按byName声明要注入的实际bean</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(this.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">return bd;</span><br></pre></td></tr></table></figure>

<p>一些比较重要的 bean 标签属性：</p>
<ul>
<li>autowire：如果 bean 的引用类型的属性没有用@Autowire 或@Resource 修饰，可以在 xml 里使用 autowire 属性统一指定依赖注入方式，一般为 byName 或 byType</li>
<li>scope：bean 的作用域，一般为 singleton 或者 prototype</li>
<li>lazy-init：如果想要 bean 懒加载，lazy-init 设为 true</li>
<li>depends-on：指定当前 bean 前置依赖的一些 beanNames，用,或者;分割</li>
<li>primary：为 true 表示当前 bean 是 primary 的，byType 加载到多个 bean 时，取 primary bean</li>
<li>init-method：设置 bean 初始化阶段回调的 init 方法名</li>
<li>destroy-method：设置 bean 销毁前回调的 destroy 方法名</li>
</ul>
<p>一些比较重要的 bean 子标签的：</p>
<ul>
<li>meta：额外定义一些 bean 的元属性 KV，保存到 BD。只能通过 BD#getAttribute 方法传入 K 获得 V，不会作为 bean 实例的属性，即元属性的含义<ul>
<li>测试代码：beandefinition.BeanDefinitionTests#testMeta</li>
</ul>
</li>
<li>lookup-method：指定 lookup-method 标签声明的方法的返回值（bean）<ul>
<li>配置 lookup-method 的 bean，会被 CgLIB 代理，增强逻辑是从 bd.methodOverrides 获取 lookup-method 方法返回的 beanName，加载 bean 作为方法的返回值</li>
<li>注意不是属性的依赖注入，只是用动态代理强制指定了方法返回的 bean</li>
<li>测试代码：instantiation.before.lookup.LookupTest</li>
</ul>
</li>
<li>property：指定依赖注入的值。如果是一个 ref，封装成 RuntimeBeanReference，加载得到注入的 bean。如果是一个 value，封装成 TypedStringValue，当做字符串注入</li>
</ul>
<h3 id="解析自定义标签"><a href="#解析自定义标签" class="headerlink" title="解析自定义标签"></a>解析自定义标签</h3><p>所谓自定义标签，即标签的命名空间不是 Spring 的 beans 命名空间<br>Spring 提供了基于自定义命名空间获取对应标签处理器<code>NamespaceHandler</code>的机制，由 NamespaceHandler 负责解析自定义标签，生成 BD 并注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) &#123;</span><br><span class="line">	// 获取自定义标签的命名空间，Spring默认命名空间是beans</span><br><span class="line">	String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">	if (namespaceUri == null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 找到该命名空间的自定义Handler</span><br><span class="line">	NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">		error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 通过handler找到自定义parser，解析自定义标签，生成beanDefinition注册到beanFactory</span><br><span class="line">	return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次解析自定义标签时，会加载描述命名空间和<code>NamespaceHandler</code>映射关系的资源文件，默认是类路径下的<code>META-INF/spring.handlers</code>文件，然后反射实例化 handler，再调用它的 init 方法注册该命名空间下的所有标签解析器<code>BeanDefinitionParser</code>，最后将命名空间和<code>NamespaceHandler</code>的映射关系放入 map 缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   // handlerMappingsLocation默认为：META-INF/spring.handlers，classLoader默认为ClassUtils.getDefaultClassLoader方法返回的线程上下文加载器</span><br><span class="line">   Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);</span><br><span class="line">   ... ...</span><br><span class="line">   NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">// 注册用于解析自定义标签的用户实现的BeanDefinitionParser</span><br><span class="line">namespaceHandler.init();</span><br><span class="line">handlerMappings.put(namespaceUri, namespaceHandler);</span><br></pre></td></tr></table></figure>

<p>示例：<br><code>SimpleConstructorNamespaceHandler</code>支持所有”&lt;c:xxx&gt;”标签的解析，c 是命名空间，xxx 是标签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler</span><br></pre></td></tr></table></figure>

<p><code>NamespaceHandler</code>的 parse 方法，会通过标签名获取标签解析器<code>BeanDefinitionParser</code>，调用 parse 方法解析标签，生成 BeanDefinition。通过 ParserContext 能拿到 beanFactory，至于是否注册 beanDefinition 到 beanFactory，由 parse 方法的实现决定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123;</span><br><span class="line">	// 获取命名空间后面的标签名，例如&lt;mybean:user xxx/&gt;，标签名就是user</span><br><span class="line">	String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">	BeanDefinitionParser parser = this.parsers.get(localName);</span><br><span class="line">	if (parser == null) &#123;</span><br><span class="line">		parserContext.getReaderContext().fatal(</span><br><span class="line">				&quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element);</span><br><span class="line">	&#125;</span><br><span class="line">	return parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用自定义标签，需要：</p>
<ul>
<li>写一个自定义命名空间下的 XML 文档协议规范 XSD</li>
<li>实现 NamespaceHandler 和标签解析器 BeanDefinitionParser</li>
<li>将命名空间和 NamespaceHandler 的映射关系写入<code>META-INF/spring.handlers</code>资源文件</li>
<li>在 xml 文件中声明自定义的命名空间</li>
</ul>
<h3 id="BD-注册到-bean-工厂"><a href="#BD-注册到-bean-工厂" class="headerlink" title="BD 注册到 bean 工厂"></a>BD 注册到 bean 工厂</h3><p>注册即 beanDefinition 添加到 beanFactory.beanDefinitionMap，key&#x3D;beanName，别名注册到 beanFactory.aliasMap，key&#x3D;alias，value&#x3D;beanName</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	// Register bean definition under primary name.</span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	// Register aliases for bean name, if any.</span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	if (aliases != null) &#123;</span><br><span class="line">		for (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bean-工厂"><a href="#bean-工厂" class="headerlink" title="bean 工厂"></a>bean 工厂</h1><p>bean 工厂的主要职责是管理注册的 beanDefinition 以及加载 bean，即实现所谓的 IoC 控制反转</p>
<p><code>DefaultListableBeanFactory</code>是 Spring 最常用的 bean 工厂，<code>XmlBeanFactory</code>是它的子类，可以理解为<code>XML配置方式得到的bean工厂</code>，使用<code>XmlBeanDefinitionReader</code>解析 XML 配置文件、生成 beanDefinition 并注册到 bean 工厂</p>
<blockquote>
<p>bean 工厂本身并不负责解析各种方式（注解、XML）的 bean 定义并生成 beanDefinition，它只是拿到 beanDefinition 执行后续 bean 注册、加载流程。bean 定义的解析注册由各种<code>BeanDefinitionReader</code>完成，它持有 bean 工厂，生成 beanDefinition 后回调 bean 工厂的注册方法注册 bean</p>
</blockquote>
<p>注意，XmlBeanFactory 现在已经被 Spring 废弃，替代它的是<code>ClassPathXmlApplicationContext</code></p>
<p><code>ClassPathXmlApplicationContext</code>本身是一个 Spring 容器<code>ApplicationContext</code>，在构造函数中创建好<code>DefaultListableBeanFactory</code>，其中 xml 解析和注册 beanDefinition 仍然通过<code>XmlBeanDefinitionReader</code></p>
<p>Spring 容器<code>ApplicationContext</code>具备 bean 工厂的全部能力，并提供了对于 bean 工厂更多的定制和扩展能力，后文会详细介绍 Spring 容器</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="/spring/xml%E6%96%B9%E5%BC%8Fbean%E8%A7%A3%E6%9E%90%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png"></p>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><p><img src="/spring/xml%E6%96%B9%E5%BC%8Fbean%E6%B3%A8%E5%86%8C%E7%B1%BB%E5%9B%BE.png"></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习Spring源码</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>github找到spring-framework的项目地址，clone到本地<br>check到5.0.X的分支<br>使用idea 2020.2版本打开项目（srping-framework使用gradle进行依赖管理）<br>本地构建项目</p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>所有测试代码均在git仓库：<a href="https://github.com/dcbupt/my_spring_5.git">https://github.com/dcbupt/my_spring_5.git</a></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习TCP</title>
    <url>/2022/07/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0TCP/</url>
    <content><![CDATA[<h2 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h2><blockquote>
<p>ref：<a href="https://zhuanlan.zhihu.com/p/450296852">https://zhuanlan.zhihu.com/p/450296852</a></p>
</blockquote>
<blockquote>
<p>ref：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247502230&amp;idx=1&amp;sn=5fb86772de17ab650088944d4d0adf62&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247502230&amp;idx=1&amp;sn=5fb86772de17ab650088944d4d0adf62&amp;scene=21#wechat_redirect</a></p>
</blockquote>
<h3 id="什么是-TIME-WAIT-状态？"><a href="#什么是-TIME-WAIT-状态？" class="headerlink" title="什么是 TIME_WAIT 状态？"></a>什么是 TIME_WAIT 状态？</h3><p>断开 TCP 连接的四次挥手流程中，主动发起断开的一方发送针对对端 FIN 消息的 ACK 消息后，进入 TIME_WAIT 状态。该状态会持续 2MSL 时间，即 2 倍的最大分片生命时长后结束。LINUX 系统中，2MSL 设置为 60s</p>
<h3 id="为什么要有这个状态？"><a href="#为什么要有这个状态？" class="headerlink" title="为什么要有这个状态？"></a>为什么要有这个状态？</h3><ul>
<li>防止历史连接中的延迟报文，被后面相同四元组的连接错误的接收；<ul>
<li>因为等待了 2MSL 时间，所以延迟报文肯定不会在后续的 tcp 连接上收到</li>
<li>不能通过 TCP 的报文序列号来判断是否为延迟报文，因为序列号不是单调递增的，到一个极值后会回绕到初始值</li>
</ul>
</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；<ul>
<li>如果主动发起断联的一方回复的 ACK 消息丢包，对端会重传 FIN 消息，此时如果没有 TIME_WAIT 状态，会回复 RST 消息，导致对端不能优雅地断开连接</li>
</ul>
</li>
</ul>
<h3 id="如果处于-TIME-WAIT-状态的-TCP-连接过多，会有什么问题？"><a href="#如果处于-TIME-WAIT-状态的-TCP-连接过多，会有什么问题？" class="headerlink" title="如果处于 TIME_WAIT 状态的 TCP 连接过多，会有什么问题？"></a>如果处于 TIME_WAIT 状态的 TCP 连接过多，会有什么问题？</h3><p>HTTP 请求的 QPS 过高时，服务端可能出现很多处于 TIME_WAIT 状态的连接，把端口号打满导致没有空闲端口来建立新的 TCP 连接</p>
<h3 id="如何解决-TIME-WAIT-过多的问题？"><a href="#如何解决-TIME-WAIT-过多的问题？" class="headerlink" title="如何解决 TIME_WAIT 过多的问题？"></a>如何解决 TIME_WAIT 过多的问题？</h3><ul>
<li>开启 LINUX 的内核参数 tcp_tw_reuse，默认是关闭的<ul>
<li>该参数能使得 TIME_WAIT 状态的连接被新连接复用，注意必须是主动发起的 TCP 连接</li>
<li>开启 tcp_tw_reuse 必须配合开启另一个内核参数 tcp_timestamps，不过它默认就是开启的<ul>
<li>开启 tcp_timestamps，即打开 TCP 时间戳，这样就能基于 TCP 报文的时间戳来判断是否为历史连接中的延迟报文。时间戳是根据 CPU 时钟生成的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意，不要开启内核参数 tcp_tw_recycle 来解决 TIME_WAIT 过多问题。tcp_tw_recycle 开启后，只会识别 IP 来做报文的时间戳校验。在 NAT 网络中，两个客户端的 IP 一样，如果新的客户端发送的建连 SYN 报文的时间戳小于之间客户端报文的时间戳，回收了 TIME_WAIT 连接的端口就会丢弃客户端的 SYN 消息，导致连接建立失败</p>
<h3 id="既然默认开启了-tcp-timestamps，为什么不默认开启-tcp-tw-reuse？"><a href="#既然默认开启了-tcp-timestamps，为什么不默认开启-tcp-tw-reuse？" class="headerlink" title="既然默认开启了 tcp_timestamps，为什么不默认开启 tcp_tw_reuse？"></a>既然默认开启了 tcp_timestamps，为什么不默认开启 tcp_tw_reuse？</h3><ul>
<li>无法保证「被动关闭连接」的一方，能被正确的关闭</li>
<li>RST 报文不会做时间戳校验，如果复用了 TIME_WAIT 的新连接收到了延迟 RST 报文，且序列号恰巧也在接收窗口内，就会处理 RST 报文，导致连接“意外”断开</li>
</ul>
<h2 id="半连接队列和全连接队列"><a href="#半连接队列和全连接队列" class="headerlink" title="半连接队列和全连接队列"></a>半连接队列和全连接队列</h2><blockquote>
<p>ref：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247484569&amp;idx=1&amp;sn=1ca4daeb8043a957850ab7a8f4f1120e&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247484569&amp;idx=1&amp;sn=1ca4daeb8043a957850ab7a8f4f1120e&amp;scene=21#wechat_redirect</a></p>
</blockquote>
<h3 id="什么是半连接队列和全连接队列"><a href="#什么是半连接队列和全连接队列" class="headerlink" title="什么是半连接队列和全连接队列"></a>什么是半连接队列和全连接队列</h3><p>TCP 建连的三次握手中，服务端收到 SYN 报文后，会把连接放到半连接队列，服务端收到客户端对自己 SYN 报文的 ACK 后，把连接从半连接队列移到全连接队列（也称 accept 队列），等待进程调用 accept 把连接取走</p>
<h3 id="如果瞬时流量把全连接队列打满了怎么办？"><a href="#如果瞬时流量把全连接队列打满了怎么办？" class="headerlink" title="如果瞬时流量把全连接队列打满了怎么办？"></a>如果瞬时流量把全连接队列打满了怎么办？</h3><p>LINUX 提供内核参数 tcp_abort_on_overflow，默认为 0，即扔掉客户端的 ACK 报文。这样客户端感知不到，就会接着发送 HTTP 请求，且携带 ACK，当服务端全连接队列有空闲后，依然会 accept 拿到这次连接并成功建连的。<br>除非你确定全连接队列将长期溢出，否则不要将 tcp_abort_on_overflow 改为 1，否则服务端会回复 RST 报文，导致这次连接建立失败。</p>
<h3 id="如何增大全连接队列"><a href="#如何增大全连接队列" class="headerlink" title="如何增大全连接队列"></a>如何增大全连接队列</h3><p>全连接队列足最大值取决于 somaxconn 和 backlog 之间的最小值</p>
<ul>
<li>somaxconn 是 Linux 内核的参数，默认值是 128</li>
<li>backlog 是内核方法 listen 的参数，由 web 服务器程序决定。Nginx 默认 511</li>
</ul>
<h3 id="如何增大半连接队列"><a href="#如何增大半连接队列" class="headerlink" title="如何增大半连接队列"></a>如何增大半连接队列</h3><p>需要同时增大内核参数 tcp_max_syn_backlog 和全连接队列大小</p>
<h3 id="什么是-SYN-攻击？"><a href="#什么是-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？"></a>什么是 SYN 攻击？</h3><p>SYN 攻击就是客户端发起 SYN 报文后，不响应服务端的 SYN 报文，导致服务端半连接队列打满无法建立新连接。也称 DDos 攻击</p>
<h3 id="如何防御-SYN-攻击？"><a href="#如何防御-SYN-攻击？" class="headerlink" title="如何防御 SYN 攻击？"></a>如何防御 SYN 攻击？</h3><ul>
<li>增大半连接队列</li>
<li>开启内核参数 tcp_syncookies<ul>
<li>tcp_syncookies 可以在不用半连接队列的情况下建连成功</li>
<li>服务端收到 SYN 报文后，在发送 SYN+ACK 报文里携带 cookie，如果收到客户端 ACK 报文后 cookie 验证合法就认为建联成功</li>
</ul>
</li>
<li>减少 SYN+ACK 重传次数<ul>
<li>因为 SYN 攻击的一方不会回复 ACK，所以服务端可以修改内核参数 tcp_synack_retries 的值，来减少 SYN+ACK 重传次数，以加速断开这种 TCP 连接</li>
</ul>
</li>
</ul>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><blockquote>
<p>ref：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247511590&amp;idx=2&amp;sn=faa6a4c6124eca8a79201489abfd394e&amp;chksm=f98dea8ccefa639af93083f9d917775efc103cf239a54d672c5a9dd7808f4d77447aa6e4c6a4&amp;scene=178&amp;cur_album_id=1337204681134751744#rd">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247511590&amp;idx=2&amp;sn=faa6a4c6124eca8a79201489abfd394e&amp;chksm=f98dea8ccefa639af93083f9d917775efc103cf239a54d672c5a9dd7808f4d77447aa6e4c6a4&amp;scene=178&amp;cur_album_id=1337204681134751744#rd</a></p>
</blockquote>
<p>TCP 基于序列号的确认应答和重传机制保证了数据的可靠传输。重传机制主要是“超时重传”和“快速重传”二者的结合</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>报文发送端会不断抽样加权计算得到报文从发送到收到应答的平均往返时间，当报文超过平均往返时间还没收到应答，就重传报文</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>当发送方连续三次收到针对同一个报文的 ACK 后，就会重传报文，即使还没超时</p>
<ul>
<li>接收端需要保证数据连续性，所以当前面有报文没收到时，即使收到了后面的报文，ACK 也返回前面缺失报文的序列号</li>
</ul>
<p>快速重传的问题是，重传时无法决定是只重传 ACK 指向的报文还是把后面的报文都重传。因此引入了 SACK（ Selective Acknowledgment 选择性确认） 机制</p>
<p>SACK 在 TCP 头部「选项」字段里加一个 SACK 字段，它可以将缓存的地图发送给发送方，这样发送方就知道哪些数据收到了，哪些数据没收到，就可以只重传丢失的数据</p>
<ul>
<li>通过内核参数 net.ipv4.tcp_dsack 开启 SACK 机制，默认开启</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><blockquote>
<p>ref：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247511590&amp;idx=2&amp;sn=faa6a4c6124eca8a79201489abfd394e&amp;chksm=f98dea8ccefa639af93083f9d917775efc103cf239a54d672c5a9dd7808f4d77447aa6e4c6a4&amp;scene=178&amp;cur_album_id=1337204681134751744#rd">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247511590&amp;idx=2&amp;sn=faa6a4c6124eca8a79201489abfd394e&amp;chksm=f98dea8ccefa639af93083f9d917775efc103cf239a54d672c5a9dd7808f4d77447aa6e4c6a4&amp;scene=178&amp;cur_album_id=1337204681134751744#rd</a></p>
</blockquote>
<p>滑动窗口指发送方可以连续发送 TCP 报文的一个缓冲区空间。当前面发送的报文收到 ACK 后，窗口就会向后滑动，继续发送后面的 TCP 报文</p>
<h3 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h3><p>接收方每次收到报文，都会将当前 TCP 连接中还没收到的最前面的报文的序列号放到 ACK 里。<br>基于这种确认机制，当接收方收到了多个连续的 TCP 报文，即使中间一个 ACK 丢包了也不会影响，因为发送方只要收到最后一个报文的 ACK，就认为前面的报文也被接收了，这就叫“累积确认”</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方将自己可接收的网络缓冲区大小放到 TCP 协议头部的 Window 字段，以此控制发送方滑动窗口的大小，实现流量控制</p>
<ul>
<li>可以认为滑动窗口的大小约等于接收方当前可接收的网络缓冲区大小。</li>
</ul>
<h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><p>如果接收方网络缓冲区都占满了，则 ACK 消息里 Window &#x3D;0，此时窗口关闭<br>当窗口关闭时，发送方将不再发送后面的报文，而是启动一个定时任务，到时间则发送一个窗口探测报文查询接收方当前可用缓冲区大小，如果仍为 0，则继续这一过程，不为 0 则可以继续发送报文</p>
<h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>当接收方的应用层读取数据速度较慢时，接收方的可用缓冲区不断缩小，导致滑动窗口最后变得很小，一个 TCP 报文只能携带很少的应用数据（TCP、IP 协议字段占了大头），这就是糊涂窗口综合症，非常浪费带宽</p>
<p>为了避免糊涂窗口综合症，发送端和接收端有对应的策略</p>
<p>发送端使用 Nagle 算法延迟发送报文</p>
<ul>
<li>要等到窗口大小 &gt;&#x3D; MSS 或是 数据大小 &gt;&#x3D; MSS<ul>
<li>MSS 指 TCP 包能容纳应用层数据的最大长度，在建立连接的时候通常要协商双方的 MSS 值<ul>
<li>ref：<a href="https://www.zhihu.com/question/19790398">https://www.zhihu.com/question/19790398</a></li>
</ul>
</li>
<li>还有一个相关的参数 MTU，指网络包的最大长度，即 MSS+TCP 头+IP 头，一般为 1500 字节</li>
</ul>
</li>
<li>Nagle 算法默认是打开的，但对于小数据包强交互的程序如 ssh 或 telnet 并不合适，因此这类程序里需要设置 TCP_NODELAY 来关闭 Nagle 算法<ul>
<li>没有内核参数来全局开关 Nagle 算法</li>
</ul>
</li>
</ul>
<p>接收端在可用缓冲区较小时，直接在 ACK 里向发送方通告窗口为 0</p>
<ul>
<li>较小指可用缓冲区小于 min( MSS，缓存空间&#x2F;2 )</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>ref：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247511590&amp;idx=2&amp;sn=faa6a4c6124eca8a79201489abfd394e&amp;chksm=f98dea8ccefa639af93083f9d917775efc103cf239a54d672c5a9dd7808f4d77447aa6e4c6a4&amp;scene=178&amp;cur_album_id=1337204681134751744#rd">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247511590&amp;idx=2&amp;sn=faa6a4c6124eca8a79201489abfd394e&amp;chksm=f98dea8ccefa639af93083f9d917775efc103cf239a54d672c5a9dd7808f4d77447aa6e4c6a4&amp;scene=178&amp;cur_album_id=1337204681134751744#rd</a></p>
</blockquote>
<p>滑动窗口本质是发送端匹配客户端消费速度的一个数据发送窗口，但如果在网络环境拥塞时一股脑将滑动窗口内的数据都发送出去，可能很多报文都需要超时重传，浪费带宽且可能继续加剧网络拥塞<br>因此在发送端需要拥塞控制，即控制数据发送的速率</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>每次发送的报文数以 2 的指数倍增加，前提条件是前面发送的报文都收到了 ACK。因此最开始发送速率最慢，一般是 1 个 MSS 长度的报文，然后快速增长，最后达到阈值结束慢启动阶段，进入拥塞避免阶段</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>为避免造成网络拥塞，后续速率线性增加，即前面所有报文都 ACK 了，下次才会在之前的基础上再多发一个报文</p>
<h3 id="重启慢启动"><a href="#重启慢启动" class="headerlink" title="重启慢启动"></a>重启慢启动</h3><p>如果发生超时重传，说明网络拥塞，会重新走一遍慢启动阶段，且慢启动阈值是发生拥塞时的 1&#x2F;2</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>如果发生快速重传，说明网络并不算很拥塞，再收到前面遗漏报文的 ACK 后，会将发送速率减半，然后进入拥塞避免阶段</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习docker</title>
    <url>/2021/01/25/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0docker/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Docker 是基于 OS 层的虚拟化技术之上的容器引擎，实现对进程的封装隔离。开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上。</p>
<p>传统的虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需要的应用进程。实现资源隔离的方法是利用独立的 OS，并利用 Hypervisor 虚拟化 CPU、内存、IO 设备等实现的</p>
<p>docker 没有自己的内核，也没有硬件虚拟，是轻量级的虚拟化技术。docker 利用的是目前 Linux 内核本身支持的容器方式实现资源和环境隔离。简单的说，docker 利用 namespace 实现系统环境的隔离；利用 Cgroup 实现资源限制；利用镜像实现根目录环境的隔离。</p>
<h1 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h1><p>Docker Client:</p>
<ul>
<li>Docker 提供给用户的客户端。Docker Client 提供给用户一个终端，用户输入 Docker 提供的命令来管理本地或者远程的服务器</li>
</ul>
<p>Docker Daemon:</p>
<ul>
<li>Docker 服务的守护进程。每台服务器（物理机或虚机）上只要安装了 Docker 的环境，基本上就跑了一个后台程序 Docker Daemon，它会接收 Docker Client 发过来的指令，并对服务器的进行具体操作</li>
</ul>
<p>Docker file:</p>
<ul>
<li>Dockerfile 是用来 build 镜像的，镜像可以用来传播，镜像运行后生成容器<ul>
<li>(Dockerfile)build-&gt;(Image)ship-&gt;(Container&#x2F;VM)run</li>
</ul>
</li>
<li>docker daemon 在 docker build 阶段一行一行的执行 Dockerfile 中的指令，每一行指令执行完就 commit 一个镜像</li>
</ul>
<p>Docker Images:</p>
<ul>
<li>俗称 Docker 的镜像，docker 镜像是基础加应用，是一个软件从最顶层一直到最底层系统库的完整依赖栈</li>
<li>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变</li>
<li>Docker 镜像采用<code>分层存储结构</code>（AUFS）。每一层构建好后就不会在变，一层层构建，前一层是后一层的基础，由多层文件系统联合组成</li>
<li>bootFS（bootloader+kernel，linux 不同发行版，底层 bootFS 共用）&amp;&amp; rootFS（不同 OS 发行版的文件系统），区别只是 rootFS，且镜像用的是极简版的，所以操作系统 docker 镜像大小，例如 CentOS，远小于实际 CentOS 镜像大小</li>
</ul>
<p>Docker Registry:</p>
<ul>
<li>Docker Images 的仓库，就像 git 的仓库一样，用来管理 Docker 镜像的，提供了 Docker 镜像的上传、下载和浏览等功能</li>
<li>每个仓库可以包含多个<code>标签</code>（Tag），每个标签对应一个镜像<ul>
<li>例如集团使用的应用自动化构建发布平台 aone，所有在 aone 构建的应用镜像都放在 aone 仓库里，标签用于区分不同镜像，一般命名为：appName_${环境名}，例如线上是：appName_production</li>
</ul>
</li>
</ul>
<p>Docker Container:</p>
<ul>
<li>俗称 Docker 的容器，是真正跑项目程序、消耗机器资源、提供服务的地方。Docker Container 通过 Docker Images 启动，在 Docker Images 的基础上运行你需要的代码。你可以认为 Docker Container 提供了系统硬件环境，然后使用了 Docker Images 这些制作好的系统盘，再加上你的项目代码，跑起来就可以提供服务了</li>
</ul>
<p><code>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</code></p>
<p><img src="/docker/docker%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png"></p>
<h1 id="docker-实践"><a href="#docker-实践" class="headerlink" title="docker 实践"></a>docker 实践</h1><p>安装：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<ul>
<li>注意国内要设置阿里云镜像地址，加速 docker 下载过程</li>
</ul>
<p>docker 命令：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<p>搜索 docker 镜像：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h1 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h1><h2 id="docker0-网关"><a href="#docker0-网关" class="headerlink" title="docker0 网关"></a>docker0 网关</h2><p>docker 会在安装 docker 的宿主机上自动创建一个 docker0 网关（ip&#x3D;x.x.0.1&#x2F;16），桥接到宿主机的物理网卡</p>
<p>每次启动一个 docker 容器，docker 会使用 veth-pair 技术分配一对虚拟网络地址，一个给 docker 容器使用，一个给宿主机使用。给 docker 容器分配的虚拟网络是带 docker0 网关的子网 ip 的，给宿主机分配的虚拟网络只有 mac 地址</p>
<p>宿主机分配的虚拟网络相当于宿主机在 docker0 网关内的一个虚拟地址。当宿主机需要和 docker 容器通信时，先通过 veth-pair 生成的虚拟网络和 docker0 网关通信，网关再转发给 veth-pair 配对的 docker 容器子网 ip</p>
<ul>
<li>veth-pair 技术用来实现虚拟网络间的通信，这个例子中就是宿主机和 docker 容器的通信</li>
</ul>
<p>docker 容器间也可以通信，这很好理解，docker0 网关内部的子网之间当然可以通过 docker0 网关的转发实现通信（桥接模式，docker0 网关相当于一个网桥）</p>
<p>当 docker 容器删除后，veth-pair 分配的这一对虚拟网络也会删掉</p>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>创建 docker 容器默认使用 docker0 网关，但 docker0 网关有一个弊端，容器间不能通过容器名通信，只能通过 ip。这就导致容器一旦重启分配新的 ip，就 ping 不通了。为了实现基于容器名通信，可以创建自定义网络代替 docker0 网关：<code>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</code></p>
<ul>
<li>网络类型也是网桥（网关），和 docker0 一样</li>
</ul>
<p>启动容器时通过<code>--net mynet</code>指定容器加入自定义 docker 网络（默认 docker0）</p>
<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p>假设有 2 个 docker 网络，因为网关不同，分属不同网段，理论上这两个网络内的 docker 容器之间是不能通信的</p>
<p>不过如果要实现容器间跨 docker 网关通信，可以将容器 A 加入到另一个 docker 网络（网关），这样容器 A 就能和加入的 docker 网络内所有容器通信。原理很简单，容器加入另一个网络本质上就是给容器在另一个网络分配一个子网 ip</p>
<p>命令：<code>docker network connect mynet mycontainer</code></p>
<h1 id="docker-的优势"><a href="#docker-的优势" class="headerlink" title="docker 的优势"></a>docker 的优势</h1><p>Docker 在运维上的优势可以类比 Java 语言：</p>
<ul>
<li>Java 可以一次编译到处运行，Docker 实现了一次构建(镜像)，到处运行(整个应用及其依赖)</li>
<li>Java 的 JVM 屏蔽了不同 OS 的差异，Docker 的 Daemon 屏蔽了不同 OS 发行版，不同机器的环境差异</li>
<li>Java 的字节码只要有 JDK 环境就能跑起来，且行为一致，Docker 的镜像只要有 Daemon 环境就能跑起来，且行为一致。两者内部都有清晰定义的格式，且自成规范</li>
<li>Java 使得开发者不需要针对不同的 OS 编程和编译，只要在任意一个 JDK 环境中编程和编译，即可交付可运行于任意 JDK 环境的 jar 包；Docker 使得开发者不需要针对不同的 OS 打不同的发行包，只要在任意一个 Daemon 环境中打包调试好，就可以交付可运行于任意 Daemon 环境的镜像</li>
</ul>
<p>类比 Java 微服务架构，一个应用一个 jar 包，连 tomcat 都打包在 jar 中。只要有 jdk 环境就能一键跑起来。而不像之前除了 jdk 之外还要有 web 容器；开发者从交付一个 war 包，到交付一个包含 web 容器的 jar，打包了 jvm 之上的所有依赖栈。这显然是在 Java 的世界里借鉴了 Docker 的思想，微服务的 jar 包就是 jvm 之上的镜像。Docker 镜像更进一步是打包了内核之上的所有依赖栈，开发者从交付一个代码包到交付一个包括所有依赖栈的镜像。可见从部分交付到整体交付是一种趋势</p>
<h1 id="Dockerfile-中常用指令"><a href="#Dockerfile-中常用指令" class="headerlink" title="Dockerfile 中常用指令"></a>Dockerfile 中常用指令</h1><ul>
<li>FROM：指定基础镜像，必须是第一个指令</li>
<li>ENV：指定运行时的系统环境变量</li>
<li>COPY：可以从 context 中拷贝文件或目录到镜像中<ul>
<li>context 即 dockerFile 所在路径下，一般存放一些应用的启动、自检脚本和环境配置</li>
</ul>
</li>
<li>RUN：执行任意 shell 指令</li>
<li>ENTRYPOINT：容器启动时自动执行的脚本，我们一般会将应用启动脚本放在这里，相当于系统自启应用</li>
<li>VOLUME：指定容器内的目录挂载到宿主机上面,为了能够保存（持久化）数据以及共享容器间的数据，为了实现数据共享，例如日志文件共享到宿主机或容器间共享数据</li>
<li>USER：用指定用户执行这条指令后面的所有指令</li>
</ul>
<h1 id="docker-build-的执行过程"><a href="#docker-build-的执行过程" class="headerlink" title="docker build 的执行过程"></a>docker build 的执行过程</h1><p>docker build 用于构建镜像：</p>
<ul>
<li>读取 Dockerfile 文件发送到 docker daemon<ul>
<li>docker 是 C&#x2F;S 架构，docker 客户端发送 Dockerfile 到服务端 docker daemon</li>
</ul>
</li>
<li>读取当前目录的所有文件（docker build 的 context），打成 tar 包，发送到 docker daemon<ul>
<li>因此不要将 Dockerfile 放到你项目根目录</li>
</ul>
</li>
<li>对 Dockerfile 进行解析，处理成命令加上对应参数的结构</li>
<li>按照顺序循环遍历所有的命令，对每个命令调用对应的处理函数进行处理<ul>
<li>一定包含一个 COPY 命令，把构建出的应用主包（压缩的 tgz 包）复制到镜像指定目录下，所以在 docker build 前，应用需要先编译构建完成</li>
</ul>
</li>
<li>每个命令（除了 FROM）都会在一个容器执行，执行的结果会生成一个新的镜像，为最后生成的镜像打上标签</li>
</ul>
<h2 id="加速构建镜像的技巧"><a href="#加速构建镜像的技巧" class="headerlink" title="加速构建镜像的技巧"></a>加速构建镜像的技巧</h2><ul>
<li>把不常变化的部分打成一个基础镜像上传到仓库，然后其它的 Dockerfile FROM 这个基础镜像<ul>
<li>构建机会从 docker 仓库 pull 基础镜像，当构建机上的基础镜像已是最新时，不会重拉基础镜像（类似 git pull）。这样每次打包就只执行变化的部分，不需要把整个镜像都 build 一遍</li>
<li>一般不变的部分是 OS 基础镜像，应用依赖的 rpm 包，应用容器配置，web 服务器配置等，这些往往写在基础镜像的 Dockerfile 里</li>
<li>变化的部分一般是应用主包这些，放在日常、预发、线上环境有各自的 Dockerfile，它们都 FROM 共同的基础镜像，这样能加速各个环境下的镜像构建过程</li>
<li>其实各个环境下的 dockerFile 即使不 From 基础镜像，在 build 时会通过命令的 md5 从缓存取镜像（镜像是分层存储的，每个命令执行完都对应一层镜像），也避免了重复构建<ul>
<li>不过一旦从 md5 取不到缓存，后面的命令都用不到 cache，因此需要保证将不变的镜像构建指令放到前面，把每次都变化的部分（例如应用主包复制）放到后面</li>
</ul>
</li>
</ul>
</li>
<li>dockerFile 目录下增加.dockerignore 文件<ul>
<li>格式和.gitignore 文件一样，排除不需要加入 docker build context 中的文件来加快 build 速度</li>
</ul>
</li>
<li>避免安装不需要的包到镜像中<ul>
<li>有很多基线中都写了不需要的包，应用开发需要确定一下哪些包是确实需要的，不要把安装不需要的包</li>
</ul>
</li>
<li>减少镜像层<ul>
<li>可以把多个指令合并成一个指令来减少镜像层</li>
</ul>
</li>
</ul>
<h1 id="容器生命周期中用户的可定制点"><a href="#容器生命周期中用户的可定制点" class="headerlink" title="容器生命周期中用户的可定制点"></a>容器生命周期中用户的可定制点</h1><ul>
<li>修改 dockerFile</li>
<li>指定应用启动、自检、停止时的执行脚本<ul>
<li>脚本放在 dockerFile 上下文路径下</li>
<li>dockerFile 里重定向上下文路径里的启动、自检、停止脚本到 docker 镜像指定目录</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习rocketMq-基础篇</title>
    <url>/2020/12/22/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketMq-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>nameServer</p>
<ul>
<li>用于服务发现，producer与consumer都会从nameServer获取Topic对应的broker，从而将消息发送至broker或者从broker获取消息，producer与consumer都会与nameServer保持长连接并通过心跳包告知状态</li>
</ul>
<p>producer</p>
<ul>
<li>消息生产者，负责产生消息并发送消息到broker，根据topic从nameServer获取对应的broker信息，如果存在多个broker都持有相同topic做负载均衡的话，producer会轮询发送消息，而不是将消息全部发送至一个broker中</li>
</ul>
<p>producer group</p>
<ul>
<li>同一组producer集合，称为producer集群</li>
</ul>
<p>consumer</p>
<ul>
<li>消息消费者</li>
</ul>
<p>consumer group</p>
<ul>
<li>同一组consumer集合，称为consumer集群，需要注意的是一个消费者集群中的订阅关系应该要保持一致，订阅关系一致指的是消费集群下所有Consumer实例订阅的消息Topic、Tag必须完全一致</li>
</ul>
<p>broker</p>
<ul>
<li>rocketmq的服务器，负责接收并存储producer发送来的消息，并会发送如存储消息的队列信息等数据到nameServer完成注册</li>
</ul>
<p>topic</p>
<ul>
<li>消息的主题，通常表示消息的业务含义，用于区分不同消息</li>
<li>同一topic下的消息，实际中可能<code>负载均衡</code>到不同broker存储，这称为topic分片</li>
</ul>
<p>CommitLog</p>
<ul>
<li>broker将消息写入文件CommitLog。消息进入broker后，按照顺序先写入commitLog(不进行长度和Topic的区分)，文件命名为起始字节位置，默认大小为1G，写满后会自动产生新的数据文件。一旦落盘成功，消息便完成了持久化，不会丢失</li>
<li>消息持久化分为<code>同步刷盘</code>和<code>异步刷盘</code>（默认）两种方式，异步刷盘默认N秒强制刷盘一次，每M条强制刷盘一次，所以理论上某broker宕机瞬间历史的消息损失数量会在M条以内</li>
</ul>
<p>MessageQueue</p>
<ul>
<li>broker有多个MessageQueue存储消息的索引信息，包括在CommitLog上的offset、msgSize、tagHashCode。每个topic在broker上会有几个固定的MessageQueue，该topic下的每条消息的索引会随机存储到其中一个MessageQueue上，或者按Producer指定的分片规则路由存储到某个MessageQueue。Consumer按MessageQueue维度消费消息，任何时刻MessageQueue里的消息只能被同一个消费组下的某个Consumer实例消费</li>
</ul>
<p>设计MessageQueue有两个作用：</p>
<ul>
<li>为了消费者的<code>负载均衡</code>。每个MessageQueue只会由一个consumer消费，如果MessageQueue数目大于consumerGroup的集群数，每个Consumer可能消费多个MessageQueue，反之，有的Consumer不会消费<ul>
<li>个人认为，不仅是负载均衡，还有两个原因：<ul>
<li><code>并行消费</code>的思想，多个消费者可以并发消费一个broker的消息，提高吞吐量</li>
<li>降低复杂度。如果多个consumer从同一个broker取该topic的消息，只有一个队列很难保证一条消息只会被一个consumer取走消费，极有可能出现重复消费，不易实现集群模式</li>
</ul>
</li>
<li>rocketmq消费模式有<code>集群模式</code>和<code>广播模式</code>。集群模式下每条消息只会被ConsumerGroup中的一个Consumer消费，一般也使用这种模式，上面说的“每个MessageQueue只会由一个consumer消费”也是针对这种模式。广播模式指的是消息会被集群中的每个Consumer消费，且不具备失败重投能力，一般不用</li>
</ul>
</li>
<li>实现<code>顺序消费</code><ul>
<li>消息发布时，可以实现<code>MessageQueueSelector</code>，选择消息要投递到哪个MessageQueue。由于每个MessageQueue只会被一个Consumer消费，这就保证了消息会被顺序消费<ul>
<li>相比乱序消息，顺序消息丧失了消息发送和消息消费中的负载均衡策略，且一旦有消息消费失败，会阻塞后续消息，造成消息堆积</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="消息发布流程"><a href="#消息发布流程" class="headerlink" title="消息发布流程"></a>消息发布流程</h1><p>对于乱序消息，Producer从nameserver获取要发布的Topic对应master broker地址列表，使用轮询的方式选择broker建立长连接，定时发送心跳。选择好broker发布消息时，因为broker中topic有多个MessageQueue，负载均衡策略是，将所有broker里面所有MessageQueue组成一个圈，按从头到尾循环遍历选择消息队列发送消息。</p>
<ul>
<li>broker列表即存储该topic消息的broker集群 </li>
<li>对于顺序消息，Producer发送消息时会投递到指定的MessageQueue</li>
</ul>
<h1 id="消息消费流程"><a href="#消息消费流程" class="headerlink" title="消息消费流程"></a>消息消费流程</h1><p>consumer从nameserver获取topic的broker集群列表，按均分的负载均衡策略选择topic的一些消费队列，然后从这些消费队列中获取消息索引，再到commitLog获取消息体</p>
<ul>
<li>consumer已选择的消费队列不能同时被其他consumer消费</li>
<li>rocketmq同时支持推模式和拉模式的消息订阅方式</li>
</ul>
<h2 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h2><p>拉模式就是短轮询，由消费者设定轮询频次，每次轮询请求新消息，broker直接将结果返回。适合于慢消费（生产速度大于消费速度）场景，每次都能拉取到新消息。但实际上，轮询的频率往往无法很好的适应消息生产的频率，频率太小将导致消息推挤在Broker中，频率太大的话增加系统负担、产生无谓的网络开销</p>
<h2 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h2><p>推模式本质是长轮询，它能以较低的成本保证消息能被及时消费。实际开发中往往使用推模式<br>broker在没有数据时会暂存消费者的请求而不是返回结果。当有新消息或超过请求的hold时间，才发送结果给消费者<br>消费者通过requestId识别是哪次消息拉取请求，再执行回调方法消费消息，并发送下一次长轮询</p>
<h1 id="消息重复投递"><a href="#消息重复投递" class="headerlink" title="消息重复投递"></a>消息重复投递</h1><p>消息重复投递一直是消息中间件很难避免的问题，通常在网络异常时会发生消息重复投递的现象，例如Producer成功将消息投递到了服务端，而服务端返回的确认消息由于网络原因没有回传成功，则Producer认为发布消息失败会重新发布一样的消息导致重复；同样在broker向Consumer成功发送消息后，由于网络原因Consumer回传的消息没有发送到broker，使得broker认为消息投递失败，重投后导致了重复消息。</p>
<p>因此消费者需要对重复消息做幂等</p>
<h1 id="rocketMq架构的简单示意图"><a href="#rocketMq架构的简单示意图" class="headerlink" title="rocketMq架构的简单示意图"></a>rocketMq架构的简单示意图</h1><p><img src="/images/rocketmq1.png"></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习threadLocal</title>
    <url>/2020/04/23/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0threadLocal/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>提供本地线程变量。放在threadLocal的内容只能被当前线程看到</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>简单理解就是每个Thread都有一个ThreadLocalMap变量，这个变量里维护了threadLocal对象和value的映射关系，threadLocal的get&#x2F;set方法，其实都是操作的当前线程的threadLocalMap变量</p>
<p>ThreadLocalMap本质是一个Entry数组，看下它的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            /** The value associated with this ThreadLocal. */</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private Entry[] table;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>每个entry维护了一个threadLocal对象和value的映射关系，Entry有两点需要说明：</p>
<ul>
<li>entry对象是一个指向threadLocal对象的弱引用，还负责维护value值</li>
<li>entry数组的下标与threadLocal对象的hashCode值强绑定</li>
</ul>
<p>第一点从Entry类定义就能知道，第二点看一下threadLocal的set方法就能明白</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">            for (Entry e = tab[i];</span><br><span class="line">                 e != null;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                if (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = new Entry(key, value);</span><br><span class="line">            int sz = ++size;</span><br><span class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>threadlocal的set方法：<br>构建一个弱引用entry，指向threadLocal对象，value为set的值，丢到当前线程threadLocalMap的entry数组里，下标基于threadLocal的hashCode计算得到</p>
<p>threadlocal的get方法简单总结如下，不贴代码了：<br>拿到当前线程的threadLocalMap，根据threadLocal的hash值取出entry数组里对应的entry，再拿到value</p>
<h1 id="threadlocal的OOM问题"><a href="#threadlocal的OOM问题" class="headerlink" title="threadlocal的OOM问题"></a>threadlocal的OOM问题</h1><p>先说一个结论：<code>如果只有弱引用指向这个对象，在下一次gc时，这个对象会被gc！</code><br>当threadLocal对象只被弱引用entry对象引用时，下一次gc就会回收threadlocal对象。当threadLocal被gc后，指向它的弱引用entry对象并不会被gc，因为<code>thread--&gt;threadLocalMap--&gt;entry[]</code>这个引用链都是强引用。但entry.value永远无法被访问，为什么呢？<br>前面说过，entry数组的下标基于threadLocal对象的hashCode计算得到，既然threadLocal被gc，那么这个entry对象就无法被访问，entry.value也就无法被访问。直到thread执行结束被gc时，entry对象才会被gc。如果内存中有很多这种entry对象，会存在OOM的风险。</p>
<p>思考：<br>为什么entry要用弱引用指向threadLocal？<br>很简单，因为只有entry用弱引用，当threadLocal被gc时，我们才能感知到，然后把entry也gc！否则，entry用强引用，只有线程退出了，entry才会被gc，更容易OOM！用软引用也不行，软引用只有当OOM时，才会将不在其他地方被引用的threadLocal给gc了，这被感知到时已经为时已晚了！</p>
<p>解决办法：<br>jvm会在每次调用threadLocal.set\get\remove方法时，会把这些entry（弱引用指向的threadlocal被回收）对象gc，这里不去深究，不过好的习惯是在finally块里手动调用threadLocal.remove来主动触发无效entry的gc</p>
<h1 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h1><p>简单理解它就是一种父子线程可共享的threadLocal<br>Thread除了threadLocals维护threadLocal，还有一个inheritableThreadLocals，维护可被子线程共享的threadLocal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="line"> * maintained by the InheritableThreadLocal class.</span><br><span class="line"> */</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></pre></td></tr></table></figure>

<p>如果线程使用InheritableThreadLocal，调用InheritableThreadLocal的createMap方法时会维护到thread.inheritableThreadLocals</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，只有在子线程创建的时候，构造函数里会去父线程的inheritableThreadLocals拷贝一份到自己的inheritableThreadLocals，之后父线程set的inheritableThreadLocal值不会被子线程获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">            this.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习rocketmq源码</title>
    <url>/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/mq/rocketmq%E6%9E%B6%E6%9E%84.png"></p>
<h1 id="客户端注册-rocketmq-组件"><a href="#客户端注册-rocketmq-组件" class="headerlink" title="客户端注册 rocketmq 组件"></a>客户端注册 rocketmq 组件</h1><p>如果是 sb 应用，rocketmq 提供 starter 方式自动装配 bean，需要引入依赖：rocketmq-spring-boot<br>spring.factories 文件里指定配置类<code>RocketMQAutoConfiguration</code>，由它注册 producer 和 consumer bean 到 bf</p>
<h2 id="注册-producer"><a href="#注册-producer" class="headerlink" title="注册 producer"></a>注册 producer</h2><ul>
<li>通过<code>@EnableConfigurationProperties(RocketMQProperties.class)</code>注册应用配置绑定 bean：<code>RocketMQProperties</code>，该 bean 包含了应用配置文件里对 rocketmq 的配置信息，producer 和 consumer 在创建过程中都通过该 bean 拿到并注入这些全局配置参数<ul>
<li>应用配置里 rocketmq 必备的配置项是 name-server(ns 地址)</li>
<li>如果指定了 producer.group 会创建 producer 实例</li>
<li>如果指定了 pull-consumer.group 和 pull-consumer.topic，会创建 consumer 实例</li>
</ul>
</li>
<li>producer 实例类型是<code>DefaultMQProducer</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean(PRODUCER_BEAN_NAME)</span><br><span class="line">@ConditionalOnMissingBean(DefaultMQProducer.class)</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;</span><br><span class="line">    &quot;name-server&quot;,</span><br><span class="line">    &quot;producer.group&quot;</span><br><span class="line">&#125;) public DefaultMQProducer defaultMQProducer(RocketMQProperties rocketMQProperties) &#123;</span><br><span class="line">    RocketMQProperties.Producer producerConfig = rocketMQProperties.getProducer();</span><br><span class="line">    String nameServer = rocketMQProperties.getNameServer();</span><br><span class="line">    String groupName = producerConfig.getGroup();</span><br><span class="line">    Assert.hasText(nameServer, &quot;[rocketmq.name-server] must not be null&quot;);</span><br><span class="line">    Assert.hasText(groupName, &quot;[rocketmq.producer.group] must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    String accessChannel = rocketMQProperties.getAccessChannel();</span><br><span class="line"></span><br><span class="line">    String ak = rocketMQProperties.getProducer().getAccessKey();</span><br><span class="line">    String sk = rocketMQProperties.getProducer().getSecretKey();</span><br><span class="line">    boolean isEnableMsgTrace = rocketMQProperties.getProducer().isEnableMsgTrace();</span><br><span class="line">    String customizedTraceTopic = rocketMQProperties.getProducer().getCustomizedTraceTopic();</span><br><span class="line"></span><br><span class="line">    DefaultMQProducer producer = RocketMQUtil.createDefaultMQProducer(groupName, ak, sk, isEnableMsgTrace, customizedTraceTopic);</span><br><span class="line"></span><br><span class="line">    producer.setNamesrvAddr(nameServer);</span><br><span class="line">    if (!StringUtils.isEmpty(accessChannel)) &#123;</span><br><span class="line">        producer.setAccessChannel(AccessChannel.valueOf(accessChannel));</span><br><span class="line">    &#125;</span><br><span class="line">    producer.setSendMsgTimeout(producerConfig.getSendMessageTimeout());</span><br><span class="line">    producer.setRetryTimesWhenSendFailed(producerConfig.getRetryTimesWhenSendFailed());</span><br><span class="line">    producer.setRetryTimesWhenSendAsyncFailed(producerConfig.getRetryTimesWhenSendAsyncFailed());</span><br><span class="line">    producer.setMaxMessageSize(producerConfig.getMaxMessageSize());</span><br><span class="line">    producer.setCompressMsgBodyOverHowmuch(producerConfig.getCompressMessageBodyThreshold());</span><br><span class="line">    producer.setRetryAnotherBrokerWhenNotStoreOK(producerConfig.isRetryNextServer());</span><br><span class="line">    producer.setUseTLS(producerConfig.isTlsEnable());</span><br><span class="line">    producer.setNamespace(producerConfig.getNamespace());</span><br><span class="line">    producer.setInstanceName(producerConfig.getInstanceName());</span><br><span class="line">    log.info(String.format(&quot;a producer (%s) init on namesrv %s&quot;, groupName, nameServer));</span><br><span class="line">    return producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册-consumer"><a href="#注册-consumer" class="headerlink" title="注册 consumer"></a>注册 consumer</h2><ul>
<li>consumer 实例类型是<code>DefaultLitePullConsumer</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean(CONSUMER_BEAN_NAME)@ConditionalOnMissingBean(DefaultLitePullConsumer.class)@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;</span><br><span class="line">    &quot;name-server&quot;,</span><br><span class="line">    &quot;pull-consumer.group&quot;,</span><br><span class="line">    &quot;pull-consumer.topic&quot;</span><br><span class="line">&#125;) public DefaultLitePullConsumer defaultLitePullConsumer(RocketMQProperties rocketMQProperties) throws MQClientException &#123;</span><br><span class="line">    RocketMQProperties.PullConsumer consumerConfig = rocketMQProperties.getPullConsumer();</span><br><span class="line">    String nameServer = rocketMQProperties.getNameServer();</span><br><span class="line">    String groupName = consumerConfig.getGroup();</span><br><span class="line">    String topicName = consumerConfig.getTopic();</span><br><span class="line">    Assert.hasText(nameServer, &quot;[rocketmq.name-server] must not be null&quot;);</span><br><span class="line">    Assert.hasText(groupName, &quot;[rocketmq.pull-consumer.group] must not be null&quot;);</span><br><span class="line">    Assert.hasText(topicName, &quot;[rocketmq.pull-consumer.topic] must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    String accessChannel = rocketMQProperties.getAccessChannel();</span><br><span class="line">    MessageModel messageModel = MessageModel.valueOf(consumerConfig.getMessageModel());</span><br><span class="line">    SelectorType selectorType = SelectorType.valueOf(consumerConfig.getSelectorType());</span><br><span class="line">    String selectorExpression = consumerConfig.getSelectorExpression();</span><br><span class="line">    String ak = consumerConfig.getAccessKey();</span><br><span class="line">    String sk = consumerConfig.getSecretKey();</span><br><span class="line">    int pullBatchSize = consumerConfig.getPullBatchSize();</span><br><span class="line">    boolean useTLS = consumerConfig.isTlsEnable();</span><br><span class="line"></span><br><span class="line">    DefaultLitePullConsumer litePullConsumer = RocketMQUtil.createDefaultLitePullConsumer(nameServer, accessChannel, groupName, topicName, messageModel, selectorType, selectorExpression, ak, sk, pullBatchSize, useTLS);</span><br><span class="line">    litePullConsumer.setEnableMsgTrace(consumerConfig.isEnableMsgTrace());</span><br><span class="line">    litePullConsumer.setCustomizedTraceTopic(consumerConfig.getCustomizedTraceTopic());</span><br><span class="line">    litePullConsumer.setNamespace(consumerConfig.getNamespace());</span><br><span class="line">    litePullConsumer.setInstanceName(consumerConfig.getInstanceName());</span><br><span class="line">    log.info(String.format(&quot;a pull consumer(%s sub %s) init on namesrv %s&quot;, groupName, topicName, nameServer));</span><br><span class="line">    return litePullConsumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册-RocketMQTemplate"><a href="#注册-RocketMQTemplate" class="headerlink" title="注册 RocketMQTemplate"></a>注册 RocketMQTemplate</h2><p>客户端不直接持有 producer 和 consumer，而是通过 RocketMQTemplate，该 bean 注册时从 bf 拿到 producer 和 consumer 实例并注入，然后在初始化阶段调用它们的 start 方法，启动 producer 和 consumer 实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean(destroyMethod = &quot;destroy&quot;)</span><br><span class="line">@Conditional(ProducerOrConsumerPropertyCondition.class)</span><br><span class="line">@ConditionalOnMissingBean(name = ROCKETMQ_TEMPLATE_DEFAULT_GLOBAL_NAME)</span><br><span class="line">public RocketMQTemplate rocketMQTemplate(RocketMQMessageConverter rocketMQMessageConverter) &#123;</span><br><span class="line">    RocketMQTemplate rocketMQTemplate = new RocketMQTemplate();</span><br><span class="line">    if (applicationContext.containsBean(PRODUCER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setProducer((DefaultMQProducer) applicationContext.getBean(PRODUCER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    if (applicationContext.containsBean(CONSUMER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setConsumer((DefaultLitePullConsumer) applicationContext.getBean(CONSUMER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    rocketMQTemplate.setMessageConverter(rocketMQMessageConverter.getMessageConverter());</span><br><span class="line">    return rocketMQTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    if (producer != null) &#123;</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    if (Objects.nonNull(consumer)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;Failed to startup PullConsumer for RocketMQTemplate&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动-producer-实例"><a href="#启动-producer-实例" class="headerlink" title="启动 producer 实例"></a>启动 producer 实例</h1><p>入口：org.apache.rocketmq.client.producer.DefaultMQProducer#start</p>
<p>调用 start 方法前，已经完成了 DefaultMQProducer 的实例化，在构造函数里设置一些默认的发送者配置信息，同时 new 了一个内部发送者实例<code>DefaultMQProducerImpl</code>，它们互相持有彼此的引用。配置信息包括：</p>
<ul>
<li>发送消息超时时间（默认 3 秒）</li>
<li>需要压缩的消息大小阈值（默认 4K）</li>
<li>发送消息失败后的重试次数（默认 2 次，不过这可能造成 consumer 收到重复消息）</li>
<li>发送消息的最大字节数（默认 4M）</li>
<li>producerGroupName，作为构造参数传入</li>
<li>mq 客户端信息，例如实例名、客户端 ip、ns 地址等<ul>
<li>定义在 <code>ClientConfig</code>，DefaultMQProducer 继承该类</li>
</ul>
</li>
</ul>
<p>需要注意，通过上面注册阶段的分析可知，发送者配置信息可以被应用配置文件里的配置覆盖。<br>不过应用配置里一般是定义一些 producer 和 consumer 个性化参数，对于一些敏感信息，例如实例名、客户端 ip、ns 地址等，我们一般沿用 ClientConfig 的实现而不在应用配置文件里指定。<br>ClientConfig 设置实例名和 ns 地址都通过系统属性获取，我们可以在应用启动脚本里设置这些系统属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultMQProducer(String namespace, String producerGroup, RPCHook rpcHook) &#123;</span><br><span class="line">    this.log = ClientLogger.getLog();</span><br><span class="line">    this.retryResponseCodes = new CopyOnWriteArraySet(Arrays.asList(17, 14, 1, 16, 204, 205));</span><br><span class="line">    this.createTopicKey = &quot;TBW102&quot;;</span><br><span class="line">    this.defaultTopicQueueNums = 4;</span><br><span class="line">    this.sendMsgTimeout = 3000;</span><br><span class="line">    this.compressMsgBodyOverHowmuch = 4096;</span><br><span class="line">    this.retryTimesWhenSendFailed = 2;</span><br><span class="line">    this.retryTimesWhenSendAsyncFailed = 2;</span><br><span class="line">    this.retryAnotherBrokerWhenNotStoreOK = false;</span><br><span class="line">    this.maxMessageSize = 4194304;</span><br><span class="line">    this.traceDispatcher = null;</span><br><span class="line">    this.namespace = namespace;</span><br><span class="line">    this.producerGroup = producerGroup;</span><br><span class="line">    this.defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultMQProducer 的 start 方法又会调用内部发送者 DefaultMQProducerImpl 的 start 方法，即 <code>producer 的启动流程实际是启动 DefaultMQProducerImpl</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start() throws MQClientException &#123;</span><br><span class="line">    ...</span><br><span class="line">    this.defaultMQProducerImpl.start();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面具体看 DefaultMQProducerImpl 的 start 流程</p>
<h2 id="处理-mqClient-实例名"><a href="#处理-mqClient-实例名" class="headerlink" title="处理 mqClient 实例名"></a>处理 mqClient 实例名</h2><p>ClientConfig 设置了全局的实例名，默认取系统环境变量，缺省值 DEFAULT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;);</span><br></pre></td></tr></table></figure>

<p>sb 应用的配置文件里也可以指定 producer 所属 client 的实例名，该优先级更高。如果没指定，缺省也是 DEFAULT。<br>如果实例名为 DEFAULT，这里会修改实例名，改成：”{进程 pid}#{时间戳}” 这种格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void changeInstanceNameToPID() &#123;</span><br><span class="line">    if (this.instanceName.equals(&quot;DEFAULT&quot;)) &#123;</span><br><span class="line">        this.instanceName = UtilAll.getPid() + &quot;#&quot; + System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化-mqClient"><a href="#实例化-mqClient" class="headerlink" title="实例化 mqClient"></a>实例化 mqClient</h2><p><code>MQClientInstance</code>表示 mqClient 实例。<code>MQClientManager</code>是<code>MQClientInstance</code>的工厂，缓存已创建的<code>MQClientInstance</code>，Key 为{ip}#{mqClient 的实例名}，如果没有在环境变量或应用配置里指定 mqClient 实例名，则这里的 key 为：{ip}#{进程 pid}#{时间戳}。注意这时带了时间戳参数，因此有如下结论：</p>
<ul>
<li>如果没有指定 mq 客户端名，每个 producer 实例在启动时都会新建一个 mqClient</li>
<li>如果系统配置里指定了 mq 客户端名，所有 producer 共用一个 mqClient</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mQClientFactory的类型就是MQClientInstance</span><br><span class="line">this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) &#123;</span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    MQClientInstance instance = this.factoryTable.get(clientId);</span><br><span class="line">    if (null == instance) &#123;</span><br><span class="line">        instance = new MQClientInstance(clientConfig.cloneClientConfig(), this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="producer-注册到-mqClient"><a href="#producer-注册到-mqClient" class="headerlink" title="producer 注册到 mqClient"></a>producer 注册到 mqClient</h2><p><code>DefaultMQProducerImpl</code>注册到<code>MQClientInstance</code></p>
<ul>
<li>mqClient 按 group 维度管理 producer、consumer 实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized boolean registerProducer(String group, DefaultMQProducerImpl producer) &#123;</span><br><span class="line">    if (null != group &amp;&amp; null != producer) &#123;</span><br><span class="line">        MQProducerInner prev = (MQProducerInner) this.producerTable.putIfAbsent(group, producer);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            this.log.warn(&quot;the producer group[&#123;&#125;] exist already.&quot;, group);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动-MQClientInstance"><a href="#启动-MQClientInstance" class="headerlink" title="启动 MQClientInstance"></a>启动 MQClientInstance</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.mQClientFactory.start();</span><br></pre></td></tr></table></figure>

<h3 id="更新-ns-地址"><a href="#更新-ns-地址" class="headerlink" title="更新 ns 地址"></a>更新 ns 地址</h3><p>获取 nameserver 服务器地址（url+端口号）。ns 地址的获取优先级是：</p>
<ul>
<li>优先使用应用配置文件里指定的 ns 地址。在 bean 加载阶段会覆盖 ClientConfig 里 ns 的默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean(PRODUCER_BEAN_NAME)@ConditionalOnMissingBean(DefaultMQProducer.class)@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;</span><br><span class="line">    &quot;name-server&quot;,</span><br><span class="line">    &quot;producer.group&quot;</span><br><span class="line">&#125;) public DefaultMQProducer defaultMQProducer(RocketMQProperties rocketMQProperties) &#123;</span><br><span class="line">    RocketMQProperties.Producer producerConfig = rocketMQProperties.getProducer();</span><br><span class="line">    String nameServer = rocketMQProperties.getNameServer();</span><br><span class="line">    ...</span><br><span class="line">    producer.setNamesrvAddr(nameServer);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其次使用 ClientConfig 的 ns 默认值。它取了系统环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String namesrvAddr = NameServerAddressUtils.getNameServerAddresses();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String getNameServerAddresses() &#123;</span><br><span class="line">    return System.getProperty(&quot;rocketmq.namesrv.addr&quot;, System.getenv(&quot;NAMESRV_ADDR&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果前面都没拿到 ns 地址，向 ns 源服务器地址（也在系统环境变量配置，有缺省值）发起 http 请求，获取 ns 服务器地址<ul>
<li>rocketmq 提供了缺省的 ns 源服务器地址：<a href="http://jmenv.tbsite.net:8080/rocketmq/nsaddr">http://jmenv.tbsite.net:8080/rocketmq/nsaddr</a></li>
<li>拿到 ns 地址更新到 nettyClient</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (null == this.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">    this.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取系统属性配置的ns源服务器地址</span><br><span class="line">public static String getWSAddr() &#123;</span><br><span class="line">    String wsDomainName = System.getProperty(&quot;rocketmq.namesrv.domain&quot;, DEFAULT_NAMESRV_ADDR_LOOKUP);</span><br><span class="line">    String wsDomainSubgroup = System.getProperty(&quot;rocketmq.namesrv.domain.subgroup&quot;, &quot;nsaddr&quot;);</span><br><span class="line">    String wsAddr = &quot;http://&quot; + wsDomainName + &quot;:8080/rocketmq/&quot; + wsDomainSubgroup;</span><br><span class="line">    if (wsDomainName.indexOf(&quot;:&quot;) &gt; 0) &#123;</span><br><span class="line">        wsAddr = &quot;http://&quot; + wsDomainName + &quot;/rocketmq/&quot; + wsDomainSubgroup;</span><br><span class="line">    &#125;</span><br><span class="line">    return wsAddr;</span><br><span class="line">&#125;...</span><br><span class="line">// 向ns源服务器地址发起http请求，获取ns服务器地址</span><br><span class="line">String url = this.wsAddr;</span><br><span class="line">HttpTinyClient.HttpResult result = HttpTinyClient.httpGet(url, null, null, &quot;UTF-8&quot;, timeoutMills);</span><br><span class="line">if (200 == result.code) &#123;</span><br><span class="line">    String responseStr = result.content;</span><br><span class="line">    if (responseStr != null) &#123;</span><br><span class="line">        return clearNewLine(responseStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;...</span><br><span class="line">// 注册ns服务器地址到nettyClient</span><br><span class="line">String[] addrArray = addrs.split(&quot;;&quot;);</span><br><span class="line">List &lt; String &gt; list = Arrays.asList(addrArray);</span><br><span class="line">this.remotingClient.updateNameServerAddressList(list);</span><br></pre></td></tr></table></figure>

<h3 id="启动-MQClientAPIImpl"><a href="#启动-MQClientAPIImpl" class="headerlink" title="启动 MQClientAPIImpl"></a>启动 MQClientAPIImpl</h3><p><code>MQClientAPIImpl</code>封装了通信接口给 mqClient 使用，它内部使用 Netty 通信。它的 start 方法会调用<code>NettyRemotingClient</code>的 start 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    this.remotingClient.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyRemotingClient 的 start 方法主要做了 2 件事。</p>
<h4 id="初始化-netty-客户端"><a href="#初始化-netty-客户端" class="headerlink" title="初始化 netty 客户端"></a>初始化 netty 客户端</h4><ul>
<li>初始化客户端 netty 环境，核心是添加 rocketmq 定义的网络通信 IO 数据的处理类 handler。需要注意的是：<ul>
<li>nioEventLoopGroup 在 NettyRemotingClient 的构造函数里实例化，只指定了一个 nioEventLoop 线程</li>
<li>为 IO 数据处理 handler 指定线程池来异步执行，提高 nioEventLoop 的线程利用率</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 为 IO 数据处理 handler 指定线程池来异步执行，提高 nioEventLoop 的线程利用率</span><br><span class="line">this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(nettyClientConfig.getClientWorkerThreads(), new ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger threadIndex = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Override public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;NettyClientWorkerThread_&quot; + this.threadIndex.incrementAndGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// nioEventLoopGroup在NettyRemotingClient的构造函数里实例化，只指定了一个 nioEventLoop 线程</span><br><span class="line">Bootstrap handler = this.bootstrap.group(this.eventLoopGroupWorker).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true).option(ChannelOption.SO_KEEPALIVE, false).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, nettyClientConfig.getConnectTimeoutMillis()).option(ChannelOption.SO_SNDBUF, nettyClientConfig.getClientSocketSndBufSize()).option(ChannelOption.SO_RCVBUF, nettyClientConfig.getClientSocketRcvBufSize()).handler(new ChannelInitializer &lt; SocketChannel &gt; () &#123;@Override public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        if (nettyClientConfig.isUseTLS()) &#123;</span><br><span class="line">            if (null != sslContext) &#123;</span><br><span class="line">                pipeline.addFirst(defaultEventExecutorGroup, &quot;sslHandler&quot;, sslContext.newHandler(ch.alloc()));</span><br><span class="line">                log.info(&quot;Prepend SSL handler&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.warn(&quot;Connections are insecure as SSLContext is null!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.addLast(defaultEventExecutorGroup, new NettyEncoder(), new NettyDecoder(), new IdleStateHandler(0, 0, nettyClientConfig.getClientChannelMaxIdleTimeSeconds()), new NettyConnectManageHandler(), new NettyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="定时清理过期的-ResponseFuture"><a href="#定时清理过期的-ResponseFuture" class="headerlink" title="定时清理过期的 ResponseFuture"></a>定时清理过期的 ResponseFuture</h4><ul>
<li>启动一个定时器，每隔 1 秒从 responseTable 移除已经超时的异步结果接收对象 ResponseFuture，并在 callback 线程池里提交任务，执行处理结果的 callback 方法<ul>
<li>nioEventLoop 执行业务 handler 的异步线程里解析响应，然后从 responseTable 根据 reqId 取出 ResponseFuture 并放入响应，再提交任务到线程池，回调 callback 方法处理结果。所以如果长时间没有新消息，responseTable 内存会一直存储接收结果的 ResponseFuture 对象，因此需要定时从 responseTable 清理过期的请求数据</li>
<li>callback 方法在固定线程数的线程池中执行，线程池数目取 cpu 核数，且最大不超过 4。see：org.apache.rocketmq.remoting.netty.NettyRemotingClient#publicExecutor</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.timer.scheduleAtFixedRate(new TimerTask() &#123;@Override public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            NettyRemotingClient.this.scanResponseTable();</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.error(&quot;scanResponseTable exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">1000 * 3, 1000);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void scanResponseTable() &#123;</span><br><span class="line">    final List &lt; ResponseFuture &gt; rfList = new LinkedList &lt; ResponseFuture &gt; ();</span><br><span class="line">    Iterator &lt; Entry &lt; Integer,</span><br><span class="line">    ResponseFuture &gt;&gt; it = this.responseTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry &lt; Integer, ResponseFuture &gt; next = it.next();</span><br><span class="line">        ResponseFuture rep = next.getValue();</span><br><span class="line"></span><br><span class="line">        if ((rep.getBeginTimestamp() + rep.getTimeoutMillis() + 1000) &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">            rep.release();</span><br><span class="line">            it.remove();</span><br><span class="line">            rfList.add(rep);</span><br><span class="line">            log.warn(&quot;remove timeout request, &quot; + rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (ResponseFuture rf: rfList) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executeInvokeCallback(rf);</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.warn(&quot;scanResponseTable, operationComplete Exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void executeInvokeCallback(final ResponseFuture responseFuture) &#123;</span><br><span class="line">    boolean runInThisThread = false;</span><br><span class="line">    ExecutorService executor = this.getCallbackExecutor();</span><br><span class="line">    if (executor != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executor.submit(new Runnable() &#123;</span><br><span class="line">                    @Override public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        responseFuture.executeInvokeCallback();</span><br><span class="line">                    &#125; catch(Throwable e) &#123;</span><br><span class="line">                        log.warn(&quot;execute callback in executor exception, and callback throw&quot;, e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        responseFuture.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            runInThisThread = true;</span><br><span class="line">            log.warn(&quot;execute callback in executor exception, maybe executor busy&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        runInThisThread = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runInThisThread) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            responseFuture.executeInvokeCallback();</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.warn(&quot;executeInvokeCallback Exception&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h3><h4 id="定时更新-ns-地址"><a href="#定时更新-ns-地址" class="headerlink" title="定时更新 ns 地址"></a>定时更新 ns 地址</h4><p>如果应用配置文件和系统环境变量都没有指定 ns 地址，使用单一定时线程池中的线程每隔 2 分钟去 ns 源服务器获取最新的 ns 服务器地址，更新到 nettyClient</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (null == this.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                MQClientInstance.this.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                log.error(&quot;ScheduledTask fetchNameServerAddr exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    1000 * 10, 1000 * 60 * 2, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时刷新-topic-消息路由"><a href="#定时刷新-topic-消息路由" class="headerlink" title="定时刷新 topic 消息路由"></a>定时刷新 topic 消息路由</h4><p>定时查询并刷新 mq 客户端发布和订阅的 topic 路由信息。获取所有 producer 和 consumer 发布和订阅的 topic，到 ns 查询 topic 的路由信息。执行频率来自配置，默认 30s 执行一次</p>
<ul>
<li><p>更新 mqClient 的<code>brokerAddrTable</code>、<code>topicRouteTable</code></p>
</li>
<li><p>更新 producer 的 topic 路由信息<code>topicPublishInfoTable</code></p>
<ul>
<li>producer 配置时不指定 topic，而是每次发送消息时去 topicPublishInfoTable 拿当前 topic 的路由信息，如果没有会从 ns 查询并更新到 topicPublishInfoTable</li>
</ul>
</li>
<li><p>更新 consumer 的负载均衡器<code>RebalanceImpl</code>的 topicSubscribeInfoTable</p>
<ul>
<li>consumer 订阅的 topic 从 RebalanceImpl 的 SubscriptionData 取出，构建 SubscriptionData 是在 consumer 实例的 start 方法里完成的</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQClientInstance.this.updateTopicRouteInfoFromNameServer();</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">10, this.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator &lt; Entry &lt; String,</span><br><span class="line">MQConsumerInner &gt;&gt; it = this.consumerTable.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Entry &lt; String,</span><br><span class="line">    MQConsumerInner &gt; entry = it.next();</span><br><span class="line">    MQConsumerInner impl = entry.getValue();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        Set &lt; SubscriptionData &gt; subList = impl.subscriptions();</span><br><span class="line">        if (subList != null) &#123;</span><br><span class="line">            for (SubscriptionData subData: subList) &#123;</span><br><span class="line">                topicList.add(subData.getTopic());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator &lt; Entry &lt; String,</span><br><span class="line">MQProducerInner &gt;&gt; it = this.producerTable.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Entry &lt; String,</span><br><span class="line">    MQProducerInner &gt; entry = it.next();</span><br><span class="line">    MQProducerInner impl = entry.getValue();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        Set &lt; String &gt; lst = impl.getPublishTopicList();</span><br><span class="line">        topicList.addAll(lst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (String topic: topicList) &#123;</span><br><span class="line">    this.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean updateTopicRouteInfoFromNameServer(final String topic) &#123;...topicRouteData = this.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, 1000 * 3);</span><br><span class="line">    if (topicRouteData != null) &#123;</span><br><span class="line">        TopicRouteData old = this.topicRouteTable.get(topic);</span><br><span class="line">        boolean changed = topicRouteDataIsChange(old, topicRouteData);...</span><br><span class="line">        if (changed) &#123;</span><br><span class="line">            TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line">            // 更新存储topic的broker地址</span><br><span class="line">            for (BrokerData bd: topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">                this.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新每个producer发布的topic路由信息，主要是topic的broker路由和MessageQueue信息</span><br><span class="line">            &#123;</span><br><span class="line">                TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">                publishInfo.setHaveTopicRouterInfo(true);</span><br><span class="line">                Iterator &lt; Entry &lt; String,</span><br><span class="line">                MQProducerInner &gt;&gt; it = this.producerTable.entrySet().iterator();</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    Entry &lt; String,</span><br><span class="line">                    MQProducerInner &gt; entry = it.next();</span><br><span class="line">                    MQProducerInner impl = entry.getValue();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新每个consumer订阅的topic路由信息，主要是topic的broker路由和MessageQueue信息</span><br><span class="line">            &#123;</span><br><span class="line">                Set &lt; MessageQueue &gt; subscribeInfo = topicRouteData2TopicSubscribeInfo(topic, topicRouteData);</span><br><span class="line">                Iterator &lt; Entry &lt; String,</span><br><span class="line">                MQConsumerInner &gt;&gt; it = this.consumerTable.entrySet().iterator();</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    Entry &lt; String,</span><br><span class="line">                    MQConsumerInner &gt; entry = it.next();</span><br><span class="line">                    MQConsumerInner impl = entry.getValue();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.updateTopicSubscribeInfo(topic, subscribeInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新topic路由信息</span><br><span class="line">            this.topicRouteTable.put(topic, cloneTopicRouteData);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时向-broker-发送心跳"><a href="#定时向-broker-发送心跳" class="headerlink" title="定时向 broker 发送心跳"></a>定时向 broker 发送心跳</h4><p>定时清理不能路由到 topic 的 broker，然后向<code>MQClientInstance</code>的所有可以路由到发布和订阅 topic 的 broker 发送心跳。执行频率来自配置，默认 30s 执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQClientInstance.this.cleanOfflineBroker();</span><br><span class="line">            MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;ScheduledTask sendHeartbeatToAllBroker exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>mqClient 的 brokerAddrTable 中删除已不能路由到 topic 的 broker 机器地址（broker 是主从架构），如果主从架构所有的 broker 机器都路由不到节点，删除 broker 逻辑节点</p>
<ul>
<li>brokerAddrTable 维度是 broker 逻辑节点，key&#x3D;brokerName，value 是 broker 逻辑节点中所有主从架构部署的物理机器地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, HashMap&lt;Long, String&gt;&gt; updatedTable = new ConcurrentHashMap&lt;String, HashMap&lt;Long, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;Entry&lt;String, HashMap&lt;Long, String&gt;&gt;&gt; itBrokerTable = this.brokerAddrTable.entrySet().iterator();</span><br><span class="line">while (itBrokerTable.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, HashMap&lt;Long, String&gt;&gt; entry = itBrokerTable.next();</span><br><span class="line">    String brokerName = entry.getKey();</span><br><span class="line">    HashMap&lt;Long, String&gt; oneTable = entry.getValue();</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Long, String&gt; cloneAddrTable = new HashMap&lt;Long, String&gt;();</span><br><span class="line">    cloneAddrTable.putAll(oneTable);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = cloneAddrTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Long, String&gt; ee = it.next();</span><br><span class="line">        String addr = ee.getValue();</span><br><span class="line">        if (!this.isBrokerAddrExistInTopicRouteTable(addr)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            log.info(&quot;the broker addr[&#123;&#125; &#123;&#125;] is offline, remove it&quot;, brokerName, addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果主从架构所有的broker机器都路由不到节点，删除broker逻辑节点</span><br><span class="line">    if (cloneAddrTable.isEmpty()) &#123;</span><br><span class="line">        itBrokerTable.remove();</span><br><span class="line">        log.info(&quot;the broker[&#123;&#125;] name&#x27;s host is offline, remove it&quot;, brokerName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        updatedTable.put(brokerName, cloneAddrTable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!updatedTable.isEmpty()) &#123;</span><br><span class="line">    this.brokerAddrTable.putAll(updatedTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean isBrokerAddrExistInTopicRouteTable(final String addr) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, TopicRouteData&gt;&gt; it = this.topicRouteTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, TopicRouteData&gt; entry = it.next();</span><br><span class="line">        TopicRouteData topicRouteData = entry.getValue();</span><br><span class="line">        List&lt;BrokerData&gt; bds = topicRouteData.getBrokerDatas();</span><br><span class="line">        for (BrokerData bd : bds) &#123;</span><br><span class="line">            if (bd.getBrokerAddrs() != null) &#123;</span><br><span class="line">                boolean exist = bd.getBrokerAddrs().containsValue(addr);</span><br><span class="line">                if (exist)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向可路由到的 broker 物理节点发送心跳</p>
<ul>
<li>心跳信息包括 mq 客户端的 clientId、producerGroupName 和 consumerGroup 的订阅信息<code>SubscriptionData</code><ul>
<li>broker 按 consumerGroup 维度聚合组订阅信息。客户端拉取消息时，broker 会用到订阅信息来判断消息是否满足过滤条件（tag 过滤 or SQL 过滤）。消息过滤原理后面单独讲</li>
<li>如果同 group 中两个 consumer 订阅信息不同，broker 存储的 consumerGroup 订阅信息会被最新一次心跳数据覆盖，被覆盖订阅信息的 consumer 在拉取消息时，broker 可能会找不到 topic 的订阅信息而返回失败</li>
<li>如果 mqClient 只有 producer，只需要向 master 节点发送心跳</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 心跳信息包括mq客户端的clientId、所有producer和consumer信息</span><br><span class="line">    final HeartbeatData heartbeatData = this.prepareHeartbeatData();</span><br><span class="line">    ...</span><br><span class="line">    // brokerAddrTable是broker逻辑节点维度，每个逻辑节点包含多个broker物理节点，因为broker是主从架构</span><br><span class="line">    Iterator&lt;Entry&lt;String, HashMap&lt;Long, String&gt;&gt;&gt; it = this.brokerAddrTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, HashMap&lt;Long, String&gt;&gt; entry = it.next();</span><br><span class="line">        String brokerName = entry.getKey();</span><br><span class="line">        HashMap&lt;Long, String&gt; oneTable = entry.getValue();</span><br><span class="line">        if (oneTable != null) &#123;</span><br><span class="line">            // broker物理节点，key=0说明是master物理节点</span><br><span class="line">            for (Map.Entry&lt;Long, String&gt; entry1 : oneTable.entrySet()) &#123;</span><br><span class="line">                Long id = entry1.getKey();</span><br><span class="line">                String addr = entry1.getValue();</span><br><span class="line">                if (addr != null) &#123;</span><br><span class="line">                    // 如果mqClient没有consumer，只需和masterBroker保持心跳</span><br><span class="line">                    if (consumerEmpty) &#123;</span><br><span class="line">                        if (id != MixAll.MASTER_ID)</span><br><span class="line">                            continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        int version = this.mQClientAPIImpl.sendHearbeat(addr, heartbeatData, 3000);</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时发送-consumer-的消费位点"><a href="#定时发送-consumer-的消费位点" class="headerlink" title="定时发送 consumer 的消费位点"></a>定时发送 consumer 的消费位点</h4><p>定时把 consumer 在 messageQueue 的消费位点更新到 broker，目的是消费者集群重启后能继续从 broker 拉取后面未消费过的消息。执行频率来自配置，默认 5s 执行一次</p>
<ul>
<li>注意，只有集群模式才会把消费位点更新到 broker，广播模式只要在本地持久化消费位点即可<ul>
<li>广播模式只要本机器自己知道在 mq 上消费到哪里即可，宕机重启后也能继续消费后面的消息</li>
<li>集群模式如果宕机重启，需要重新负载均衡分配 mq 的消费者机器，所以不能消费者机器本地持久化位点，只有 broker 自己知道 mq 的消费位点，才能给“新的消费者机器”投递后续的消息</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQClientInstance.this.persistAllConsumerOffset();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;ScheduledTask persistAllConsumerOffset exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>遍历所有 Consumer 实例，然后从内存里获取 consumer 在每个 messageQueue 的当前消费位点</p>
<ul>
<li>当 messageQueue 数目大于 ConsumerGroup 下的实例数，一个 Consumer 实例有可能消费多个 messageQueue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, MQConsumerInner&gt;&gt; it = this.consumerTable.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, MQConsumerInner&gt; entry = it.next();</span><br><span class="line">    MQConsumerInner impl = entry.getValue();</span><br><span class="line">    impl.persistConsumerOffset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : this.offsetTable.entrySet()) &#123;</span><br><span class="line">    MessageQueue mq = entry.getKey();</span><br><span class="line">    AtomicLong offset = entry.getValue();</span><br><span class="line">    if (offset != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 将consumer对messageQueue的最新消费位点更新到broker</span><br><span class="line">        this.updateConsumeOffsetToBroker(mq, offset.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 messageQueue 所在 broker 的物理节点地址，更新 consumerGroup 在当前 messageQueue 的消费位点</p>
<ul>
<li>messageQueue 在同一个消费组 ConsumerGroup 下只能有一个消费者 Consumer（负载均衡里实现的），所以 messageQueue 记录消费位点是按消费组 ConsumerGroup 维度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,</span><br><span class="line">MQBrokerException, InterruptedException, MQClientException &#123;</span><br><span class="line">    // 从messageQueue所在broker获取一个物理节点地址</span><br><span class="line">    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());</span><br><span class="line">    if (null == findBrokerResult) &#123;</span><br><span class="line">        // 如果找不到broker，去ns获取topic的最新broker路由信息，并更新到本地</span><br><span class="line">        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">        // 再找一次mq所在的broker的物理节点地址</span><br><span class="line">        findBrokerResult = this.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (findBrokerResult != null) &#123;</span><br><span class="line">        UpdateConsumerOffsetRequestHeader requestHeader = new UpdateConsumerOffsetRequestHeader();</span><br><span class="line">        requestHeader.setTopic(mq.getTopic());</span><br><span class="line">        requestHeader.setConsumerGroup(this.groupName);</span><br><span class="line">        requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">        requestHeader.setCommitOffset(offset);</span><br><span class="line"></span><br><span class="line">        // 将mqClient对messageQueue的最新消费位点更新到broker</span><br><span class="line">        if (isOneway) &#123;</span><br><span class="line">            this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffsetOneway(</span><br><span class="line">                findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffset(</span><br><span class="line">                findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new MQClientException(&quot;The broker[&quot; + mq.getBrokerName() + &quot;] not exist&quot;, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动消息拉取线程"><a href="#启动消息拉取线程" class="headerlink" title="启动消息拉取线程"></a>启动消息拉取线程</h3><p>启动一个消息拉取线程，从阻塞队列<code>pullRequestQueue</code>拿消息拉取的 request，向 broker 发送请求批量拉取消息</p>
<ul>
<li>阻塞队列类型：LinkedBlockingQueue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Start pull service</span><br><span class="line">this.pullMessageService.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    log.info(&quot;Try to start service thread:&#123;&#125; started:&#123;&#125; lastThread:&#123;&#125;&quot;, getServiceName(), started.get(), thread);</span><br><span class="line">    if (!started.compareAndSet(false, true)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    stopped = false;</span><br><span class="line">    this.thread = new Thread(this, getServiceName());</span><br><span class="line">    this.thread.setDaemon(isDaemon);</span><br><span class="line">    this.thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PullRequest pullRequest = this.pullRequestQueue.take();</span><br><span class="line">            this.pullMessage(pullRequest);</span><br><span class="line">        &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;Pull Message Service Run Method exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取-consumer-实例"><a href="#获取-consumer-实例" class="headerlink" title="获取 consumer 实例"></a>获取 consumer 实例</h4><p>通过拉取消息请求所属的 ConsumerGroup，获取 Consumer 实例</p>
<ul>
<li>第一个拉取消息请求是 consumer 的 rebalance 负载均衡后放入的<ul>
<li>注意，消息拉取请求的维度是 messageQueue，即每个 messageQueue 都会有对应的拉取消息请求</li>
<li>后续该 consumer 在 mq 上的消息拉取请求都是复用这个 request</li>
</ul>
</li>
<li>这里 Consumer 直接强转成 DefaultMQPushConsumerImpl，说明消息拉取线程使用推模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mQClientFactory是MQClientInstance</span><br><span class="line">final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">if (consumer != null) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">    impl.pullMessage(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h4><p>DefaultMQPushConsumerImpl 发送拉取消息请求前，会做流控，如果触发流控，会通过一个延时任务，50ms 后再把这个消息拉取请求放入阻塞队列。</p>
<p>满足以下任一条件，触发流控：</p>
<ul>
<li>待处理的消息数超过阈值<ul>
<li>从 messageQueue 拉取到的消息会放入处理队列 processQueue，每次消费都从该队列取出。所以通过它能判断当前待处理消息数目</li>
<li>阈值可以通过配置 consumer 的 pullThresholdForQueue 修改</li>
</ul>
</li>
<li>待处理的消息大小超过阈值<ul>
<li>阈值可以通过配置 consumer 的 pullThresholdSizeForQueue 修改</li>
</ul>
</li>
<li>乱序消费 &amp;&amp; 处理队列的位点范围超过阈值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 处理队列缓存的消息数目或消息体大小超过阈值，延时拉取消息</span><br><span class="line">long cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span><br><span class="line"></span><br><span class="line">if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    if ((queueFlowControlTimes++%1000) == 0) &#123;</span><br><span class="line">        log.warn(&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;, this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.consumeOrderly) &#123;</span><br><span class="line">    // 乱序消费时，处理队列当前待处理消息的位点范围超过阈值（消费速度&lt;生成速度），执行流控，延时拉取消息</span><br><span class="line">    if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">        if ((queueMaxSpanFlowControlTimes++%1000) == 0) &#123;</span><br><span class="line">            log.warn(&quot;the queue&#x27;s messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;, processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) &#123;</span><br><span class="line">    if (!isStopped()) &#123;</span><br><span class="line">        this.scheduledExecutorService.schedule(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">                PullMessageService.this.executePullRequestImmediately(pullRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        timeDelay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.warn(&quot;PullMessageServiceScheduledThread has shutdown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void executePullRequestImmediately(final PullRequest pullRequest) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.pullRequestQueue.put(pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上报已消费的位点"><a href="#上报已消费的位点" class="headerlink" title="上报已消费的位点"></a>上报已消费的位点</h4><p>集群模式下，拉取消息请求里放入 consumer 在 mq 上已消费到的位点 commitOffsetValue，让 broker 做持久化。和定时上报 consumer 消费位点相互配合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 订阅模式，集群型表示消息在ConsumerGroup中只能被消费一次，广播型表示消息可以被ConsumerGroup中的每个Consumer消费一次</span><br><span class="line">// 集群订阅模式，拉取消息时传入commitOffsetValue，应该是告知broker，当前ConsumerGroup已经消费到该位点了，位点前的消息不能再被拉取</span><br><span class="line">if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">    commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">    if (commitOffsetValue &gt; 0) &#123;</span><br><span class="line">        commitOffsetEnable = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意拉取请求的起始位点 nextOffset 不是 commitOffsetValue。而是从 broker 拿到的响应 pullResult 里取出的，即 broker 会在响应里告诉 consumer，下一次消息拉取的起始位点</p>
<ul>
<li>首次拉取请求的 nextOffset 为 null，这时 broker 就会用到 consumer 上报的 commitOffsetValue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br></pre></td></tr></table></figure>

<h4 id="获取-broker-地址"><a href="#获取-broker-地址" class="headerlink" title="获取 broker 地址"></a>获取 broker 地址</h4><p>获取 messageQueue 所在的 broker 地址，然后调用 pullMessageAsync 异步拉取消息</p>
<ul>
<li>传入 Consumer 的 callback 接口用于收到消息后回调，消费批量拉取到的消息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FindBrokerResult findBrokerResult =</span><br><span class="line">    // 挑选要从messageQueue所在的物理broker拉取消息，可能是master也可能是slave</span><br><span class="line">    this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</span><br><span class="line">        this.recalculatePullFromWhichNode(mq), false);</span><br><span class="line">if (null == findBrokerResult) &#123;</span><br><span class="line">    // 找不到broker，重新从ns刷一遍路由信息到内存，然后再找一遍</span><br><span class="line">    this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">    findBrokerResult =</span><br><span class="line">        this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</span><br><span class="line">            this.recalculatePullFromWhichNode(mq), false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (findBrokerResult != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();</span><br><span class="line">    requestHeader.setConsumerGroup(this.consumerGroup);</span><br><span class="line">    requestHeader.setTopic(mq.getTopic());</span><br><span class="line">    requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">    requestHeader.setQueueOffset(offset);   // pullRequest.getNextOffset()，拉取该位点后面的消息</span><br><span class="line">    requestHeader.setMaxMsgNums(maxNums);   // 批量拉取的最大消息数</span><br><span class="line">    requestHeader.setSysFlag(sysFlagInner);</span><br><span class="line">    requestHeader.setCommitOffset(commitOffset);</span><br><span class="line">    requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</span><br><span class="line">    requestHeader.setSubscription(subExpression);</span><br><span class="line">    requestHeader.setSubVersion(subVersion);</span><br><span class="line">    requestHeader.setExpressionType(expressionType);</span><br><span class="line"></span><br><span class="line">    String brokerAddr = findBrokerResult.getBrokerAddr();</span><br><span class="line">    if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</span><br><span class="line">        brokerAddr = computePullFromWhichFilterServer(mq.getTopic(), brokerAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 批量拉取消息，推模式异步拉取消息，提供callback接口，异步future结果返回后，通过注册在future的监听器回调callback方法消费批量拉取的消息</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);</span><br><span class="line">    switch (communicationMode) &#123;</span><br><span class="line">        case ONEWAY:</span><br><span class="line">            assert false;</span><br><span class="line">            return null;</span><br><span class="line">        case ASYNC:</span><br><span class="line">            this.pullMessageAsync(addr, request, timeoutMillis, pullCallback);</span><br><span class="line">            return null;</span><br><span class="line">        case SYNC:</span><br><span class="line">            return this.pullMessageSync(addr, request, timeoutMillis);</span><br><span class="line">        default:</span><br><span class="line">            assert false;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义-netty-响应的回调-callback"><a href="#定义-netty-响应的回调-callback" class="headerlink" title="定义 netty 响应的回调 callback"></a>定义 netty 响应的回调 callback</h4><p>调用底层 netty 发送异步消息拉取请求前，又定义了一个 callback，用于将 netty 的响应结果转成 PullResult，然后回调外层 Consumer 提供的 callback，真正消费批量消息</p>
<ul>
<li>体现了分层和单一职责的思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ResponseFuture responseFuture) &#123;</span><br><span class="line">        RemotingCommand response = responseFuture.getResponseCommand();</span><br><span class="line">        if (response != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response, addr);</span><br><span class="line">                assert pullResult != null;</span><br><span class="line">                pullCallback.onSuccess(pullResult);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                pullCallback.onException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立和-broker-的-tcp-连接"><a href="#建立和-broker-的-tcp-连接" class="headerlink" title="建立和 broker 的 tcp 连接"></a>建立和 broker 的 tcp 连接</h4><p>netty 在发送异步请求前，会到 channelTable 拿这个 broker 地址对应的 channel 连接通道。如果没有（第一次发送请求），会调用 connect 方法建立与 broker 的 tcp 连接，然后再把通道 channel 缓存到 channelTable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Channel getAndCreateChannel(final String addr) throws RemotingConnectException,</span><br><span class="line">InterruptedException &#123;</span><br><span class="line">    if (null == addr) &#123;</span><br><span class="line">        return getAndCreateNameserverChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelWrapper cw = this.channelTables.get(addr);</span><br><span class="line">    if (cw != null &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">        return cw.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.createChannel(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Channel createChannel(final String addr) throws InterruptedException &#123;</span><br><span class="line">    ChannelWrapper cw = this.channelTables.get(addr);</span><br><span class="line">    if (cw != null &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">        return cw.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.lockChannelTables.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean createNewConnection;</span><br><span class="line">            cw = this.channelTables.get(addr);</span><br><span class="line">            if (cw != null) &#123;</span><br><span class="line"></span><br><span class="line">                if (cw.isOK()) &#123;</span><br><span class="line">                    return cw.getChannel();</span><br><span class="line">                &#125; else if (!cw.getChannelFuture().isDone()) &#123;</span><br><span class="line">                    createNewConnection = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.channelTables.remove(addr);</span><br><span class="line">                    createNewConnection = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                createNewConnection = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (createNewConnection) &#123;</span><br><span class="line">                ChannelFuture channelFuture = this.bootstrap.connect(RemotingHelper.string2SocketAddress(addr));</span><br><span class="line">                log.info(&quot;createChannel: begin to connect remote host[&#123;&#125;] asynchronously&quot;, addr);</span><br><span class="line">                cw = new ChannelWrapper(channelFuture);</span><br><span class="line">                this.channelTables.put(addr, cw);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;createChannel: create channel exception&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.lockChannelTables.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.warn(&quot;createChannel: try to lock channel table, but timeout, &#123;&#125;ms&quot;, LOCK_TIMEOUT_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cw != null) &#123;</span><br><span class="line">        ChannelFuture channelFuture = cw.getChannelFuture();</span><br><span class="line">        if (channelFuture.awaitUninterruptibly(this.nettyClientConfig.getConnectTimeoutMillis())) &#123;</span><br><span class="line">            if (cw.isOK()) &#123;</span><br><span class="line">                log.info(&quot;createChannel: connect remote host[&#123;&#125;] success, &#123;&#125;&quot;, addr, channelFuture.toString());</span><br><span class="line">                return cw.getChannel();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.warn(&quot;createChannel: connect remote host[&quot; + addr + &quot;] failed, &quot; + channelFuture.toString(), channelFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.warn(&quot;createChannel: connect remote host[&#123;&#125;] timeout &#123;&#125;ms, &#123;&#125;&quot;, addr, this.nettyClientConfig.getConnectTimeoutMillis(), channelFuture.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-netty-发送请求"><a href="#通过-netty-发送请求" class="headerlink" title="通过 netty 发送请求"></a>通过 netty 发送请求</h4><p>使用 netty 发送消息异步拉取请求到 broker</p>
<ul>
<li>创建这次请求的<code>ResponseFuture</code>对象，封装这次请求的异步响应上下文，包括异步消息响应（收到响应后 set 进去）、reqId、callback 函数等</li>
<li>缓存 ResponseFuture，key 是 reqId<ul>
<li>reqId 的生成规则是一个全局自增数</li>
<li>拿到响应后通过 reqId 拿到<code>ResponseFuture</code>，填充响应结果，然后在 callback 线程池里回调内层 callback 转换响应结果，再回调外层 callback 处理消息</li>
<li>通过 reqId 关联请求和响应，是实现异步拉取消息（推模式）的关键点</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建这次请求的`ResponseFuture`对象，封装这次请求的响应上下文，包括从netty通道获取的响应结果、处理响应结果的回调方法等</span><br><span class="line">final ResponseFuture responseFuture = new ResponseFuture(channel, opaque, timeoutMillis - costTime, invokeCallback, once);</span><br><span class="line">// 缓存ResponseFuture，key是请求id，生成规则是一个全局自增数。拿到响应后通过请求id拿到`ResponseFuture`，填充响应结果，然后执行回调方法处理响应结果</span><br><span class="line">this.responseTable.put(opaque, responseFuture);</span><br><span class="line">try &#123;</span><br><span class="line">    channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void operationComplete(ChannelFuture f) throws Exception &#123;</span><br><span class="line">            if (f.isSuccess()) &#123;</span><br><span class="line">                responseFuture.setSendRequestOK(true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            requestFail(opaque);</span><br><span class="line">            log.warn(&quot;send a request command to channel &lt;&#123;&#125;&gt; failed.&quot;, RemotingHelper.parseChannelRemoteAddr(channel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 拿到响应后通过请求id拿到`ResponseFuture`，填充响应结果</span><br><span class="line">// 回调内层callback处理响应结果，最终回调外层callback消费消息</span><br><span class="line">public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) &#123;</span><br><span class="line">    final int opaque = cmd.getOpaque();</span><br><span class="line">    final ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">    if (responseFuture != null) &#123;</span><br><span class="line">        responseFuture.setResponseCommand(cmd);</span><br><span class="line">        responseTable.remove(opaque);</span><br><span class="line">        if (responseFuture.getInvokeCallback() != null) &#123;</span><br><span class="line">            executeInvokeCallback(responseFuture);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            responseFuture.putResponse(cmd);</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void executeInvokeCallback(final ResponseFuture responseFuture) &#123;</span><br><span class="line">    boolean runInThisThread = false;</span><br><span class="line">    ExecutorService executor = this.getCallbackExecutor();</span><br><span class="line">    if (executor != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executor.submit(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        responseFuture.executeInvokeCallback();</span><br><span class="line">                    &#125; catch(Throwable e) &#123;</span><br><span class="line">                        log.warn(&quot;execute callback in executor exception, and callback throw&quot;, e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        responseFuture.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            runInThisThread = true;</span><br><span class="line">            log.warn(&quot;execute callback in executor exception, maybe executor busy&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        runInThisThread = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runInThisThread) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            responseFuture.executeInvokeCallback();</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.warn(&quot;executeInvokeCallback Exception&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果是同步拉取消息"><a href="#如果是同步拉取消息" class="headerlink" title="如果是同步拉取消息"></a>如果是同步拉取消息</h4><p>以上说的都是异步拉取消息的方式，即推 Push 模式。如果是拉 Pull 模式，区别就是从异步拉取消息改为同步拉取消息。具体实现方式为：</p>
<ul>
<li>ResponseFuture 放入 table，然后通过和 broker 建连的 channel 发送请求，这和异步方式没差别</li>
<li>调用 CDL 的 await 方法，让拉取消息线程阻塞等待响应结果<ul>
<li>注意是带最长阻塞时间的</li>
</ul>
</li>
<li>收到响应后，通过 reqId 拿到 ResponseFuture，因为同步方式 ResponseFuture 不会包含 callback 函数，所以走 putResponse 方法，set 响应数据并执行 countDown。这会唤醒拉取消息线程，拿到响应数据开始执行消费逻辑。这也是同步和异步最大的区别</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request,</span><br><span class="line">    final long timeoutMillis)</span><br><span class="line">    throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException &#123;</span><br><span class="line">    final int opaque = request.getOpaque();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        final ResponseFuture responseFuture = new ResponseFuture(channel, opaque, timeoutMillis, null, null);</span><br><span class="line">        this.responseTable.put(opaque, responseFuture);</span><br><span class="line">        final SocketAddress addr = channel.remoteAddress();</span><br><span class="line">        channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture f) throws Exception &#123;</span><br><span class="line">                if (f.isSuccess()) &#123;</span><br><span class="line">                    responseFuture.setSendRequestOK(true);</span><br><span class="line">                    return;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    responseFuture.setSendRequestOK(false);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                responseTable.remove(opaque);</span><br><span class="line">                responseFuture.setCause(f.cause());</span><br><span class="line">                responseFuture.putResponse(null);</span><br><span class="line">                log.warn(&quot;send a request command to channel &lt;&quot; + addr + &quot;&gt; failed.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 同步拉取消息，线程hold一定时间等待response</span><br><span class="line">        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</span><br><span class="line">        if (null == responseCommand) &#123;</span><br><span class="line">            if (responseFuture.isSendRequestOK()) &#123;</span><br><span class="line">                throw new RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,</span><br><span class="line">                    responseFuture.getCause());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseCommand;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        this.responseTable.remove(opaque);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public RemotingCommand waitResponse(final long timeoutMillis) throws InterruptedException &#123;</span><br><span class="line">    this.countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    return this.responseCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) &#123;</span><br><span class="line">    final int opaque = cmd.getOpaque();</span><br><span class="line">    final ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">    if (responseFuture != null) &#123;</span><br><span class="line">        responseFuture.setResponseCommand(cmd);</span><br><span class="line"></span><br><span class="line">        responseTable.remove(opaque);</span><br><span class="line"></span><br><span class="line">        if (responseFuture.getInvokeCallback() != null) &#123;</span><br><span class="line">            executeInvokeCallback(responseFuture);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            responseFuture.putResponse(cmd);</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.warn(&quot;receive response, but not matched any request, &quot; + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line">        log.warn(cmd.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费拉取到的消息"><a href="#消费拉取到的消息" class="headerlink" title="消费拉取到的消息"></a>消费拉取到的消息</h4><p>收到异步响应后 netty 回调业务 handler 处理消息，see：org.apache.rocketmq.remoting.netty.NettyRemotingClient.NettyClientHandler#channelRead0<br>在业务 handler 里通过 reqId 拿到对应 ResponseFuture 并把消息体赋给它。然后提交任务到 callback 线程池，异步调用 callback 线程来处理新消息<br>callback 线程将消息体转义为 pullResult 对象，然后回调业务 callback 的 onSuccess 方法开始真正处理新消息。</p>
<p>下面介绍的都是拿到了新消息后的逻辑，如果没拉取到新消息会立刻将请求放入阻塞队列</p>
<h5 id="设置下次拉取消息的起始位点"><a href="#设置下次拉取消息的起始位点" class="headerlink" title="设置下次拉取消息的起始位点"></a>设置下次拉取消息的起始位点</h5><p>读取在 messageQueue 上的消息拉取响应里返回的位点，作为下次拉取消息的起始位点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 读取messageQueue在消息拉取的响应里返回的位点，作为下次拉取消息的起始位点</span><br><span class="line">long prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br></pre></td></tr></table></figure>

<h5 id="消息放入-processQueue"><a href="#消息放入-processQueue" class="headerlink" title="消息放入 processQueue"></a>消息放入 processQueue</h5><p>拉取到的消息放入 processQueue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息List放入处理队列</span><br><span class="line">boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br></pre></td></tr></table></figure>

<h5 id="异步消费消息"><a href="#异步消费消息" class="headerlink" title="异步消费消息"></a>异步消费消息</h5><p>提交消费任务到线程池异步执行。按消费模式的不同，乱序（并发）消费使用 ConsumeMessageConcurrentlyService，顺序消费使用 ConsumeMessageOrderlyService</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建消费任务，提交到线程池执行</span><br><span class="line">// 如果是并发消费，消息list按最大批量消费数阈值分片后，提交并发消费任务到线程池 ✨</span><br><span class="line">// 如果是顺序消费，提交顺序消费任务到线程池 ✨</span><br><span class="line">DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(</span><br><span class="line">    pullResult.getMsgFoundList(),</span><br><span class="line">    processQueue,</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    dispatchToConsume);</span><br></pre></td></tr></table></figure>

<p>如果是乱序消费，消息 list 按单次消费消息数阈值分片后，提交多个并发消费任务到线程池</p>
<ul>
<li>消费阈值默认为 1，定义在 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#consumeMessageBatchMaxSize<ul>
<li>一般我们不改这个值，因为 listener 消费接口返回消费结果状态，如果多条消息一起消费，它们只能一起消费成功或失败</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">if (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">    ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">    try &#123;</span><br><span class="line">        this.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">        this.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    for (int total = 0; total &lt; msgs.size(); ) &#123;</span><br><span class="line">        List&lt;MessageExt&gt; msgThis = new ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">        for (int i = 0; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">            if (total &lt; msgs.size()) &#123;</span><br><span class="line">                msgThis.add(msgs.get(total));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.consumeExecutor.submit(consumeRequest);</span><br><span class="line">        &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">            for (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                msgThis.add(msgs.get(total));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行并发消费消息任务，先调用前置 hook</p>
<ul>
<li>hook 函数是调用 org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#registerConsumeMessageHook 方法注册到 consumer 的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = new ConsumeMessageContext();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(false);</span><br><span class="line">    ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用业务方 listener 消费批量消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br></pre></td></tr></table></figure>

<p>最后调用后置 hook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    // 调用后置hook</span><br><span class="line">    ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理消费结果</p>
<ul>
<li>如果 listener 返回的消费状态为重试（消费失败了），消息发送回 broker，并传入消息重投最大次数和重投时间间隔<ul>
<li>重投次数由 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#maxReconsumeTimes 控制，默认为-1，然后被转成 16，即默认重投 16 次</li>
<li>重投时间间隔由 org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext#delayLevelWhenNextConsume 控制。-1 表示直接投递到 DLQ 死信队列不重新消费了，0 表示由 broker 控制重投间隔，大于 0 表示客户端控制重投间隔。默认为 0</li>
<li>ConsumeConcurrentlyContext 作为入参传递给 listener，业务方可以修改默认值控制消息的重投间隔</li>
<li>如果消息发回 broker 失败，会本地提交一个延时任务，5 秒后重新消费消息</li>
</ul>
</li>
<li>从处理队列 ProcessQueue 移除消费完的消息</li>
<li>从 processQueue 获取下一个待消费消息的 offset，更新到 offsetTable<ul>
<li>offsetTable 按 messageQueue 维度存储将要消费的下一条消息位点。集群模式下定时上报到 broker，目的是 consumerGroup 重新负载均衡后（例如 consumerGroup 集群重启），broker 能知道 consumerGroup 在 messageQueue 上需要从哪条消息开始继续消费</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case RECONSUME_LATER:</span><br><span class="line">    ackIndex = -1;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">case CLUSTERING:</span><br><span class="line">    List &lt; MessageExt &gt; msgBackFailed = new ArrayList &lt; MessageExt &gt; (consumeRequest.getMsgs().size());</span><br><span class="line">    for (int i = ackIndex + 1; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">        MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">        // 集群模式，批量消息消费失败，重投递消息到broker的消费队列，指定下次延迟发送时间 ✨</span><br><span class="line">        boolean result = this.sendMessageBack(msg, context);</span><br><span class="line">        if (!result) &#123;</span><br><span class="line">            msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);</span><br><span class="line">            msgBackFailed.add(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">        consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line"></span><br><span class="line">        this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">// 消费完的消息，从处理队列（实际就是一个map，key=offset，value=消息）移除，返回移除后队列下一条待消费的消息offset</span><br><span class="line">long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">// 更新下一个待消费消息的offset到内存offsetTable</span><br><span class="line">if (offset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">    this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果业务方使用的 listener 是 MessageListenerOrderly，则表示顺序消费 mq 上的消息，consumer 实例创建的消费服务就是 ConsumeMessageOrderlyService</p>
<p>顺序消费基本流程和并发消费类似，只说区别</p>
<p>1、如果 mqClient 还没有给 messageQueue 加锁，或加锁过期了，则加锁后再延迟消费消息</p>
<ul>
<li>mqClient 通知 broker 给 mq 加锁的目的是为了严格保证 mq 与消费者实例唯一绑定，确保 mq 上的消息在集群模式下被顺序消费</li>
<li>只有当 mqClient 关闭时，才会 unLock 所有 messageQueue</li>
<li>ConsumeMessageOrderlyService 的 start 方法会开启一个定时任务，发送 mq 加锁请求给负载均衡分配的 mq 所在的 broker。加锁成功后会置 mq 对应的 processQueue 的 locked 字段为 true</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// processQueue的locked状态和messageQueue是一致的，通过本地processQueue的锁定状态和锁定时间判断messageQueue是否锁定或过期，如果过期，需要重新让consumer所在的mqClient锁定messageQueue</span><br><span class="line">// 锁定messageQueue的作用我认为应该是为了通知broker，messageQueue已被consumerGroup中的当前client占据，防止极端情况组内其他client也去messageQueue拉取消息，造成乱序消费</span><br><span class="line">// 只有当mqClient关闭时，才会unLock所有messageQueue</span><br><span class="line">if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">        || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean lock(final MessageQueue mq) &#123;</span><br><span class="line">    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);</span><br><span class="line">    if (findBrokerResult != null) &#123;</span><br><span class="line">        LockBatchRequestBody requestBody = new LockBatchRequestBody();</span><br><span class="line">        requestBody.setConsumerGroup(this.consumerGroup);</span><br><span class="line">        requestBody.setClientId(this.mQClientFactory.getClientId());</span><br><span class="line">        requestBody.getMqSet().add(mq);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // ConsumerGroup中的当前mqClient锁住它对应broker中的messageQueue</span><br><span class="line">        // 所谓锁住，实际是在broker中标记messageQueue被consumerGroup的哪个mqClient占有</span><br><span class="line">        Set&lt;MessageQueue&gt; lockedMq =</span><br><span class="line">        this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);</span><br><span class="line">        for (MessageQueue mmqq : lockedMq) &#123;</span><br><span class="line">            ProcessQueue processQueue = this.processQueueTable.get(mmqq);</span><br><span class="line">            if (processQueue != null) &#123;</span><br><span class="line">                // 缓存队列locked，说明它对应的messageQueue已被当前ConsumerGroup的mqClient锁住</span><br><span class="line">                processQueue.setLocked(true);</span><br><span class="line">                processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (lockOK) &#123;</span><br><span class="line">    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, mq, 10);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、从 processQueue 按位点顺序取不超过批量消费消息阈值数的消息进行消费</p>
<ul>
<li>并发消费时，直接切分收到的消息 list，每个切分后的子消息 list 创建一个线程消费</li>
<li>从 processQueue 取消息 &amp;&amp; 调用业务 Listener 顺序消费时，都加了互斥锁，确保 processQueue 的 msgs 不被并发访问消费，即保证了顺序性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 批量消费消息数阈值</span><br><span class="line">final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">// 从缓存队列批量顺序取待消费消息，不超过批量消费消息数阈值</span><br><span class="line">List&lt;MessageExt&gt; msgs = this.processQueue.takeMessages(consumeBatchSize);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 调用业务Listener顺序消费时加锁，防止在任务并发执行时，并发调用listener消费消息，产生消费乱序</span><br><span class="line">    this.processQueue.getLockConsume().lock();</span><br><span class="line">    // 批量消费消息</span><br><span class="line">    status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 解锁</span><br><span class="line">    this.processQueue.getLockConsume().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、顺序消费失败，如果超过最大重试次数，发送到死信队列，跳过消息。否则，将 msgs 重新放回 processQueue，延迟提交该 processQueue 上的顺序消费任务到线程池</p>
<ul>
<li>最大重试次数取 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#maxReconsumeTimes，默认-1，会转成 Integer.MAX_VALUE，表示会一直重试</li>
<li>本地延迟消费的延时时间默认 1s，取 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#suspendCurrentQueueTimeMillis。可以通过 org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext#suspendCurrentQueueTimeMillis 字段修改</li>
<li>并发消费失败的消息，重投递回 broker，不是提交延时任务本地重新消费</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">    if (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);</span><br><span class="line">        this.submitConsumeRequestLater(</span><br><span class="line">            consumeRequest.getProcessQueue(),</span><br><span class="line">            consumeRequest.getMessageQueue(),</span><br><span class="line">            context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">        continueConsume = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<h5 id="拉取消息请求放回阻塞队列"><a href="#拉取消息请求放回阻塞队列" class="headerlink" title="拉取消息请求放回阻塞队列"></a>拉取消息请求放回阻塞队列</h5><p>提交消费任务后，消息拉取请求放到阻塞队列，由拉取线程从阻塞队列取出请求，再次向 broker 发起请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息拉取请求放到阻塞队列，由拉取线程轮询阻塞队列再次向broker发起请求</span><br><span class="line">if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动负载均衡线程"><a href="#启动负载均衡线程" class="headerlink" title="启动负载均衡线程"></a>启动负载均衡线程</h3><p>负载均衡线程默认每隔 20s 执行一次负载 mq 的负载均衡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override public void run() &#123;</span><br><span class="line">    log.info(this.getServiceName() + &quot; service started&quot;);</span><br><span class="line"></span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        this.waitForRunning(waitInterval);</span><br><span class="line">        this.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按 consumer 实例订阅的 topic 所属 mq 维度执行负载均衡策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doRebalance() &#123;</span><br><span class="line">    for (Map.Entry&lt;String, MQConsumerInner&gt; entry : this.consumerTable.entrySet()) &#123;</span><br><span class="line">        MQConsumerInner impl = entry.getValue();</span><br><span class="line">        if (impl != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;doRebalance exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doRebalance(final boolean isOrder) &#123;</span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span><br><span class="line">    if (subTable != null) &#123;</span><br><span class="line">        for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            final String topic = entry.getKey();</span><br><span class="line">            try &#123;</span><br><span class="line">                this.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(&quot;rebalanceByTopic Exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取存储 topic 消息的所有 messageQueue</p>
<ul>
<li>topic 的路由信息是定时请求 ns 获取到的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// topicSubscribeInfoTable存储的是定时从ns拿到的topic路由信息，即存储topic消息的所有messageQueue</span><br><span class="line">Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic);</span><br></pre></td></tr></table></figure>

<p>随机请求存储 topic 消息的一台 broker，获取同 consumerGroup 下所有客户端的 clientId</p>
<ul>
<li>所有订阅该 topic 的 consumer 都会通过心跳消息向所有存储 topic 消息的 broker 上报 ConsumerGroup 信息，因此通过 broker 能拿到 ConsumerGroup 中的所有 clientId</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 随机取存储topic消息的一个broker，通过它获取当前consumer所在Group中所有consumer客户端的clientId</span><br><span class="line">List&lt;String&gt; cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br></pre></td></tr></table></figure>

<p>按 mqClient 均分的方式为 consumer 消费的 topic 分配 messageQueue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 均分算法，如果consumer数量超过messageQueue数量，超过部分的consumer实例不消费messageQueue</span><br><span class="line"> * 返回分配到的messageQueue</span><br><span class="line"> */</span><br><span class="line">int index = cidAll.indexOf(currentCID);</span><br><span class="line">int mod = mqAll.size() % cidAll.size();</span><br><span class="line">int averageSize = mqAll.size() &lt;= cidAll.size() ? 1 : (mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size());</span><br><span class="line">int startIndex = (mod &gt; 0 &amp;&amp; index &lt; mod) ? index * averageSize: index * averageSize + mod;</span><br><span class="line">int range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">for (int i = 0; i &lt; range; i++) &#123;</span><br><span class="line">    result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>

<p>如果负载均衡分配的 messageQueue 在 mqClient 上还没有 processQueue，创建与 messageQueue 映射的 processQueue，然后构建该 messageQueue 上的消息拉取请求，放入阻塞队列</p>
<ul>
<li>如果之前已经缓存了该 topic 的 messageQueue，会比对之前的 messageQueue 是否依然在该 topic 新分配的 messageQueue 里，如果不在，认为之前分配的 messageQueue 失效并 remove，同时 drop 对应的 processQueue</li>
<li>如果 consumerGroup 顺序消费 topic 消息，创建 ProcessQueue 前，一定要用 ConsumerGroup 中的当前 client 锁住 messageQueue，否则不能拉取消息。应该是担心万一 messageQueue 已被别的 consumerClient 占据，造成多个 consumer 同时消费一个 messageQueue 产生乱序消费</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.processQueueTable.entrySet().iterator();</span><br><span class="line">...</span><br><span class="line">// messageQueue的topic与consumer订阅的topic相同，说明是之前已经负载均衡后给consumer分配的messageQueue</span><br><span class="line">// 但messageQueue不在最新负载均衡分配的mqs里，说明broker上的messageQueue有调整，之前的messageQueue失效，需要remove，并drop对应的processQueue</span><br><span class="line">if (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">    if (!mqSet.contains(mq)) &#123;</span><br><span class="line">    pq.setDropped(true);</span><br><span class="line">    if (this.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// mqSet：负载均衡器给当前consumer实例分配的messageQueueSet</span><br><span class="line">for (MessageQueue mq : mqSet) &#123;</span><br><span class="line">    // 如果最新负载均衡分配的messageQueue在mqClient没有对应的processQueue，初始化processQueue，然后构建消息拉取请求，拉取messageQueue里的消息</span><br><span class="line">    if (!this.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">        ProcessQueue pq = new ProcessQueue();</span><br><span class="line">        // 获取从messageQueue拉取消息的起始位点</span><br><span class="line">        long nextOffset = this.computePullFromWhere(mq);</span><br><span class="line">        if (nextOffset &gt;= 0) &#123;</span><br><span class="line">            // 初始化缓存队列，映射分配的messageQueue</span><br><span class="line">            ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">            if (pre != null) &#123;</span><br><span class="line">                log.info(&quot;doRebalance, &#123;&#125;, mq already exists, &#123;&#125;&quot;, consumerGroup, mq);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 初始化后，构建消息拉取请求，拉取messageQueue里的消息</span><br><span class="line">                log.info(&quot;doRebalance, &#123;&#125;, add a new mq, &#123;&#125;&quot;, consumerGroup, mq);</span><br><span class="line">                PullRequest pullRequest = new PullRequest();</span><br><span class="line">                pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                pullRequest.setMessageQueue(mq);</span><br><span class="line">                pullRequest.setProcessQueue(pq);</span><br><span class="line">                pullRequestList.add(pullRequest);</span><br><span class="line">                changed = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 消息拉取请求放入阻塞队列</span><br><span class="line">this.dispatchPullRequest(pullRequestList);</span><br></pre></td></tr></table></figure>

<h3 id="更新-mqClient-的状态"><a href="#更新-mqClient-的状态" class="headerlink" title="更新 mqClient 的状态"></a>更新 mqClient 的状态</h3><p>producer 所属 mqClient 的 serviceState 变为 RUNNING，表示 producer 实例启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.serviceState = ServiceState.RUNNING;</span><br></pre></td></tr></table></figure>

<h1 id="启动-consumer-实例"><a href="#启动-consumer-实例" class="headerlink" title="启动 consumer 实例"></a>启动 consumer 实例</h1><p>启动 consumer 实例和启动 producer 实例基本类似。启动方法入口：org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#start</p>
<h2 id="构建-SubscriptionData"><a href="#构建-SubscriptionData" class="headerlink" title="构建 SubscriptionData"></a>构建 SubscriptionData</h2><p>构建 consumer 的订阅信息 SubscriptionData，放入它的负载均衡器 RebalanceImpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void copySubscription() throws MQClientException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Map &lt; String,</span><br><span class="line">        String &gt; sub = this.defaultMQPushConsumer.getSubscription();</span><br><span class="line">        if (sub != null) &#123;</span><br><span class="line">            for (final Map.Entry &lt; String, String &gt; entry: sub.entrySet()) &#123;</span><br><span class="line">                final String topic = entry.getKey();</span><br><span class="line">                final String subString = entry.getValue();</span><br><span class="line">                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), topic, subString);</span><br><span class="line">                this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化-mqClient-1"><a href="#实例化-mqClient-1" class="headerlink" title="实例化 mqClient"></a>实例化 mqClient</h2><p>同 producer</p>
<h2 id="实例化-offsetStore"><a href="#实例化-offsetStore" class="headerlink" title="实例化 offsetStore"></a>实例化 offsetStore</h2><p>实例化 offsetStore，存储在 mq 上的下一条待消费消息的 offset。如果是广播模式，本地持久化 offset 即可，如果是集群模式，需要同步给 broker，目的是重新负载均衡新的消费者机器绑定 mq 后，broker 能知道该从哪个消息开始继续消费</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (this.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">case BROADCASTING:</span><br><span class="line">    this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    break;</span><br><span class="line">case CLUSTERING:</span><br><span class="line">    this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化消息消费服务"><a href="#实例化消息消费服务" class="headerlink" title="实例化消息消费服务"></a>实例化消息消费服务</h2><p>根据业务 listener 是并发消费类型还是顺序消费类型，创建对应的消息消费服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (this.getMessageListenerInner() instanceof MessageListenerOrderly) &#123;</span><br><span class="line">    this.consumeOrderly = true;</span><br><span class="line">    this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span><br><span class="line">&#125; else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) &#123;</span><br><span class="line">    this.consumeOrderly = false;</span><br><span class="line">    this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动消息消费服务的定时任务"><a href="#启动消息消费服务的定时任务" class="headerlink" title="启动消息消费服务的定时任务"></a>启动消息消费服务的定时任务</h2><p>针对消费服务，启动辅助的定时任务</p>
<h3 id="并发消费的定时任务"><a href="#并发消费的定时任务" class="headerlink" title="并发消费的定时任务"></a>并发消费的定时任务</h3><p>该定时任务延时 15 分钟后，每隔 15 分钟执行一次。该任务定时清理消费超时的消息，消费超时阈值默认 15 分钟，所以定时任务的周期如此设置</p>
<ul>
<li>消费超时的阈值由 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#consumeTimeout 控制，默认 15 分钟</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override public void run() &#123;</span><br><span class="line">            cleanExpireMsg();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理消费超时消息的具体流程：<br>遍历 processQueue 里的消息，如果业务 listener 对消息的消费时间超过阈值，默认 15 分钟，将消息发回 broker 做延时投递重新消费，然后从 processQueue 里移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) &#123;</span><br><span class="line">    if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int loop = msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16;</span><br><span class="line">    for (int i = 0; i &lt; loop; i++) &#123;</span><br><span class="line">        MessageExt msg = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.lockTreeMap.readLock().lockInterruptibly();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 如果业务listener消费消息的时间超过了阈值，将消息发回broker</span><br><span class="line">                if (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * 60 * 1000) &#123;</span><br><span class="line">                    msg = msgTreeMap.firstEntry().getValue();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                this.lockTreeMap.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            pushConsumer.sendMessageBack(msg, 3);</span><br><span class="line">            log.info(&quot;send expire msg back. topic=&#123;&#125;, msgId=&#123;&#125;, storeHost=&#123;&#125;, queueId=&#123;&#125;, queueOffset=&#123;&#125;&quot;, msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());</span><br><span class="line">            try &#123;</span><br><span class="line">                this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            removeMessage(Collections.singletonList(msg));</span><br><span class="line">                        &#125; catch(Exception e) &#123;</span><br><span class="line">                            log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    this.lockTreeMap.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(InterruptedException e) &#123;</span><br><span class="line">                log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序消费的定时任务"><a href="#顺序消费的定时任务" class="headerlink" title="顺序消费的定时任务"></a>顺序消费的定时任务</h3><p>默认 20s 执行一次，定时对 broker 上的 messageQueue 发起加锁请求，加锁成功的 mq 对应的 processQueue，置 locked 字段为 true。这么做是为了确保 mqClient 和 mq 的唯一绑定关系，确保 mq 上的消息在 consumerGroup 能被顺序消费</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    // 集群模式顺序消费时，client定时对broker上的messageQueue加锁，对加锁成功的mq对应的processQueue，置locked字段为true</span><br><span class="line">    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">                ConsumeMessageOrderlyService.this.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void lockAll() &#123;</span><br><span class="line">    HashMap &lt; String,</span><br><span class="line">    Set &lt; MessageQueue &gt;&gt; brokerMqs = this.buildProcessQueueTableByBrokerName();</span><br><span class="line"></span><br><span class="line">    Iterator &lt; Entry &lt; String,</span><br><span class="line">    Set &lt; MessageQueue &gt;&gt;&gt; it = brokerMqs.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry &lt; String,</span><br><span class="line">        Set &lt; MessageQueue &gt;&gt; entry = it.next();</span><br><span class="line">        final String brokerName = entry.getKey();</span><br><span class="line">        final Set &lt; MessageQueue &gt; mqs = entry.getValue();</span><br><span class="line"></span><br><span class="line">        if (mqs.isEmpty()) continue;</span><br><span class="line"></span><br><span class="line">        FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, true);</span><br><span class="line">        if (findBrokerResult != null) &#123;</span><br><span class="line">            LockBatchRequestBody requestBody = new LockBatchRequestBody();</span><br><span class="line">            requestBody.setConsumerGroup(this.consumerGroup);</span><br><span class="line">            requestBody.setClientId(this.mQClientFactory.getClientId());</span><br><span class="line">            requestBody.setMqSet(mqs);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Set &lt; MessageQueue &gt; lockOKMQSet = this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);</span><br><span class="line"></span><br><span class="line">                for (MessageQueue mq: lockOKMQSet) &#123;</span><br><span class="line">                    ProcessQueue processQueue = this.processQueueTable.get(mq);</span><br><span class="line">                    if (processQueue != null) &#123;</span><br><span class="line">                        if (!processQueue.isLocked()) &#123;</span><br><span class="line">                            log.info(&quot;the message queue locked OK, Group: &#123;&#125; &#123;&#125;&quot;, this.consumerGroup, mq);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        processQueue.setLocked(true);</span><br><span class="line">                        processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (MessageQueue mq: mqs) &#123;</span><br><span class="line">                    if (!lockOKMQSet.contains(mq)) &#123;</span><br><span class="line">                        ProcessQueue processQueue = this.processQueueTable.get(mq);</span><br><span class="line">                        if (processQueue != null) &#123;</span><br><span class="line">                            processQueue.setLocked(false);</span><br><span class="line">                            log.warn(&quot;the message queue locked Failed, Group: &#123;&#125; &#123;&#125;&quot;, this.consumerGroup, mq);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                log.error(&quot;lockBatchMQ exception, &quot; + mqs, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="consumer-注册到-mqClient"><a href="#consumer-注册到-mqClient" class="headerlink" title="consumer 注册到 mqClient"></a>consumer 注册到 mqClient</h2><p>同 producer</p>
<h2 id="启动-MQClientInstance-1"><a href="#启动-MQClientInstance-1" class="headerlink" title="启动 MQClientInstance"></a>启动 MQClientInstance</h2><p>同 producer</p>
<h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><h2 id="Broker-如何做消息持久化"><a href="#Broker-如何做消息持久化" class="headerlink" title="Broker 如何做消息持久化"></a>Broker 如何做消息持久化</h2><p>先说结论：</p>
<ul>
<li>消息持久化的流程是：先写内核缓冲区 PageCache–&gt;再把数据刷盘到文件</li>
<li>broker 将消息顺序写入 commitLog 文件。超过 1G 后自动创建新文件，文件名为当前偏移量 offset</li>
<li>写入 commitLog 后，broker 会把消息的索引信息放到 messageQueue 里。索引信息包括：commitLogOffset+msgSize+tagsHashCode，共 20 字节<ul>
<li>broker 处理 consumer 的消息拉取请求时，如果 messageQueue 里存在 request.nextOffset 偏移量后面的消息，且消息的 tagsHashCode 在 group 的订阅信息里，或者消息满足 consumer 端的 sql 表达式，则通过 commitLogOffset+msgSize 到 commitLog 里取出消息体，发送给 consumer</li>
<li>获取消息需要先读 messageQueue 再读 commitLog，但不会影响性能。因为 Linux 的 PageCache 技术，读写磁盘文件的数据都会缓存到 PageCache 缓存，且 messageQueue 只包含索引信息，占用的字节更少（每个消息 20 字节），所以 PageCache 可以缓存更多的 messageQueue，对它的读取接近直接从内存获取</li>
</ul>
</li>
</ul>
<p>消息持久化的入口：<br>org.apache.rocketmq.store.MappedFile#appendMessagesInner</p>
<h3 id="写入内核缓冲区"><a href="#写入内核缓冲区" class="headerlink" title="写入内核缓冲区"></a>写入内核缓冲区</h3><p>先将消息写入内核缓冲区 PageCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);</span><br></pre></td></tr></table></figure>

<p>这里需要说明的是，buteBuffer 使用了 java nio 里的 DirectByteBuffer，该对象是 java 程序对内核缓冲区的引用，通过它可以直接操作内核缓冲区，减少了用户空间（java 堆内存）到内核缓冲区的数据拷贝，提高了 io 读写性能。这也是我们常说的零拷贝技术。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">    for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</span><br><span class="line"></span><br><span class="line">        final long address = ((DirectBuffer) byteBuffer).address();</span><br><span class="line">        Pointer pointer = new Pointer(address);</span><br><span class="line">        LibC.INSTANCE.mlock(pointer, new NativeLong(fileSize));</span><br><span class="line"></span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h3><p>刷盘即 PageCache 缓存的数据刷入磁盘文件。有两种实现方式：</p>
<ul>
<li>将 DirectByteBuffer 指向的 PageCache 的数据提交到 FileChannel。FileChannel 把数据给到操作系统进行文件修改</li>
<li>调用 java.nio.MappedByteBuffer#force，不通过 FileChannel 直接将 PageCache 的数据映射到文件，这种是针对超大文件的一种优化。还不太了解原理</li>
</ul>
<p>刷盘策略也分为同步刷盘和异步刷盘，他们的共同点都是唤醒异步刷盘线程执行刷盘操作，区别是同步刷盘阻塞等待刷盘线程的结果，异步刷盘只唤醒刷盘线程就结束了</p>
<ul>
<li>GroupCommitService：同步刷盘，基于 MappedByteBuffer<ul>
<li>同步刷盘的线程阻塞在 flushOkFuture.get 方法，等待刷盘结果再返回</li>
</ul>
</li>
<li>CommitRealTimeService：异步刷盘，基于 DirectByteBuffer<ul>
<li>异步刷盘只是 wakeUp 刷盘线程，底层 countDown 唤醒，开始刷盘</li>
</ul>
</li>
<li>FlushRealTimeService：异步刷盘，基于 MappedByteBuffer<ul>
<li>异步刷盘只是 wakeUp 刷盘线程，底层 countDown 唤醒，开始刷盘</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void handleDiskFlush(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt) &#123;</span><br><span class="line">    // Synchronization flush</span><br><span class="line">    if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;</span><br><span class="line">        if (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            GroupCommitRequest request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">            service.putRequest(request);</span><br><span class="line">            CompletableFuture&lt;PutMessageStatus&gt; flushOkFuture = request.future();</span><br><span class="line">            PutMessageStatus flushStatus = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                flushStatus = flushOkFuture.get(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(),</span><br><span class="line">                        TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">                //flushOK=false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                log.error(&quot;do groupcommit, wait for flush failed, topic: &quot; + messageExt.getTopic() + &quot; tags: &quot; + messageExt.getTags()</span><br><span class="line">                    + &quot; client address: &quot; + messageExt.getBornHostString());</span><br><span class="line">                putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            service.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Asynchronous flush</span><br><span class="line">    else &#123;</span><br><span class="line">        if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            // FlushRealTimeService</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // CommitRealTimeService</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是同步刷盘策略，会把一个组提交 GroupCommitRequest 请求放到 GroupCommitService 的写列表里。然后执行 countDown 方法唤醒同步刷盘线程</p>
<ul>
<li>GroupCommitRequest 指定了消息在 PageCache 的 offset，该 offset 之前的数据都可以刷到磁盘里</li>
<li>GroupCommitService 是一个守护线程，负责执行列表里的组提交刷盘请求</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private volatile List&lt;GroupCommitRequest&gt; requestsWrite = new ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line">private volatile List&lt;GroupCommitRequest&gt; requestsRead = new ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line"></span><br><span class="line">public synchronized void putRequest(final GroupCommitRequest request) &#123;</span><br><span class="line">    synchronized (this.requestsWrite) &#123;</span><br><span class="line">        this.requestsWrite.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    this.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void wakeup() &#123;</span><br><span class="line">    if (hasNotified.compareAndSet(false, true)) &#123;</span><br><span class="line">        waitPoint.countDown(); // notify</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒线程后，先交换 GroupCommitService 的读写列表。相当于清空了写列表，它可以继续添加新的组提交请求。刷盘遍历的是读列表里的组提交请求，然后执行底层的刷盘操作</p>
<ul>
<li>两个列表交替使用，读列表被加锁刷盘时，写列表可以继续用于添加请求。效率较高</li>
<li>刷盘结束条件：刷两次或者刷盘请求指定的 offset 位置已经刷到磁盘了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void swapRequests() &#123;</span><br><span class="line">    List&lt;GroupCommitRequest&gt; tmp = this.requestsWrite;</span><br><span class="line">    this.requestsWrite = this.requestsRead;</span><br><span class="line">    this.requestsRead = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doCommit() &#123;</span><br><span class="line">    synchronized (this.requestsRead) &#123;</span><br><span class="line">        if (!this.requestsRead.isEmpty()) &#123;</span><br><span class="line">            for (GroupCommitRequest req : this.requestsRead) &#123;</span><br><span class="line">                // There may be a message in the next file, so a maximum of</span><br><span class="line">                // two times the flush</span><br><span class="line">                boolean flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                for (int i = 0; i &lt; 2 &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">                    flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                req.wakeupCustomer(flushOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            if (storeTimestamp &gt; 0) &#123;</span><br><span class="line">                CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.requestsRead.clear();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Because of individual messages is set to not sync flush, it</span><br><span class="line">            // will come to this process</span><br><span class="line">            CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int flush(final int flushLeastPages) &#123;</span><br><span class="line">    if (this.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        if (this.hold()) &#123;</span><br><span class="line">            int value = getReadPosition();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //We only append data to fileChannel or mappedByteBuffer, never both.</span><br><span class="line">                if (writeBuffer != null || this.fileChannel.position() != 0) &#123;</span><br><span class="line">                    this.fileChannel.force(false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error occurred when force data to disk.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.flushedPosition.set(value);</span><br><span class="line">            this.release();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.warn(&quot;in flush, hold failed, flush offset = &quot; + this.flushedPosition.get());</span><br><span class="line">            this.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mqFlush.png"></p>
<h2 id="Broker-处理-Consumer-拉取消息请求"><a href="#Broker-处理-Consumer-拉取消息请求" class="headerlink" title="Broker 处理 Consumer 拉取消息请求"></a>Broker 处理 Consumer 拉取消息请求</h2><p>入口：org.apache.rocketmq.broker.processor.PullMessageProcessor#processRequest(io.netty.channel.ChannelHandlerContext, org.apache.rocketmq.remoting.protocol.RemotingCommand)</p>
<h3 id="构建-MessageFilter"><a href="#构建-MessageFilter" class="headerlink" title="构建 MessageFilter"></a>构建 MessageFilter</h3><p>根据 request 里的 consumerGroup 订阅信息构建消息过滤 MessageFilter 对象。该对象主要包含 2 个用于消息过滤的成员变量：</p>
<ul>
<li>SubscriptionData，它包含了 tagsHashCodeSet，通过它完成基于 tag 的过滤</li>
<li>ConsumerFilterData，它使用布隆过滤器存储 consumerGroup+topic 映射的 bit 数组。通过它做基于 sql 表达式的过滤<ul>
<li>每条消息在 messageQueue 扩展队列里会存储所有通过 sql 校验的 consumerGroup 组成的布隆过滤器 bit 数组。这个大 bit 数组是在消息持久化过程中计算并存储到 messageQueue 的扩展队列<ul>
<li>如果当前 bit 数组不包含在这个大数组中，说明这条消息一定不能满足 sql 表达式</li>
<li>如果包含，说明这条消息可能满足 sql 表达式（因为布隆过滤器可能误判），再执行一次 sql 表达式来验证。通过布隆过滤器，能提升 consumer 消息拉取的性能，不用每条消息都执行一遍 sql 表达式来验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MessageFilter messageFilter;</span><br><span class="line">if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">    messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        this.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        this.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找到-MessageQueue"><a href="#找到-MessageQueue" class="headerlink" title="找到 MessageQueue"></a>找到 MessageQueue</h3><blockquote>
<p>实际要找的是：存储 MessageQueue 的所有文件在内存 PageCache 里的映射对象</p>
</blockquote>
<p>broker 为每个 topic 创建多个 messageQueue。每个 MessageQueue 对应一个包含 topic+messageQueueId 的路径，该路径下会创建多个文件，存储消息的索引和过滤信息</p>
<ul>
<li>每条消息在 messageQueue 上占 20 字节：commitLogOffset、msgSize、消息在 MessageQueue 扩展队列的地址</li>
<li>每个文件大小 mappedFileSize 默认为 20 字节*30W，即每个文件最多存储 30W 条消息</li>
<li>每条消息在扩展对列上存储：所有通过 sql 校验的 consumerGroup 组成的布隆过滤器 bit 数组、消息的 tagsHashCode</li>
</ul>
<p>按 topic+queueId 查内存，获取 MessageQueue。它主要封装了 MappedFileQueue，表示实际存储 MessageQueue 的路径下所有文件的 PageCache 缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumeQueue &#123;</span><br><span class="line">    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    // messageQueue上的每条消息的大小，20字节=commitLogOffset+msgSize+tagsHashCode</span><br><span class="line">    public static final int CQ_STORE_UNIT_SIZE = 20;</span><br><span class="line"></span><br><span class="line">    private final MappedFileQueue mappedFileQueue;</span><br><span class="line">    private final String topic;</span><br><span class="line">    private final int queueId;</span><br><span class="line"></span><br><span class="line">    private final String storePath;</span><br><span class="line">    // 默认20字节*30W，即一个MessageQueue最多存储30W条消息</span><br><span class="line">    private final int mappedFileSize;</span><br><span class="line"></span><br><span class="line">    public ConsumeQueue(final String topic, final int queueId, final String storePath, final int mappedFileSize, final DefaultMessageStore defaultMessageStore) &#123;</span><br><span class="line">        this.storePath = storePath;</span><br><span class="line">        this.mappedFileSize = mappedFileSize;</span><br><span class="line">        this.defaultMessageStore = defaultMessageStore;</span><br><span class="line"></span><br><span class="line">        this.topic = topic;</span><br><span class="line">        this.queueId = queueId;</span><br><span class="line"></span><br><span class="line">        String queueDir = this.storePath + File.separator + topic + File.separator + queueId;</span><br><span class="line"></span><br><span class="line">        this.mappedFileQueue = new MappedFileQueue(queueDir, mappedFileSize, null);</span><br><span class="line"></span><br><span class="line">        this.byteBufferIndex = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">        if (defaultMessageStore.getMessageStoreConfig().isEnableConsumeQueueExt()) &#123;</span><br><span class="line">            this.consumeQueueExt = new ConsumeQueueExt(topic, queueId, StorePathConfigHelper.getStorePathConsumeQueueExt(defaultMessageStore.getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore.getMessageStoreConfig().getMappedFileSizeConsumeQueueExt(), defaultMessageStore.getMessageStoreConfig().getBitMapLengthConsumeQueueExt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ConsumeQueue findConsumeQueue(String topic, int queueId) &#123;</span><br><span class="line">    ConcurrentMap&lt;Integer, ConsumeQueue&gt; map = consumeQueueTable.get(topic);</span><br><span class="line">    if (null == map) &#123;</span><br><span class="line">        ConcurrentMap&lt;Integer, ConsumeQueue&gt; newMap = new ConcurrentHashMap&lt;Integer, ConsumeQueue&gt;(128);</span><br><span class="line">        ConcurrentMap&lt;Integer, ConsumeQueue&gt; oldMap = consumeQueueTable.putIfAbsent(topic, newMap);</span><br><span class="line">        if (oldMap != null) &#123;</span><br><span class="line">            map = oldMap;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumeQueue logic = map.get(queueId);</span><br><span class="line">    … …</span><br><span class="line">    return logic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位在-MessageQueue-的起始消费位置"><a href="#定位在-MessageQueue-的起始消费位置" class="headerlink" title="定位在 MessageQueue 的起始消费位置"></a>定位在 MessageQueue 的起始消费位置</h3><p>根据 request 传入的起始消息 offset，先定位具体存储该条消息的文件的 PageCache，再计算 offset 在该文件的起始字节位置，返回从该位置开始的 ByteBuffer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public SelectMappedBufferResult getIndexBuffer(final long startIndex) &#123;</span><br><span class="line">    int mappedFileSize = this.mappedFileSize;</span><br><span class="line">    long offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line">    if (offset &gt;= this.getMinLogicOffset()) &#123;</span><br><span class="line">        // 根据offset到MassageQueue的文件列表里拿到存储该条消息的文件，返回该文件映射的PageCache对象MappedFile</span><br><span class="line">        MappedFile mappedFile = this.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class="line">        if (mappedFile != null) &#123;</span><br><span class="line">            // offset % mappedFileSize 是该条消息在文件里的起始字节位置，返回从该位置开始的ByteBuffer</span><br><span class="line">            SelectMappedBufferResult result = mappedFile.selectMappedBuffer((int) (offset % mappedFileSize));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定位是哪个文件其实很简单，根据 offset 计算消息存储在哪个字节处（offset*20，20 为每条消息的存储空间），然后除每个文件的最大字节数（20 字节*30W）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line">... ...</span><br><span class="line">int index = (int) ((offset / this.mappedFileSize) - (firstMappedFile.getFileFromOffset() / this.mappedFileSize));</span><br></pre></td></tr></table></figure>

<p>定位在文件上的起始字节位置也同理，对单个文件最大字节数取余即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SelectMappedBufferResult result = mappedFile.selectMappedBuffer((int) (offset % mappedFileSize));</span><br></pre></td></tr></table></figure>

<h3 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h3><p>拿到起始位置的 ByteBuffer 后，每 20 字节开始读取消息在 ByteBuffer 上的索引和过滤信息</p>
<ul>
<li>注意，tagsCode 实际为消息在扩展队列的地址，tagsCode 和所有通过 sql 过滤的布隆过滤器 bit 数组都存储在扩展队列</li>
<li>最多读取消息数可以在 request 里指定，如果不指定默认为 16000&#x2F;20 &#x3D; 800。当然还没读到这些消息 messageQueue 就读完了也会退出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">... ...</span><br><span class="line">for (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">    long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">    int sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">    long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用此次消息拉取请求的消息过滤器 MessageFilter，判断消息是否满足过滤条件。实际调用方法为：org.apache.rocketmq.broker.filter.ExpressionMessageFilter#isMatchedByConsumeQueue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (messageFilter != null</span><br><span class="line">        // 消息是否满足tag过滤和sql过滤</span><br><span class="line">    &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) &#123;</span><br><span class="line">    if (getResult.getBufferTotalSize() == 0) &#123;</span><br><span class="line">        status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 tag 或者基于 sql 的消息过滤规则上面说过了，代码也很清晰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) &#123;</span><br><span class="line">    if (null == subscriptionData) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (subscriptionData.isClassFilterMode()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // by tags code.</span><br><span class="line">    if (ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line"></span><br><span class="line">        if (tagsCode == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return subscriptionData.getCodeSet().contains(tagsCode.intValue());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // no expression or no bloom</span><br><span class="line">        if (consumerFilterData == null || consumerFilterData.getExpression() == null</span><br><span class="line">            || consumerFilterData.getCompiledExpression() == null || consumerFilterData.getBloomFilterData() == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // message is before consumer</span><br><span class="line">        if (cqExtUnit == null || !consumerFilterData.isMsgInLive(cqExtUnit.getMsgStoreTime())) &#123;</span><br><span class="line">            log.debug(&quot;Pull matched because not in live: &#123;&#125;, &#123;&#125;&quot;, consumerFilterData, cqExtUnit);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] filterBitMap = cqExtUnit.getFilterBitMap();</span><br><span class="line">        BloomFilter bloomFilter = this.consumerFilterManager.getBloomFilter();</span><br><span class="line">        if (filterBitMap == null || !this.bloomDataValid</span><br><span class="line">            || filterBitMap.length * Byte.SIZE != consumerFilterData.getBloomFilterData().getBitNum()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BitsArray bitsArray = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bitsArray = BitsArray.create(filterBitMap);</span><br><span class="line">            // 如果consumerGroup的布隆过滤bit数组在所有满足sql的consumerGroup组成的布隆过滤bit数组中，则认为sql过滤通过</span><br><span class="line">            // （可能误判，还需要实际执行sql表达式来判断是否满足）</span><br><span class="line">            boolean ret = bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray);</span><br><span class="line">            log.debug(&quot;Pull &#123;&#125; by bit map:&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, ret, consumerFilterData, bitsArray, cqExtUnit);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.error(&quot;bloom filter error, sub=&quot; + subscriptionData</span><br><span class="line">                + &quot;, filter=&quot; + consumerFilterData + &quot;, bitMap=&quot; + bitsArray, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 MessageFilter 过滤通过了，从 commitLog 里取出实际的消息体内存映射 MappedByteBuffer。取的逻辑和上面 MessageQueue 一样，先根据 commitLogOffset 做除法定位文件，然后取余定位具体内存位置</p>
<ul>
<li>CommitLog 每个文件大小默认为 1G</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public SelectMappedBufferResult getMessage(final long offset, final int size) &#123;</span><br><span class="line">    int mappedFileSize = this.defaultMessageStore.getMessageStoreConfig().getMappedFileSizeCommitLog();</span><br><span class="line">    MappedFile mappedFile = this.mappedFileQueue.findMappedFileByOffset(offset, offset == 0);</span><br><span class="line">    if (mappedFile != null) &#123;</span><br><span class="line">        int pos = (int) (offset % mappedFileSize);</span><br><span class="line">        return mappedFile.selectMappedBuffer(pos, size);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到实际消息体后，如果按 sql 过滤，还要实际执行一遍 sql 表达式来确认是否满足，因为布隆过滤器可能误判</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map&lt;String, String&gt; properties) &#123;</span><br><span class="line">    if (subscriptionData == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (subscriptionData.isClassFilterMode()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumerFilterData realFilterData = this.consumerFilterData;</span><br><span class="line">    Map&lt;String, String&gt; tempProperties = properties;</span><br><span class="line"></span><br><span class="line">    // no expression</span><br><span class="line">    if (realFilterData == null || realFilterData.getExpression() == null</span><br><span class="line">        || realFilterData.getCompiledExpression() == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tempProperties == null &amp;&amp; msgBuffer != null) &#123;</span><br><span class="line">        tempProperties = MessageDecoder.decodeProperties(msgBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object ret = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        MessageEvaluationContext context = new MessageEvaluationContext(tempProperties);</span><br><span class="line">        // 执行sql表达式判断消息是否真的满足过滤条件，因为布隆过滤器可能误判</span><br><span class="line">        ret = realFilterData.getCompiledExpression().evaluate(context);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        log.error(&quot;Message Filter error, &quot; + realFilterData + &quot;, &quot; + tempProperties, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(&quot;Pull eval result: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, ret, realFilterData, tempProperties);</span><br><span class="line"></span><br><span class="line">    if (ret == null || !(ret instanceof Boolean)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (Boolean) ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置下次 consumer 拉取消息的起始 offset。i 为这次读到的内存位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 更新下次消息拉取的起始offset。for循环读取messageQueue消息时做了计数，所以下次拉取消息的offset就是这次的offset加上计数器的值</span><br><span class="line">nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br></pre></td></tr></table></figure>

<p>遍历完 MessageQueue 后，把满足条件的消息从 MappedByteBuffer 移到堆内存，然后转成字节数组赋值给 response</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 把消息在PageCache的缓存数据读取到堆内存，转成字节数组，放到响应的body里</span><br><span class="line">final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br></pre></td></tr></table></figure>

<h3 id="如果没拉取到消息"><a href="#如果没拉取到消息" class="headerlink" title="如果没拉取到消息"></a>如果没拉取到消息</h3><p>遍历完 MessageQueue 后如果没有符合过滤条件的消息，broker 会把请求挂起，这时不会发送响应给 consumer。<br>如果 broker 支持长轮训，挂起的时间为 consumer 发送请求时指定的时间。如果不支持长轮训，则使用短轮训，默认挂起 1s。</p>
<ul>
<li>所谓挂起，是把 consumerGroup 在该 messageQueue 上的消息拉取请求存到 map 里</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果没有满足条件的新消息，把consumer的请求缓存起来，然后返回null，此时不会给consumer发送响应</span><br><span class="line">this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) &#123;</span><br><span class="line">    String key = this.buildKey(topic, queueId);</span><br><span class="line">    ManyPullRequest mpr = this.pullRequestTable.get(key);</span><br><span class="line">    if (null == mpr) &#123;</span><br><span class="line">        mpr = new ManyPullRequest();</span><br><span class="line">        ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            mpr = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpr.addPullRequest(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>broker 会有一个守护线程 PullRequestHoldService，如果支持长轮训，5s 执行一次，处理所有挂起的请求，如果是短轮询，1s 执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    log.info(&quot;&#123;&#125; service started&quot;, this.getServiceName());</span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                this.waitForRunning(5 * 1000);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long beginLockTimestamp = this.systemClock.now();</span><br><span class="line">            this.checkHoldRequest();</span><br><span class="line">            long costTime = this.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            if (costTime &gt; 5 * 1000) &#123;</span><br><span class="line">                log.info(&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;&#123;&#125; service end&quot;, this.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理挂起请求的逻辑是：<br>如果 messageQueue 在 hold 开始后又有新消息，或者超过最大 hold 时长，发送消息拉取结果给 consumer，让它发送新的请求过来，从新的 beginOffset 开始继续拉取消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">    	… …</span><br><span class="line">        try &#123;</span><br><span class="line">            this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                request.getRequestCommand());</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.error(&quot;execute request when wakeup failed.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">            request.getRequestCommand());</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        log.error(&quot;execute request when wakeup failed.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习分布式事务</title>
    <url>/2020/12/21/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h1><p>通过这篇文章，你能了解到：</p>
<ul>
<li>CAP 的含义<ul>
<li>一致性、可用性、分区容错性</li>
</ul>
</li>
<li>刚性分布式事务和柔性分布式事务的区别<ul>
<li>CP 型和 AP 型</li>
</ul>
</li>
<li>分布式事务的实现原理：二阶段提交 2PC<ul>
<li>事务执行分为确认阶段和执行阶段。确认阶段进行逻辑校验和资源预留，执行阶段由事务管理器负责，不断重试保证分布式事务执行后的数据一致性</li>
</ul>
</li>
<li>AP 型分布式事务的实际使用案例<ul>
<li>TCC<ul>
<li>TCC 是一种分布式事务的编程模型，它将分布式事务拆分为 try-confirm-cancel 三个步骤，try 和 confirm 负责执行事务，其中任何一步执行失败都会在 cancel 阶段执行回滚</li>
</ul>
</li>
<li>rocketmq 的事务消息<ul>
<li>2PC 的确认阶段：prepare 半事务消息+本地事务+commit 消息+mqBroker 回调查询本地事务结果。2PC 的执行阶段：mqBroker 保证事务消息一定可被投递到消费端执行分布式事务。回滚阶段：本地事务执行失败，发 rollback 消息，删除 mqBroker 侧的 prepare 消息</li>
</ul>
</li>
<li>本地事务消息表<ul>
<li>把分布式事务的 mq 消息落库操作和本地事务做在一起。定时扫表发送分布式事务消息，成功后从本地事务消息表删除。不推荐，不如直接用 mq 的事务消息</li>
</ul>
</li>
<li>补偿型分布式事务<ul>
<li>适合于每个分布式事务一定可被执行。通过注解+aop 方式，对执行分布式事务的方法做增强，如果执行失败，写补偿表，定时扫补偿表重试该方法，需要每个分布式事务做幂等。但这种方式完全放弃了一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h1><p>分布式系统中，数据可能分布在多个缓存服务器、数据库中，且这些服务器、数据库往往都部署在多个网络分组中，所以可以说：<code>分布式系统中，数据是多网络环境多物理空间存储的</code></p>
<p>多网络分组、多物理空间存储的数据，核心问题就是要<code>解决数据读取一致性</code>。因此，就有了 CAP 理论来描述这种问题</p>
<p>CAP 即 Consistency、Avaliability、PartitionTolerence，一般分布式系统<code>只能保证CP或AP，无法同时满足CAP</code></p>
<p>Consistency 即一致性，需要保证任何时刻分布式系统中数据存储的结果是一致的。因此数据写入时，需要对写入的所有分布式空间加读写锁，这期间数据是无法被外部访问的，因此不满足 Avaliability，即可用性。所以分布式系统中一致性和可用性是相互矛盾的，无法同时满足</p>
<p>PartitionTolerence 即分区容错性。分布式系统中服务器、数据库会部署在多个网络分组中（分区的含义），相互间通信需要网络调用，因此超时、丢包问题无法避免，因此需要容忍网络超时或丢包问题（容错的含义）。所以分布式系统必须具备 P，分区容错性，可以<code>通过回滚或重试来保证分区容错性</code></p>
<h1 id="分布式事务的实现方案"><a href="#分布式事务的实现方案" class="headerlink" title="分布式事务的实现方案"></a>分布式事务的实现方案</h1><p>CAP 理论在分布式系统的实际应用体现在分布式事务中。满足 CP 的分布式事务称为刚性分布式事务，对数据一致性是刚需的。反之是柔性分布式事务，对数据一致性不是刚需，只要保证最终一致性即可，但要保证可用性，即满足 AP</p>
<h2 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h2><p>无论是 CP 型还是 AP 型分布式事务，二阶段提交（2PC，2 phase commit）都是一个常用的理论方案。二阶段提交将事务的执行拆分为两个阶段，即确认阶段和执行阶段。确认阶段由业务验证事务执行的合法性，并预留资源。执行阶段往往由事务管理器负责，保证分布式事务一定被全部执行</p>
<p>只有在确认阶段所有事务执行者都确认并预留资源成功，才会在执行阶段真正执行分布式事务，否则回滚预留资源，分布式事务执行失败</p>
<h2 id="CP-型分布式事务的实现方案"><a href="#CP-型分布式事务的实现方案" class="headerlink" title="CP 型分布式事务的实现方案"></a>CP 型分布式事务的实现方案</h2><p>CP 型分布式事务的执行效果和执行本地事务是一致的，要么都成功，要么全部回滚，且事务执行期间，外部无法访问数据。即 CP 型分布式事务满足事务的 ACID 特性，原子性、一致性、隔离性、持久化。</p>
<h3 id="二阶段提交-XA-协议"><a href="#二阶段提交-XA-协议" class="headerlink" title="二阶段提交-XA 协议"></a>二阶段提交-XA 协议</h3><p>实现 CP 型分布式事务的典型代表是 XA 协议，它将分布式系统划分为：业务应用、资源管理器、事务管理器。由事务管理器承接业务应用的分布式事务请求，面向资源管理器（各类商业数据库）统一执行分布式事务</p>
<p>XA 协议基于二阶段提交，由事务管理器先向所有<code>实现了XA接口的资源管理器</code>发起投票，称为 prepare 阶段。如果 prepare 阶段有投票反对，由事务管理器对所有资源管理器发起回滚。如果投票全部通过，执行分布式事务，称为 commit 阶段。这个过程中如果资源管理器宕机或网络请求异常，由事务管理器进行重试补偿</p>
<p>资源在 prepare 阶段就已经被锁定，直到回滚或所有数据 commit 成功后才释放，需要长时间锁定资源的读写，因此不适合长事务，不满足高并发场景，实际应用中使用较少</p>
<h2 id="AP-型分布式事务的实现方案"><a href="#AP-型分布式事务的实现方案" class="headerlink" title="AP 型分布式事务的实现方案"></a>AP 型分布式事务的实现方案</h2><p>AP 型分布式事务保证数据最终一致性，不会锁定资源的读写操作，过程中可能出现短暂的数据不一致，但适合高并发场景。<br><code>最终一致性在互联网应用场景中被广泛用做吞吐量和ACID的妥协点</code></p>
<h3 id="TCC-编程模式"><a href="#TCC-编程模式" class="headerlink" title="TCC 编程模式"></a>TCC 编程模式</h3><p>所谓的 TCC 编程模式，是二阶段提交的一个变种。TCC 提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm 和 Cancel 三个操作。以在线下单为例，Try 阶段会去扣库存，Confirm 阶段则是去更新订单状态，如果更新订单失败，则进入 Cancel 阶段，会去恢复库存。总之，TCC 就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。</p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>阿里云 RocketMQ 的事务消息能实现分布式事务的最终一致性，是一种 AP 型分布式事务的解决方案。它核心思想还是借鉴了二阶段提交</p>
<p>mq 的 broker 扮演事务管理器的角色，broker 需要得到业务方（消息生产者）真正的确认回执，然后由 broker 保证消息一定能投递到消费端完成分布式事务中后续的事务执行操作，达到事务最终一致性。具体的执行过程描述如下</p>
<p>二阶段提交的确认阶段：</p>
<ul>
<li>业务应用首先发送 prepare 消息（半事务消息）到 MQ</li>
<li>在发送 prepare 消息成功后执行本地事务</li>
<li>根据本地事务执行结果返回 commit 或者是 rollback<ul>
<li>commit 后的消息称为事务消息</li>
<li>如果消息是 rollback，MQ 将删除该 prepare 消息不进行下发</li>
</ul>
</li>
<li>如果 broker 长时间拿不到半事务消息的结果（例如业务应用挂了或网络超时），broker 会主动调业务应用查询事务状态<ul>
<li>需要业务应用实现回调接口</li>
</ul>
</li>
</ul>
<p>二阶段提交的执行阶段：</p>
<ul>
<li>mq 保证事务消息一定能被消费端成功消费<ul>
<li>投递失败会重试，因此消费方需要保证分布式事务幂等执行</li>
</ul>
</li>
</ul>
<p>你可能会问，我何不把发 mq 消息也放到本地事务里，一旦发 mq 消息失败，本地事务就回滚，不也能实现分布式事务么？实际上这是有问题的，事务消息能保证本地事务和消息投递的强一致性，只要本地事务执行成功，一定能由 mq 服务端保证分布式事务执行成功。但如果把发 mq 放到本地事务，可能本地事务成功了，mq 发送失败，但这却要回滚本地事务，对资源是一种浪费。</p>
<h3 id="本地事务消息表"><a href="#本地事务消息表" class="headerlink" title="本地事务消息表"></a>本地事务消息表</h3><p>本地事务消息表的实现方案：</p>
<ul>
<li>创建本地事务消息表</li>
<li>执行本地事务和消息数据写入本地事务表放在一个事务里，保证本地事务执行和消息投递的强一致性</li>
<li>定时任务从消息表中获取消息数据</li>
<li>发送消息</li>
<li>删除本地消息</li>
</ul>
<p>该方案也是 AP 事务的一种实现，和事务消息相比，引入定时器且需要额外的存储资源，也仍然需要依赖分布式消息队列如 rocketMq，复杂度和资源开销都更高，不推荐</p>
<h3 id="补偿型分布式事务"><a href="#补偿型分布式事务" class="headerlink" title="补偿型分布式事务"></a>补偿型分布式事务</h3><p>补偿型分布式事务适用于一定可以执行分布式事务的业务，解决一些分布式事务执行过程中因网络抖动、丢包造成的失败场景</p>
<p>一连串分布式事务操作同步调用时，极易发生接口整体超时情况，因此特别适合于补偿型分布式事务</p>
<p>实现上可以通过 TOC 方式：</p>
<ul>
<li>定义一个补偿表，保存分布式事务执行方法的 bean 名称，方法签名，方法参数</li>
<li>定义一个补偿注解，加在分布式事务方法上</li>
<li>通过 aop 将带上注解的方法作为切面方法做增强，如果分布式事务方法执行失败或异常，写入补偿表</li>
<li>通过定时任务扫表补偿。当然，需要保证分布式事务执行的每一个方法都幂等，否则不能补偿</li>
</ul>
<p>这种补偿型分布式事务，通过 aop+注解的方式减少对业务侵入，但它完全放弃了一致性，且不支持回滚</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/m0_38110132/article/details/77043580">https://blog.csdn.net/m0_38110132/article/details/77043580</a><br><a href="https://blog.csdn.net/m0_38110132/article/details/76994165">https://blog.csdn.net/m0_38110132/article/details/76994165</a></p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习分布式锁</title>
    <url>/2020/07/31/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p>
<h1 id="为什么要用分布式锁"><a href="#为什么要用分布式锁" class="headerlink" title="为什么要用分布式锁"></a>为什么要用分布式锁</h1><p>单机环境，可以使用一些同步组件或关键字 Synchronized 保证线程安全，但分布式环境下如何保证多个进程之间的线程安全性？</p>
<h1 id="分布式锁的几种方案"><a href="#分布式锁的几种方案" class="headerlink" title="分布式锁的几种方案"></a>分布式锁的几种方案</h1><h2 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁有以下问题：</p>
<ul>
<li>多表更新的性能问题。如果竞争的共享资源是单个表，适合用乐观锁。如果涉及 N 张表，每张表的更新都用乐观锁，冲突的概率扩大 N 倍，性能有问题</li>
<li>不适合插入操作。乐观锁只适合数据更新，如果需求是多进程都要插入同一条数据，但只能保证插入一条（类似单例模式），就无法用到乐观锁</li>
</ul>
<h3 id="排它锁（悲观锁）"><a href="#排它锁（悲观锁）" class="headerlink" title="排它锁（悲观锁）"></a>排它锁（悲观锁）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin transaction；</span><br><span class="line">select ...for update；</span><br><span class="line">doSomething()；</span><br><span class="line">commit();</span><br></pre></td></tr></table></figure>

<p>这种处理主要依靠排他锁来阻塞其他线程，不过这个需要注意几点：</p>
<ul>
<li>查询的数据要命中索引，否则会加 gap 锁，造成大面积的行锁，影响性能</li>
<li>避免长事务</li>
</ul>
<h3 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h3><p>通过在一张表里创建唯一键来获取锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert table lock_store (&#x27;method_name&#x27;) values($method_name)</span><br></pre></td></tr></table></figure>

<p>其中 method_name 是个唯一键，通过这种方式也可以做到，解锁的时候直接删除该行记录就行</p>
<h2 id="基于-zk"><a href="#基于-zk" class="headerlink" title="基于 zk"></a>基于 zk</h2><p>zk 可被用作分布式锁，主要由于具备以下两个特性</p>
<ul>
<li>zk 以 k-v 的形式存储数据，存储结构为树状结构，这保证了同级目录下不存在相同的节点，即 zk 不会存储两个相同的 key</li>
<li>zk 的数据节点类型分为持久节点、临时节点和顺序节点。与持久节点相比，临时节点会在 zk 客户端会话超时或发生异常而关闭时被删除（当然持久节点、临时节点都可以由 zk 客户端操作手动删除）。顺序节点指在持久节点或临时节点的基础上，key 值用 uuid+自增序号组成，按时间保证顺序</li>
</ul>
<p>zk 实现非公平分布式锁：</p>
<ul>
<li>在父节点（持久节点）下创建 zk 临时节点，保证 zk 客户端异常断联也会删除节点</li>
<li>创建成功则认为拿到分布式锁。失败，说明临时节点已存在，通过 CDL 阻塞当前线程，同时监听该节点的删除操作，一旦该节点删除，CDL 执行 countdown，唤醒当前线程，拿到分布式锁</li>
</ul>
<p>问题：</p>
<ul>
<li>如果并发高，释放分布式锁会回调大量 zk 客户端监听，产生羊群效应，性能不好</li>
</ul>
<p>解法：</p>
<ul>
<li>利用临时有序节点实现分布式公平锁，每次只回调一个 zk 客户端监听，公平有序获取分布式锁</li>
</ul>
<p>zk 实现公平分布式锁：</p>
<ul>
<li>在父节点（持久节点）下创建 zk 临时有序节点</li>
<li>获取父节点目录下所有的子节点并排序。如果当前临时有序节点就是子节点的第一个节点，则获得锁。如果不是，设置监听当前节点的上一个节点的删除事件，然后阻塞当前线程，直到监听到前一节点删除事件，通过 CDL 机制唤醒当前线程，再次判断当前节点如果是最小的节点，则获得锁</li>
</ul>
<p>Netflix 公司基于 ZK 封装了一整套分布式锁开源框架<code>Curator</code>，目前已贡献给 Apache 开源组织，它不仅实现了公平分布式锁，还提供了可重入特性：</p>
<ul>
<li>通过一个 concurrentHashMap 存储线程已重入次数</li>
<li>线程获取分布式锁先从 concurrentHashMap 取当前线程的可重入次数，不为空且大于 0 说明当前线程已经拿到分布式锁，重入次数+1</li>
<li>如果第一次获取到公平分布式锁，初始化当前线程的可重入次数为 1</li>
<li>释放锁时，不仅要删除 zk 临时节点，还要从 concurrentHashMap 里 remove 当前线程的重入次数</li>
</ul>
<h2 id="基于-Redis"><a href="#基于-Redis" class="headerlink" title="基于 Redis"></a>基于 Redis</h2><p>以 Redis 的 setNx 命令执行成功与否，来判断是否获取基于 Redis 的分布式锁。不过要注意以下问题</p>
<h3 id="锁失效问题"><a href="#锁失效问题" class="headerlink" title="锁失效问题"></a>锁失效问题</h3><p>这种情况通常是取得分布式锁的线程执行时间超过锁到期时间，例如发生了 GC。等执行完业务逻辑后，再次释放 Redis 锁（delete）时，可能释放了其他线程的分布式锁</p>
<p>解法：</p>
<ul>
<li>value 传 requestId，然后我们在释放锁的时候判断一下，如果是当前 requestId，那就可以释放，否则不允许释放。这种方案依然不能完全解决问题，因为判断 requestId 和释放锁不是原子操作，不过可以将这两个操作写在一个 lua 脚本里，调用<code>jedis.eval</code>执行，redis 保证 lua 脚本里的操作满足原子性。</li>
</ul>
<p>尽管如此，当 FGC 过久或者接口调用发生网络超时，线程执行时间可能超过锁过期时间，这时分布式锁就起不到作用了，该如何解决？</p>
<p>用<code>续命锁（watchdog看门狗）</code>的方案，redis 客户端定义一个子线程，定时去查看是否主线程依然持有当前锁，如果是，则为其延长锁过期时间，RedissonLock（Redis 的 Java 客户端）的 lock 方法就使用了续命锁，默认锁过期时间是 30s，每 10s（1&#x2F;3 的锁过期时间）检查一次，续 30s</p>
<ul>
<li>你可能会想，既然 Redis 锁那么容易过期，我把过期时间延长或者干脆永不过期就好了。但这么做可能有更严重的后果，试想如果加锁成功的线程异常了（没有在 finally 里释放 tair 锁）或者进程挂了，没有释放 Redis 锁，那么就产生了“死锁”，其他线程就会长时间“阻塞”！</li>
</ul>
<h3 id="主从同步问题（单点问题）"><a href="#主从同步问题（单点问题）" class="headerlink" title="主从同步问题（单点问题）"></a>主从同步问题（单点问题）</h3><p>当主 Redis 加锁了，开始执行线程，若还未将锁通过异步同步的方式同步到从 Redis 节点，主节点就挂了，此时会把某一台从节点作为新的主节点，此时别的线程就可以加锁了。本质是因为 Redis 是 AP 型服务，优先服务可用性，而非数据一致性</p>
<p>解法：</p>
<ul>
<li>采用 zookeeper 代替 Redis<ul>
<li>由于 zk 集群的特点，其支持的是 CP。而 Redis 集群支持的则是 AP。</li>
</ul>
</li>
<li>采用 RedLock<ul>
<li>RedLock 机制，需要 client 向超过一半的 Redis 节点加锁成功才认为取得了分布式锁。否则释放已加锁的 Redis 节点。为什么要超过一半？很容易理解，如果不超过一半节点，其他线程的 RedLock 也能加锁成功，锁就失效了</li>
<li>如果并发高，多个线程同时竞争同一个 redis 锁，用 RedLock 机制可能造成每个线程都在部分节点加锁成功，但最后谁都没真正拿到分布式锁，因此重试的时候需要随机等待一段时间再重试</li>
<li>具体使用存在争议，例如加了锁的其中几个 redis 节点挂了，RedLock 机制就失效了，其他线程尝试获取锁会成功，因此不太推荐使用 RedLock。如果考虑高可用并发推荐使用 Redisson，考虑一致性推荐使用 zookeeper</li>
</ul>
</li>
</ul>
<h3 id="不具备可重入能力"><a href="#不具备可重入能力" class="headerlink" title="不具备可重入能力"></a>不具备可重入能力</h3><p>解法：加入锁计数 count，在获取锁的时候查询一次，如果是当前线程已经持有的锁（通过 requestId 判断），count 加 1，获取锁成功</p>
<p>简单实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static volatile int count = 0;</span><br><span class="line">public boolean lock(String key, V v, int expireTime)&#123;</span><br><span class="line">    int retry = 0;</span><br><span class="line">    //获取锁失败最多尝试10次</span><br><span class="line">    while (retry &lt; failRetryTimes)&#123;</span><br><span class="line">        //1.先获取锁,如果是当前线程已经持有，则直接返回</span><br><span class="line">        //2.防止后面设置锁超时，其实是设置成功，而网络超时导致客户端返回失败，所以获取锁之前需要查询一下</span><br><span class="line">        V value = redis.get(key);</span><br><span class="line">        //如果当前锁存在，并且属于当前线程持有，则锁计数+1，直接返回</span><br><span class="line">        if (null != value &amp;&amp; value.equals(v))&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果锁已经被持有了，那需要等待锁的释放</span><br><span class="line">        if (value == null || count &lt;= 0)&#123;</span><br><span class="line">            //获取锁</span><br><span class="line">            Boolean result = redis.setNx(key, v, expireTime);</span><br><span class="line">            if (result)&#123;</span><br><span class="line">                count = 1;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //获取锁失败间隔一段时间重试</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(sleepInterval);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">public boolean unlock(String key, String requestId)&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    if (Strings.isNullOrEmpty(value))&#123;</span><br><span class="line">        count = 0;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断当前锁的持有者是否是当前线程，如果是的话释放锁，不是的话返回false</span><br><span class="line">    if (value.equals(requestId))&#123;</span><br><span class="line">        if (count &gt; 1)&#123;</span><br><span class="line">            count -- ;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean delete = redis.delete(key);</span><br><span class="line">        if (delete)&#123;</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return delete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer productId = 324324;</span><br><span class="line">    RedisLock&lt;String&gt; redisLock = new RedisLock&lt;String&gt;();</span><br><span class="line">    String requestId = UUID.randomUUID().toString();</span><br><span class="line">    redisLock.lock(productId+&quot;&quot;, requestId, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>由于锁的作用实际上就是将并行的请求转化为串行请求。这样就降低了并发度。为了解决这一问题，可以将锁进行分段处理：例如秒杀商品 A，原本存在 1000 个库存，可以将其分为 20 段，key&#x3D;A1，A2…A20，用 20 个 Redisson 做分布式锁，独立处理库存扣减</p>
<h3 id="get-x2F-put-version"><a href="#get-x2F-put-version" class="headerlink" title="get&#x2F;put + version"></a>get&#x2F;put + version</h3><ul>
<li>先执行 get 操作<ul>
<li>如果为 null，再 put，version&#x3D;1，value&#x3D;true。<ul>
<li>成功则获取到分布式锁，执行业务代码，再释放锁，执行 put，version&#x3D;1，value&#x3D;false。释放锁失败增加报警</li>
<li>失败则说明锁已被抢占，获取分布式锁失败</li>
</ul>
</li>
<li>如果不为 null，判断 value<ul>
<li>value 为 true，说明锁已被抢占，获取分布式锁失败</li>
<li>value 为 false，说明锁已被释放。尝试 put，version&#x3D;当前 version，value&#x3D;true<ul>
<li>成功则获取到分布式锁，执行业务代码，再释放锁，执行 put，version&#x3D;version+1，value&#x3D;false。释放锁失败增加报警</li>
<li>失败则说明锁已被抢占，获取分布式锁失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>tips：锁过期时间尽量久一点，保证每次释放锁都成功</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习流控技术</title>
    <url>/2017/03/14/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%B5%81%E6%8E%A7%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>流控的含义：</p>
<ul>
<li>限制单位时间内的请求量</li>
</ul>
<p>流控的作用：</p>
<ul>
<li>高并发场景下，保证服务的可用性</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>实现流控的算法包括：固定窗口、滑动窗口、漏桶、令牌桶、滑动日志</p>
<h2 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h2><p>最简单的流控算法，核心思想是：给定时间窗口，维护一个计数器用于统计访问次数，并实现以下规则：</p>
<ul>
<li>如果访问次数小于阈值，则允许访问，访问次数+1；</li>
<li>如果访问次数超出阈值，则限制访问，访问次数不增；</li>
<li>如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间</li>
</ul>
<p>分布式环境下，可以使用tair缓存来统计访问次数</p>
<p>固定窗口算法的问题：</p>
<ul>
<li>存在<code>临界突变</code>问题，导致极端情况下单位时间内的请求量double于设置的阈值，达不到限流的效果<ul>
<li>假设1分钟内仅允许100个请求，时间窗口为0:00-1:00和1:00-2:00，若从0:50开始以10次&#x2F;秒的速度请求，则在临界0:50-1:00的20秒内系统承受了200次请求，没有实现限流的效果</li>
</ul>
</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>固定窗口存在临界突变问题的核心是统计调用次数的粒度太粗。滑动窗口为解决这个问题，把大的时间窗口拆分成若干粒度更细的子窗口，每个子窗口独立统计调用次数，按子窗口维度滑动来统计整体窗口内的调用次数</p>
<p>滑动窗口这样解决临界突变问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">滑动窗口将一分钟的时间窗口切分成6个子窗口，每个子窗口维护一个独立的计数器用于统计10秒内的访问量，每经过10s，时间窗口向右滑动一格。如果0:50到1:00进来了100次请求，由于算法统计的是6个子窗口的访问量总和，接下来1:00~1:10的请求就会被拒绝</span><br></pre></td></tr></table></figure>

<p>滑动窗口的问题：</p>
<ul>
<li>精度问题。滑动窗口无法控制任意给定时间内的请求量都小于阈值，无法保障系统的可靠性</li>
<li>平滑度问题。滑动窗口无法控制任意子时间窗口内流量的相对均匀性，导致流量超过一定范围后，流量被切断，无法保障系统的可用性</li>
</ul>
<h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>核心思想：基于出口流速来做流控，可以很好地解决平滑度问题，在网络通信中常用于流量整形</p>
<p>漏桶算法描述如下：</p>
<ul>
<li>漏桶具有固定容量和固定出水的速率，其中出水速率表示流控的qps阈值</li>
<li>请求qps速率以流入桶中的水的流速表示</li>
<li>如果桶满了，则流入的水滴溢出，表现为新请求被拒绝</li>
</ul>
<p>由此可知，漏桶算法对流量激增有一定容忍度，靠桶内容量兜住。除非qps持续激增，桶满了才会拒绝请求，否则当调用方qps低于阈值后，桶内的水不断流出，系统在流量激增和下降阶段依然能正常提供服务，这就解决了平滑度问题，调用方的请求不会突然间全部拒绝</p>
<h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>和漏桶算法我认为没区别。基于入口流速来做流控，qps阈值表示往桶中放令牌的速度。外部请求表示从桶中拿令牌，只有当拿不到令牌时才拒绝请求。</p>
<h2 id="滑动日志"><a href="#滑动日志" class="headerlink" title="滑动日志"></a>滑动日志</h2><p>核心思想：记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。</p>
<p>滑动日志的问题</p>
<ul>
<li>时间复杂度&amp;空间复杂度较大。<ul>
<li>首先，我们要保存一个长度最大为<code>N=qps*t</code>的队列，这意味着空间复杂度达到O(N)</li>
<li>其次，我们需要在队列中寻找t时间范围内的请求总数。以二分查找为例，时间复杂度是O(logN)。</li>
</ul>
</li>
</ul>
<h2 id="流控算法对比"><a href="#流控算法对比" class="headerlink" title="流控算法对比"></a>流控算法对比</h2><table>
<thead>
<tr>
<th>算法</th>
<th>原理</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>问题</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>固定窗口</td>
<td>固定时间窗口计数</td>
<td>O(1)</td>
<td>O(1)</td>
<td>临界突变</td>
<td>容易实现，适用于一些简单的流控场景，流量比较均匀，或者允许临界突变</td>
</tr>
<tr>
<td>滑动窗口</td>
<td>窗口拆分，子窗口独立统计，按窗口时间滑动，统一限流。</td>
<td>O(1)</td>
<td>O(M) - M为子窗口数</td>
<td>精度&amp;平滑度</td>
<td>适用大多数场景，可以通过调节采样子窗口数来平衡开销</td>
</tr>
<tr>
<td>漏桶&#x2F;令牌桶算法</td>
<td>基于（出口&#x2F;入口）流速来做流控</td>
<td>O(1)</td>
<td>O(1)</td>
<td>精度</td>
<td>可做流量整形，容忍一定程度的突发流量</td>
</tr>
<tr>
<td>滑动日志</td>
<td>基于请求日志做流控</td>
<td>O(log(N))</td>
<td>O(N)-最大日志数</td>
<td>精度高，时间&amp;空间复杂度高</td>
<td>要求完全精确的控制，保证任意T时刻内流量不超过N，高时间和空间复杂度，性能最差</td>
</tr>
</tbody></table>
<h1 id="成熟产品"><a href="#成熟产品" class="headerlink" title="成熟产品"></a>成熟产品</h1><h2 id="Guava-RateLimiter"><a href="#Guava-RateLimiter" class="headerlink" title="Guava RateLimiter"></a>Guava RateLimiter</h2><p>基于令牌桶算法实现，有平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）两种实现</p>
<p>RateLimiter是采用令牌桶算法，但是如果单独起一个线程去发放令牌肯定不优雅，所以RateLimiter采用了一个很巧妙的方法：将一个时间段视作一个令牌（时间段的长度 &#x3D; 1&#x2F;限流值）。时间的匀速推进，就相当于在匀速的发放令牌，每次请求都会根据当前时间重新计算桶内令牌数</p>
<h3 id="SmoothBursty"><a href="#SmoothBursty" class="headerlink" title="SmoothBursty"></a>SmoothBursty</h3><p>当桶内有剩余令牌时，突然来一波流量，默认配置的SmoothBursty会放过去2倍限流值的流量</p>
<p>SmoothBursty类型的RateLimiter，会匀速的往桶里放入令牌，默认会存储1s的令牌，取令牌的时候优先消耗存储令牌，如果没有令牌则返回false（或者等待）。所以对于一波突发的流量，可能会出现2倍限流值的情况</p>
<h3 id="SmoothWarmingUp"><a href="#SmoothWarmingUp" class="headerlink" title="SmoothWarmingUp"></a>SmoothWarmingUp</h3><p>当桶内有剩余令牌时，突然来一波流量，SmoothWarmingUp的流量会呈爬坡型逐渐升高到限流值</p>
<p>取令牌的时候，会取令牌桶中的令牌，但是取走之后会设置一个等待时间tw（tw内不允许流量通过），这个等待时间tw是根据桶内的令牌来计算的，桶内存储的令牌越多，等待时间越长。所以这对突刺流量，真正通过的流量会是一个爬坡线。</p>
<p>预热区间决定了斜线的斜率，预热区间越大，斜率越小。（预热区间：创建限流器时的入参）</p>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习秒杀系统</title>
    <url>/2021/07/12/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.png"></p>
<h1 id="秒杀场景的技术挑战和对应的设计原则"><a href="#秒杀场景的技术挑战和对应的设计原则" class="headerlink" title="秒杀场景的技术挑战和对应的设计原则"></a>秒杀场景的技术挑战和对应的设计原则</h1><ul>
<li>并发高<ul>
<li>秒杀的服务、数据库单独部署</li>
<li>上游服务限流</li>
</ul>
</li>
<li>读多写少<ul>
<li>使用CDN静态化秒杀商品数据，商品详情页直接访问CDN</li>
</ul>
</li>
<li>超卖问题<ul>
<li>库存扣减使用本地缓存+redis分布式缓存</li>
<li>redis分段锁机制，提升并发度</li>
</ul>
</li>
</ul>
<h1 id="秒杀服务后端方案设计"><a href="#秒杀服务后端方案设计" class="headerlink" title="秒杀服务后端方案设计"></a>秒杀服务后端方案设计</h1><h2 id="异步方案"><a href="#异步方案" class="headerlink" title="异步方案"></a>异步方案</h2><ul>
<li>处理秒杀请求<ul>
<li>验证码校验</li>
<li>通过mq消息队列长度判断是否限流</li>
<li>发mq异步处理秒杀请求</li>
</ul>
</li>
<li>异步处理秒杀请求<ul>
<li>业务规则校验</li>
<li>扣减redis缓存中的商品库存</li>
<li>生成token</li>
</ul>
</li>
<li>短轮询秒杀资格<ul>
<li>返回token</li>
</ul>
</li>
<li>下单<ul>
<li>校验token<ul>
<li>过期，回补缓存里的商品库存</li>
<li>未过期，下单成功，删除token</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>上游通过mq限流，减轻了下游（应用服务器、redis）压力</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了额外缓存用户token的成本</li>
</ul>
<h2 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h2><p>与异步的区别：</p>
<ul>
<li>不用mq限流，处理秒杀请求时直接减库存，生成token</li>
<li>减库存策略不同，采取本地缓存减库存+redis缓存减库存<ul>
<li><code>异步方案采用mq限流，同步方案使用本地缓存拦截额外的请求，达到限流的效果。二者的本质目的都是减少redis减库存压力</code></li>
</ul>
</li>
</ul>
<h1 id="减库存方案优化"><a href="#减库存方案优化" class="headerlink" title="减库存方案优化"></a>减库存方案优化</h1><h2 id="本地缓存优化"><a href="#本地缓存优化" class="headerlink" title="本地缓存优化"></a>本地缓存优化</h2><p>本地缓存预设库存+buffer，防止服务器在高qps压力下宕机，造成少卖</p>
<ul>
<li>因为还要redis减库存成功才认为减库存成功，所以加buffer不会造成超卖。不过buffer加的过大起不到本地缓存限流的作用，因此需要折中考虑</li>
</ul>
<h2 id="redis缓存优化"><a href="#redis缓存优化" class="headerlink" title="redis缓存优化"></a>redis缓存优化</h2><p>库存过大时，使用redis存在热点key问题，且减库存的并发度不高</p>
<p>解法是分桶</p>
<ul>
<li>把大库存分成多个小份，用不同的key表示。在redis额外存储一份商品id和分桶key列表的映射关系<ul>
<li>这些Key的哈希值不同，大概率不在Redis的同一个槽位中，避免热点key带来的性能问题</li>
<li>每个redis分桶key可以并发做库存扣减操作，提高减库存的并发度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习线程池</title>
    <url>/2020/04/21/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池概述"><a href="#线程池概述" class="headerlink" title="线程池概述"></a>线程池概述</h1><blockquote>
<p>由来<br>为减少频繁创建和销毁线程的开销，引入<code>池</code>的概念：提前定制一定量的资源来进行资源复用</p>
</blockquote>
<blockquote>
<p>作用<br>1、控制线程数量。2、工作线程可被复用。3、线程池参数调优，高效利用资源。</p>
</blockquote>
<h1 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h1><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><blockquote>
<p>线程池上层接口</p>
</blockquote>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><blockquote>
<p>ExecutorService的默认实现，供Executors工厂类创建线程池的底层使用</p>
</blockquote>
<p>构造参数含义：</p>
<ul>
<li>corePoolSize：池中所保存的线程数，包括空闲线程。</li>
<li>maximumPoolSize：池中允许的最大线程数。</li>
<li>keepAliveTime：当线程数大于核心时，此为终止多余的空闲线程前允许其等待新任务的最长时间。</li>
<li>unit：keepAliveTime参数的时间单位。</li>
<li>blockingQueue：执行前用于保存任务的队列。此队列仅保持由execute方法提交的Runnable任务。</li>
<li>threadFactory：创建新线程时使用的工厂。</li>
<li>rejectedExecutionHandler：由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</li>
</ul>
<h3 id="blockingQueue"><a href="#blockingQueue" class="headerlink" title="blockingQueue"></a>blockingQueue</h3><blockquote>
<p>工作原理</p>
</blockquote>
<p>如果运行的线程少于corePoolSize，则Executor始终首选添加新的线程，而不进行排队。<br>如果运行的线程等于或多于corePoolSize，则Executor始终首选将请求加入队列，而不添加新的线程。<br>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</p>
<blockquote>
<p>任务的三种排队策略</p>
</blockquote>
<p>1、直接提交。<br>工作队列的默认选项是SynchronousQueue，在添加任务后必须等待其他线程取走后才能继续添加。如果不存在可用于立即运行任务的线程，且线程数小于池子最大数，会构造一个新的线程。这一点很重要，核心线程打满时，在同步队列里的任务会立即触发额外线程来处理任务，由此保证提交到线程池的任务立即顺序执行，避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界maximumPoolSizes以避免拒绝新提交的任务。</p>
<p>2、无界队列。<br>使用无界队列（例如，不具有预定义容量的LinkedBlockingQueue）将导致在所有corePoolSize线程都忙时新任务在队列中等待。这样，创建的线程就不会超过corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在Web服务器中。这种排队可用于处理瞬态突发请求。</p>
<p>3、有界队列。<br>当使用有限的maximumPoolSizes时，有界队列（如ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低CPU使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。  </p>
<p>4、延时队列。<br>定时线程池使用延时队列DelayedWorkQueue实现定时执行任务。延时队列基于最小堆构造，最近要执行的延时任务放在堆顶，内部有一个leader线程指向等待最近一个要执行任务的线程</p>
<p>offer方法提交延时任务：</p>
<ul>
<li>任务入最小堆，如果任务在堆顶，说明是最近一个要执行的任务，则唤醒一个等待在延时队列的线程，让它作为leader线程，再执行awaitNanos方法等待最近的延时任务</li>
</ul>
<p>take方法获取延时任务：</p>
<ul>
<li>堆顶无任务，则线程await，等待在延时队列</li>
<li>leader线程不为空说明有任务在等待最近一次延时任务，则线程await，等待在延时队列</li>
<li>否则，当前线程作为leader线程，等待堆顶的最近一次延时任务，即执行awaitNanos方法延时等待<ul>
<li>期间如果有更紧急的延时任务提交，则leader线程会置空，并唤醒一个等待在延时队列的线程，作为新的leader线程等待在最近的延时任务上</li>
</ul>
</li>
<li>获取到延时任务后，leader线程置空，并唤醒一个等待在延时队列的线程，作为leader线程继续等待下一个延时任务</li>
</ul>
<h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>jdk提供了四种任务拒绝策略RejectedExecutionHandler的实现</p>
<blockquote>
<p>CallerRunsPolicy</p>
</blockquote>
<p>线程池未关闭时，在线程池运行的主线程中执行被拒绝任务。<br>这种策略提供了一个简单的反馈控制机制，缺点就是可能会阻塞主线程</p>
<blockquote>
<p>AbortPolicy</p>
</blockquote>
<p>拒绝任务时会抛出运行时RejectedExecutionException到线程池运行的主线程中<br><code>它是线程池默认的拒绝策略</code></p>
<blockquote>
<p>DiscardPolicy</p>
</blockquote>
<p>直接丢弃任务，和AbortPolicy的唯一区别就是AbortPolicy抛出异常，DiscardPolicy不做任何处理</p>
<blockquote>
<p>DiscardOldestPolicy</p>
</blockquote>
<p>线程池未关闭时，丢弃阻塞队列中最老的（头部）任务，然后再将该任务提交到线程池中执行</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><blockquote>
<p>创建线程池的一个工厂类</p>
</blockquote>
<p>1.newSingleThreadExecutor<br>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<blockquote>
<p>core&#x3D;1,max&#x3D;1,keepAliveTime&#x3D;0,LinkedBlockingQueue</p>
</blockquote>
<p>2.newFixedThreadPool<br>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到达到线程池的最大线程数。一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<blockquote>
<p>core&#x3D;n,max&#x3D;n,keepAliveTime&#x3D;0,LinkedBlockingQueue</p>
</blockquote>
<p>3.newCachedThreadPool<br>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<blockquote>
<p>core&#x3D;0,max&#x3D;MAX_VALUE,keepAliveTime&#x3D;60s,SynchronousQueue</p>
</blockquote>
<p>4.newScheduledThreadPool<br>创建一个定时线程池。此线程池支持定时以及周期性执行任务的需求</p>
<blockquote>
<p>core&#x3D;n,max&#x3D;MAX_VALUE,keepAliveTime&#x3D;10ms,DelayedWorkQueue</p>
</blockquote>
<h1 id="线程池注意事项"><a href="#线程池注意事项" class="headerlink" title="线程池注意事项"></a>线程池注意事项</h1><p>1、并发可能产生的死锁问题<br>2、线程泄漏：使用局部线程池造成线程泄漏</p>
<ul>
<li>简单理解，线程池里的线程执行完任务后并不会stop，而是在while循环里不断轮询阻塞队列（请求队列）拿任务</li>
<li>ThreadPoolExecutor -&gt; Worker -&gt; Thread，由于存在这样的引用关系，并且Thread作为GC Root，所以无法被回收</li>
</ul>
<h1 id="线程池工作模型"><a href="#线程池工作模型" class="headerlink" title="线程池工作模型"></a>线程池工作模型</h1><p>1、线程池管理器</p>
<ul>
<li>核心是管理工作线程<ul>
<li>构造线程池时，初始化一些工作线程，添加到工作线程队列并启动</li>
<li>接收外部任务，提交到请求队列。请求队列拒绝时，比较工作线程队列的线程数和核心线程数、最大线程数的关系，决定是创建新的工作线程还是拒绝任务</li>
<li>关闭线程池时，停止所有工作线程</li>
</ul>
</li>
</ul>
<p>2、请求队列</p>
<ul>
<li>核心是服务于工作线程取任务<ul>
<li>提交到线程池的任务，同步添加到请求队列<ul>
<li>添加后notify所有等待在请求队列的工作线程取任务</li>
</ul>
</li>
<li>提供接口给工作线程，同步从请求队列取任务<ul>
<li>请求队列为空时，wait在请求队列</li>
</ul>
</li>
<li>请求队列满时，调用拒绝策略</li>
</ul>
</li>
</ul>
<p>3、工作线程</p>
<ul>
<li>核心是从请求队列里取任务执行<ul>
<li>轮询请求队列，获取并执行任务</li>
</ul>
</li>
</ul>
<p>4、工作线程队列</p>
<ul>
<li>核心是维护创建的工作线程<ul>
<li>负责工作线程的入队和出队</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>系统学习设计模式</title>
    <url>/2017/03/14/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式包含三大类：创建模式、行为模型、结构模式</p>
<p>创建模式</p>
<ul>
<li>专注于类的实例化，简化新实体的创建过程，例如简单工厂、单例（Singleton）和抽象工厂（Abstract Factory）</li>
</ul>
<p>行为模型</p>
<ul>
<li>将组件之间的通用行为抽象为一个单独的实体，进而与你的创建模式结合起来。常见的行为模式包括命令（Command）、策略（Strategy）、观察者（Observer）模式</li>
</ul>
<p>结构模式</p>
<ul>
<li>负责处理不同组件（或类）之间的关系，并形成新结构以提供新功能。常用的结构模式有组合（Composite）、适配器（Adapter）和装饰器（Decorator）</li>
</ul>
<h1 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>遵循工厂模式的概念，在实际应用中衍生出了几种设计模式，分别是简单工厂、工厂包、抽象工厂</p>
</blockquote>
<p>简单工厂</p>
<ul>
<li>由工厂类负责按需创建同一类产品（实现了相同接口的对象实例）</li>
<li>缺点：增加新类型的产品时，需要修改工厂类的工厂方法</li>
<li>解决办法：抽象”工厂方法”得到抽象工厂，每个类型的产品都有自己独立的工厂实例，负责创建产品实例</li>
</ul>
<p>抽象工厂</p>
<ul>
<li>将创建产品实例的工厂方法抽象为接口，得到抽象工厂，由抽象工厂的实现类负责创建产品实例，每个类型的产品都有自己的抽象工厂实例</li>
<li>由工厂制造器负责按需创建特定的工厂实例</li>
</ul>
<p>抽象工厂的应用场景：</p>
<ul>
<li>工厂无法预期它必须创建的产品实例类型</li>
<li>希望由不同的工厂分别创建自己领域下的产品实例</li>
</ul>
<p>工厂包</p>
<ul>
<li>使用 Builder 构建（不可更改的）产品实例的方式定义工厂</li>
<li>Builder 与工厂是分离的，由业务方使用 Builder 构建工厂的产品实例</li>
<li>实现方案使用 JAVA8 的函数式接口：Consumer、Supplier<ul>
<li>Consumer 是消费者，专注于处理 Consumer 的泛型入参</li>
<li>使用 Builder 接口作为 Consumer 的泛型入参，业务方实现 Consumer，调用 Builder 的 add 方法向工厂添加产品实例</li>
<li>工厂提供 Builder 的实现类，获取业务方提供的产品实例并添加到工厂，简单的实现方式就是一个 Map</li>
<li>Supplier 是提供者，专注于提供产品</li>
<li>Builder 的接口方法参数使用 Supplier，业务方在调用 Builder 的 add 方法时，实现 Supplier，自定义产品实例的创建逻辑</li>
</ul>
</li>
</ul>
<p>工厂包的应用场景：</p>
<ul>
<li>工厂无法预期它必须创建的产品实例类型</li>
<li>业务方自定义 Builder 来灵活构建自适应工厂，而非依赖全局工厂</li>
<li>明确知道工厂需要产出的产品实例类型</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>单例模式保证了类在每个类加载器实例中只会有一个类实例对象，并提供了全局方法来访问这个单例对象</p>
</blockquote>
<p>单例模式的几种实现：</p>
<ul>
<li>饿汉式<ul>
<li>单例实例作为类属，在类加载时被实例化</li>
</ul>
</li>
<li>简单懒汉式<ul>
<li>单例实例作为类属，在第一次被访问时加锁实例化</li>
</ul>
</li>
<li>DCL 懒汉式<ul>
<li>单例实例作为类属并用 volatile 修饰，在第一次被访问时先利用可见性判断是否已实例化，如果没有才加锁，加锁后再二次判断是否已实例化，没有再实例化。适合高并发场景 - 加 volatile 关键字保证可见性，防止指令重排序在并发时出现问题，导致没有初始化的单例对象被业务线程拿到</li>
</ul>
</li>
<li>静态内部类的懒汉式<ul>
<li>单例实例作为静态内部类的类属，在第一次被访问时通过加载静态内部类完成实例化，而静态内部类只有在被访问时加载，所以也是 lazy 方式，且是线程安全的</li>
</ul>
</li>
</ul>
<h2 id="builder-模式"><a href="#builder-模式" class="headerlink" title="builder 模式"></a>builder 模式</h2><blockquote>
<p>建造者模式提供一套复杂对象的通用构造流程，优雅地创建同一类对象的不同呈现</p>
</blockquote>
<p>builder 模式的实现：</p>
<ul>
<li>target 类里创建一个静态类 Builder，属性是需要通过 build 模式构建的属性</li>
<li>builder 提供方法为 builder 实例填充属性</li>
<li>builder 提供 build 方法，内部调用 target 的构造器创建 target 实例，传入 builder 实例完成属性传递</li>
</ul>
<h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="command-模式"><a href="#command-模式" class="headerlink" title="command 模式"></a>command 模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/command%E6%A8%A1%E5%BC%8F.png"></p>
<p>命令模式将面向对象里执行命令的函数对象化为执行者 Command，Command 只负责执行命令逻辑，不关心目标对象 Target 是谁，而 Target 也不知道被什么 Command 执行命令。业务方 Client 使用 Invoker 来发号施令，提供给 Invoker 实际的执行者和目标，Invoker 发号施令的同时还提供命令的撤回和重做能力</p>
<p>命令模式：</p>
<ul>
<li>命令模式包含四类元素：Command、Target、Invoker、Client</li>
<li>执行者 Command 专注于执行对目标 Target 的命令，而不关心 Target 具体是谁</li>
<li>Invoker 负责发号施令，不关心实际的执行者 Command 和目标 Target 是谁<ul>
<li>Invoker 内部通过维护执行者 Command 的 undo 和 redo 队列，回调 command 的 undo&#x2F;redo 方法实现命令的撤销和重做</li>
</ul>
</li>
<li>Client 操作 Invoker 来发号施令，指定实际的执行者 Command 和目标 Target</li>
</ul>
<p>Command 模式的应用场景</p>
<ul>
<li>回调函数建模<ul>
<li>回调函数对象化为命令 Command</li>
</ul>
</li>
<li>多级回退 Undo 操作</li>
<li>事务建模<ul>
<li>事务建模为 Command，当事务失败时，回退到事务前的状态</li>
<li>Command 具有公共接口，可让您以相同的方式调用所有事务</li>
</ul>
</li>
</ul>
<h2 id="observer-模式"><a href="#observer-模式" class="headerlink" title="observer 模式"></a>observer 模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/observer%E6%A8%A1%E5%BC%8F.png"></p>
<blockquote>
<p>定义被依赖方和依赖方之间一对多的关联关系，当被依赖方的状态改变时，可以通知多个依赖方自动更新状态</p>
</blockquote>
<p>观察者模式</p>
<ul>
<li>三个核心元素：观察者 Observer、被观察者 Observable、回调上下文 Argument</li>
<li>被观察者 Observable 维护一组观察者 Observer，提供基本的添加和删除观察者能力，以及 notify 能力，通知它的所有观察者，回调观察者的 update 接口消费事件</li>
<li>Argument 是被观察者 Observable 在执行事件后用于回调所有观察者的上下文参数</li>
<li>Observable 是观察者模式的顶级抽象类，Observer 是顶级接口。它们都适合使用泛型，由业务方继承时指定实际的 Observable、Observer、Argument</li>
</ul>
<p>使用场景</p>
<ul>
<li>当一个对象改变需要通知其他对象，且你无法确定其他对象的个数时</li>
<li>当你需要将依赖方和被依赖方解耦，被依赖方不需要感知有哪些依赖方<ul>
<li>目的是依赖方和被依赖方作为独立模块能分别复用和修改</li>
</ul>
</li>
</ul>
<h2 id="strategy-模式"><a href="#strategy-模式" class="headerlink" title="strategy 模式"></a>strategy 模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/strategy%E6%A8%A1%E5%BC%8F.png"></p>
<blockquote>
<p>策略模式提供一组策略，帮助业务在运行时动态选择和执行决策，使得业务行为具备动态性</p>
</blockquote>
<p>策略模式的实现：</p>
<ul>
<li>定义顶层 Strategy 策略接口，并提供一组策略的实现类</li>
<li>提供策略上下文类，实现方式可以是简单工厂，或者是枚举，帮助业务在运行时动态选择策略<ul>
<li>枚举方式代码可读性更好，更符合开闭原则</li>
</ul>
</li>
<li>业务类依赖策略接口，运行时动态注入策略实例，执行不同的策略有不同的行为表现</li>
</ul>
<p>使用场景：</p>
<ul>
<li>许多相似的类仅仅在行为上有不同的表现，可以使用策略模式统一这些相似的类</li>
<li>类的行为包含很多 if-else 条件，可以将类的行为抽象为策略，相关的条件分支移到策略类里实现</li>
</ul>
<h1 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h1><h2 id="Composite-模式"><a href="#Composite-模式" class="headerlink" title="Composite 模式"></a>Composite 模式</h2><blockquote>
<p>组合模式将不同组件按树状结构组合在一起，表示部分和整体的层级结构。作用是使得业务方只需统一处理父级组件，就能达到处理整个层级结构的效果</p>
</blockquote>
<p>组件间需要满足：</p>
<ul>
<li>组件的类型相同，即组件需要有共同行为，实现同一接口</li>
<li>组件间的结构关系是树形结构</li>
</ul>
<p>举例：</p>
<ul>
<li>一句话、一个词、一个字都是相同类型的组件，因为这些组件都有相同的打印行为，且这些组件间满足树形结构，一句话包含多个词，一个词包含多个字。所以在打印这些组件时，可以使用组合模式</li>
<li>商品、购物车也是相同类型的组件，都具备计算价格的行为，且 Box 是父节点，Product 是叶子节点。所以在计算这类组件的价格时，可以使用组合模式</li>
</ul>
<p>应用场景：</p>
<ul>
<li>你想要构建”部分-整体”的对象间层级结构</li>
<li>你想要业务方无需关心父级对象和它内部的组成结构，只需要统一处理父级对象</li>
</ul>
<h2 id="decorator-模式"><a href="#decorator-模式" class="headerlink" title="decorator 模式"></a>decorator 模式</h2><blockquote>
<p>装饰者模式能实现动态地将额外功能附加到对象，不需要通过子类来实现，灵活性更强</p>
</blockquote>
<p>装饰者模式包含的元素有装饰者 decorator 和被装饰者 decorated</p>
<p>装饰者 decorator 需要满足：</p>
<ul>
<li>与被装饰者 decorated 实现同一接口，否则不能装饰<ul>
<li>这里装饰就像是被代理</li>
</ul>
</li>
<li>聚合被装饰者 decorated 的实例</li>
</ul>
<p>应用场景：</p>
<ul>
<li>动态透明地为对象附加功能<ul>
<li>动态体现在：<ul>
<li>运行时额外增加功能而非通过定义子类在类加载时就已经扩展功能</li>
<li>如果不装饰就能做到撤销功能</li>
<li>装饰者也可以作为被装饰者来二次装饰，功能扩展更为灵活</li>
</ul>
</li>
<li>透明体现在不影响对象，既不改变对象内部代码也不用扩展对象类型的子类</li>
</ul>
</li>
<li>当使用子类扩展功能不可行时<ul>
<li>对象不支持扩展子类</li>
<li>避免扩展太多作用不大的子类</li>
</ul>
</li>
</ul>
<h2 id="adapter-模式"><a href="#adapter-模式" class="headerlink" title="adapter 模式"></a>adapter 模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter%E6%A8%A1%E5%BC%8F.png"></p>
<blockquote>
<p>适配器模式的作用是适配业务方期望的接口类型，实现在接口不兼容时也能协同工作</p>
</blockquote>
<p>Adapter 模式包含两个元素：Adapter 和 Adaptee</p>
<ul>
<li>Adapter 是适配器，Adaptee 是被适配者</li>
<li>Adapter 通过注入 Adaptee 来复用 Adaptee 的能力</li>
<li>Adapter 实现业务方期望的接口来达到适配的效果</li>
</ul>
<p>使用场景：</p>
<ul>
<li>您要使用现有的类，并且其接口与您需要的接口不匹配</li>
<li>使用第三方类库时，使用适配器作为中间层使应用程序与三方类库分离</li>
</ul>
<h2 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bridge%E6%A8%A1%E5%BC%8F.png"></p>
<blockquote>
<p>桥接模式可以认为是<code>两层抽象</code>，业务方可以使用桥接模式将两种类型的实现类自由结合起来实现功能，而不是创建深层次的等级体系</p>
</blockquote>
<p>桥接模式通过定义两个顶级接口，并将其中一个接口注入另一个中，使得在接口级别抽象为上下游两层，上层接口依赖下层接口实现功能（桥接的含义）。业务方可以自由组合这两种类型的实现类，灵活替换接口实现类满足功能需求变更</p>
<p>使用场景：</p>
<ul>
<li>运行时动态选择和切换实现类</li>
</ul>
]]></content>
      <categories>
        <category>系统学习系列</category>
      </categories>
  </entry>
  <entry>
    <title>A+B问题</title>
    <url>/2017/02/28/blog_article/%E7%AE%97%E6%B3%95/A-B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二进制的数字用0、1表示，两数相加即对应位0、1相加，其结果无非还是0、1<br>存在两种情况：进位、不进位<br><code>不进位</code>：考虑用异或。异或运算又叫：不进位相加<br><code>进位</code>：进位的bit位，即两数与的结果为1的位。进位需要将两数与的结果左移一位。<br>所以两数求和，演变成异或的结果和与运算移位后的结果<code>继续求和，考虑递归</code>。<br><code>递归终止条件自然是与的结果为0</code>，那么最终结果就是异或的值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int aplusb(int a, int b) &#123;</span><br><span class="line">        // write your code here, try to do it without arithmetic operators.</span><br><span class="line">        if(b == 0) &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return repeat(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int repeat(int a, int b) &#123;</span><br><span class="line">        int _a = a ^ b;</span><br><span class="line">        int _b = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">        if(b != 0) &#123;</span><br><span class="line">           return repeat(_a, _b);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return _a;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>递归（递归的思想：参数不同，套路相同，终止条件，逐层返回）</li>
<li>位运算（两数异或：加法不进位）</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>丑数II</title>
    <url>/2017/02/28/blog_article/%E7%AE%97%E6%B3%95/%E4%B8%91%E6%95%B0II/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个算法，找出只含素因子2，3，5 的第 n 大的数。1也是一个丑数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>方法一<br>每个丑数都是2*..<em>3</em>..<em>5</em>..的结果<br>创建保存丑数的数组a，设a[0]&#x3D;1<br>用index2，index3，index5表示丑数分解包含了2、3、5的个数，初始化为0<br>每次求min(a[indexk]*k)，得到当前最小的丑数，写入数组，并将indexk++<br>这样做即可保证a数组中能保存所有的按序排列的丑数，输出第a[n-1]个元素即可。</p>
</li>
<li><p>方法二<br>将1加入保存丑数的数组a，将2,3,5加入优先队列pq<br>每次从pq取min，如果min与a[tmp]不等，数组保存min，并将min*2,3,5的值加入优先队列。如果相等，跳过。<br>这样做，最终可以得到a[n-1]个元素即为结果</p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int nthUglyNumber(int n) &#123;</span><br><span class="line">       // Write your code here</span><br><span class="line">       int index2 = 0;</span><br><span class="line">       int index3 = 0;</span><br><span class="line">       int index5 = 0;</span><br><span class="line">       int[] res = new int[n];</span><br><span class="line">       res[0] = 1;</span><br><span class="line">       int count = 1;</span><br><span class="line">       while(count &lt; n)&#123;</span><br><span class="line">           res[count] = min(res[index2]*2, res[index3]*3, res[index5]*5);</span><br><span class="line">           if(res[count] == res[index2]*2) index2++;</span><br><span class="line">           if(res[count] == res[index3]*3) index3++;</span><br><span class="line">           if(res[count] == res[index5]*5) index5++;</span><br><span class="line">           count++;</span><br><span class="line">       &#125;</span><br><span class="line">       return res[--count];</span><br><span class="line">   &#125;</span><br><span class="line">   private int min(int a1, int a2, int a3)&#123;</span><br><span class="line">       if(a1 &lt; a2)&#123;</span><br><span class="line">           if(a1 &lt; a3)</span><br><span class="line">               return a1;</span><br><span class="line">           else</span><br><span class="line">               return a3;</span><br><span class="line">       &#125;else if(a2 &lt; a3)&#123;</span><br><span class="line">           return a2;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           return a3;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>优先队列</li>
<li>数组下标的灵活运用</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>两个排序数组的中位数</title>
    <url>/2017/03/08/blog_article/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>我的笨办法<br>因为两数组已经排序了，所以先求两数组合并后的中位数下标i，然后从头开始比较比较两个数组，直到找到下标为i的中位数为止。<br>注意，需要分合并后的数组元素个数为奇数还是偶数，因为偶数返回的中位数是中间两个数的平均值。</p>
</li>
<li><p>别人的高端分治法<br>回想归并排序，本质上是先排序好子数组，再将子数组合并排序<br><br>所以，可以这样：</p>
</li>
<li><p>先求A和B数组的中位数，再比较中位数：</p>
</li>
<li><p>中位数相等，直接输出</p>
</li>
<li><p>A的中位数更大，则取A的左半部分和B的右半部分</p>
</li>
<li><p>B的中位数更大，则取A的右半部分和B的左半部分</p>
</li>
<li><p>再来一遍…</p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int midIndex; </span><br><span class="line">    public double findMedianSortedArrays(int[] A, int[] B) &#123;</span><br><span class="line">        int length = A.length + B.length;</span><br><span class="line">		if(length % 2 == 0) &#123;</span><br><span class="line">			midIndex = (length / 2);</span><br><span class="line">			return getMid(false, A, B);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			midIndex = ((length+1) / 2);</span><br><span class="line">			return getMid(true, A, B);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	private double getMid(boolean isSingle, int[] A, int[] B) &#123;</span><br><span class="line">		if(A.length == 0) &#123;</span><br><span class="line">			if(isSingle) &#123;</span><br><span class="line">				return B[midIndex-1];</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				return (double)(B[midIndex]+B[midIndex-1]) / 2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if (B.length == 0) &#123;</span><br><span class="line">			if(isSingle) &#123;</span><br><span class="line">				return A[midIndex-1];</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				return (double)(A[midIndex]+A[midIndex-1]) / 2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			int tmp = 0;</span><br><span class="line">			int tmpCount = 1;</span><br><span class="line">			int left = 0;</span><br><span class="line">			int i = 0;</span><br><span class="line">			int j = 0;</span><br><span class="line">			if(isSingle) &#123;</span><br><span class="line">				while(tmpCount &lt;= midIndex) &#123;</span><br><span class="line">					if(A[i] &gt;= B[j]) &#123;</span><br><span class="line">						tmp = B[j];</span><br><span class="line">						if(j &lt; B.length-1) &#123;</span><br><span class="line">						    j++;</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">						    B[j] = Integer.MAX_VALUE;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						tmp = A[i];</span><br><span class="line">						if(i &lt; A.length-1) &#123;</span><br><span class="line">						    i++;</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">						    A[i] = Integer.MAX_VALUE;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					tmpCount++;</span><br><span class="line">				&#125;</span><br><span class="line">				return tmp;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				while(tmpCount &lt;= midIndex+1) &#123;</span><br><span class="line">					if(A[i] &gt;= B[j]) &#123;</span><br><span class="line">						tmp = B[j];</span><br><span class="line">						if(j &lt; B.length-1) &#123;</span><br><span class="line">						    j++;</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">						    B[j] = Integer.MAX_VALUE;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						tmp = A[i];</span><br><span class="line">						if(i &lt; A.length-1) &#123;</span><br><span class="line">						    i++;</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">						    A[i] = Integer.MAX_VALUE;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">                    if(tmpCount == midIndex) &#123;</span><br><span class="line">						left = tmp;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					tmpCount++;</span><br><span class="line">				&#125;</span><br><span class="line">				return (double)(left+tmp)/2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>分治法</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2017/03/06/blog_article/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。<br>你需要实现的函数twoSum需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 1 到 n，不是以 0 开头。<br>你可以假设只有一组答案。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为要找两数之和等于target，但数组未排序，显然如果暴力查找时间复杂度太大<br>给数组排序后可以很容易找到两数之和等于target，但新问题是：排序会打乱原来元素的顺序，就无法得到这两个数在原数组准确的下标了。<br>综上，可以这么处理：</p>
<ul>
<li>用一个hashmap保存该数组，key为下标+1，value就是数组的值</li>
<li>数组排序</li>
<li>找到这两个数</li>
<li>自己写一个通过value找到key的函数，输出下标<br>通过value找key也很容易，通过keyset集可以轻松遍历map里的value，比较相等后将key添加到int[]数组即可。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">		int tmpIndex = 1;</span><br><span class="line">		for(int num : numbers) &#123;</span><br><span class="line">			hashMap.put(tmpIndex++, num);</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(numbers);</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = numbers.length-1;</span><br><span class="line">        while(i &lt; j) &#123;</span><br><span class="line">        	if(target &lt; numbers[i]+numbers[j]) &#123;</span><br><span class="line">        		j--;</span><br><span class="line">        	&#125;else if (target &gt; numbers[i]+numbers[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				return getKey(hashMap, numbers[i], numbers[j]);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	private int[] getKey(HashMap&lt;Integer, Integer&gt; hashMap, int value1, int value2) &#123;</span><br><span class="line">		int[] res = new int[2];</span><br><span class="line">		int i = 0;</span><br><span class="line">		Set&lt;Integer&gt; keySet = hashMap.keySet();</span><br><span class="line">		for(int key : keySet) &#123;</span><br><span class="line">			if(hashMap.get(key) == value1 || hashMap.get(key) == value2) &#123;</span><br><span class="line">				res[i++] = key;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>hashmap的应用</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>主元素</title>
    <url>/2017/03/11/blog_article/%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用贪心。贪心不是一种算法，是一种思想，这种思想告诉我们：</p>
<blockquote>
<p>每一步都做出当前最正确的选择以得到最后的结果</p>
</blockquote>
<p>遍历数组，用res表示”当前认为”的主元素，用count表示抵消掉竞争对手后，主元素当前剩余的个数<br>每访问一个元素</p>
<ul>
<li>如果其和主元素相当，count++</li>
<li>如果不相等，count–，如果count&#x3D;&#x3D;0，认为当前访问的元素为新的主元素</li>
</ul>
<p>遍历的过程中，当出现count&#x3D;0时，也不能保证新的主元素就是真正的主元素。但是，因为主元素严格超过一半，所以遍历完后，res保存的一定是主元素。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int majorityNumber(ArrayList&lt;Integer&gt; nums) &#123;</span><br><span class="line">        int count = 1;	// 抵消掉竞争对手后剩余的个数</span><br><span class="line">        int res = nums.get(0);	// 始终保存当前出现次数最多的那个元素</span><br><span class="line">        for(int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        	if(res == nums.get(i)) &#123;</span><br><span class="line">        		count++;</span><br><span class="line">        	&#125;else &#123;</span><br><span class="line">        		if(count == 0) &#123;</span><br><span class="line">					res = nums.get(i);</span><br><span class="line">					count = 1;</span><br><span class="line">				&#125;</span><br><span class="line">				count--;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>贪心</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2017/03/11/blog_article/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交易(例如,一次买卖股票),设计一个算法来找出最大利润。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>贪心。每访问一个数组的元素，都判断其是否为卖点，如果不是，判断其是否为买点，都不是，继续向后访问。</p>
<ul>
<li>用buy和sell表示买卖点下标，res表示利润，初始都为0</li>
<li>从num[1]开始遍历数组元素<ul>
<li>如果出现卖点（当前值-买点值 大于 res），更新res，更新sell</li>
<li>如果出现买点（当前值 &lt; 买点），更新buy</li>
</ul>
</li>
<li>遍历完数组，res即为最大利润<br>这样做，利用贪心的思想，buy始终是当前最好的买点下标，sell始终是当前最好的卖点下标，res始终是当前最大的利润</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int buy = 0;</span><br><span class="line">        int sell = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            // 能卖吗</span><br><span class="line">            if((prices[i] - prices[buy]) &gt; res) &#123;</span><br><span class="line">                sell = i;</span><br><span class="line">                res = prices[i] - prices[buy];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 能买吗</span><br><span class="line">            if(prices[i] &lt; prices[buy]) &#123;</span><br><span class="line">                buy = i;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>贪心</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票的最佳时机II</title>
    <url>/2017/03/13/blog_article/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>贪心。<br>一开始认为买卖点都在头部，向后遍历</p>
<ul>
<li>当出现卖点时，更新卖点和当前利润</li>
<li>未出现卖点，将当前利润累加到总利润中，并将买点指向当前点（完成了一次交易，为下次交易做准备）<br>即，只要发生利润A &gt; 利润B，就卖掉利润A，开始下一次交易，这样每次操作都保证了利润的最大化，同时还为下一次交易做了准备</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int sell = 0;</span><br><span class="line">        int buy = 0;</span><br><span class="line">        int tmpMax = 0; // 当前这笔交易的最大利润</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            if((prices[i] - prices[buy] &gt;= tmpMax)) &#123;    // 当前交易出现更好的卖点，更新</span><br><span class="line">                tmpMax = prices[i] - prices[buy];</span><br><span class="line">                sell = i;</span><br><span class="line">                if(i == prices.length-1) &#123;      // 如果是最后一个交易日，卖出股票</span><br><span class="line">                    res += tmpMax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;     // 当前交易完成，为下一次交易做准备</span><br><span class="line">                res += tmpMax;</span><br><span class="line">                buy = i;</span><br><span class="line">                tmpMax = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>贪心</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2017/03/03/blog_article/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序的整数数组（升序）和一个要查找的整数target，用O(logn)的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回-1</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二分查找，用递归可以很容易实现。<br>用target和当前数组的中间元素比较，根据比较的结果向后递归即可。<br>需要注意两点：</p>
<ul>
<li>递归终止条件：子数组只包含一个元素，则不需要继续向后递归</li>
<li>防止数组下标越界：<ul>
<li>如果递归左子数组，且mid为0时，不能继续递归，不然会越界</li>
<li>因为数组可能包含重复元素，所以匹配到target后，还需要去求该元素第一次出现的下标。同样小心下标不要越界</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">        return myBinarySearch(nums, target, 0, nums.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">	 * @intention:二分查找也是递归的做法</span><br><span class="line">	 */</span><br><span class="line">	private int myBinarySearch(int[] nums, int target, int start, int end) &#123;</span><br><span class="line">		if(start == end &amp;&amp; target != nums[start]) &#123;</span><br><span class="line">			return -1;		//找不到</span><br><span class="line">		&#125;</span><br><span class="line">		int mid = start + (end-start)/2;	//mid偏左</span><br><span class="line">		if(target &lt; nums[mid]) &#123;</span><br><span class="line">			if(mid != 0) &#123;</span><br><span class="line">				return myBinarySearch(nums, target, start, mid-1);		//防止下标越界</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				return -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if (target &gt; nums[mid]) &#123;</span><br><span class="line">			return myBinarySearch(nums, target, mid+1, end);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			return findIndex(nums, target, mid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private int findIndex(int[] nums, int target, int tmpIndex) &#123;</span><br><span class="line">		while(target == nums[tmpIndex]) &#123;</span><br><span class="line">			if(tmpIndex == 0) &#123;     //防止下标越界</span><br><span class="line">				return tmpIndex;</span><br><span class="line">			&#125;</span><br><span class="line">			tmpIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		return tmpIndex+1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二分法</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>二叉查找树中搜索区间</title>
    <url>/2017/03/02/blog_article/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;&#x3D; x &lt;&#x3D; k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。<br>例子：如果有 k1 &#x3D; 10 和 k2 &#x3D; 22, 你的程序应该返回 [12, 20, 22]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    20</span><br><span class="line">   /  \</span><br><span class="line">  8   22</span><br><span class="line"> / \</span><br><span class="line">4   12</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为是二叉查找树，最直接的方式就是左中右遍历二叉树<br>对每一个节点，如果其val符合条件，则添加到list<br><code>改进算法</code></p>
<blockquote>
<p>针对遍历过程中的每一个root节点，如果其val在查找范围之外，则只选择其一个分支进行递归，直到root的val落在查找范围内，再用基本的二叉查找树遍历算法</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>基本算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">	        searchBinaryTree(aList, root, k1, k2);</span><br><span class="line">	        return aList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void searchBinaryTree(ArrayList&lt;Integer&gt; alist,TreeNode root, int k1, int k2) &#123;</span><br><span class="line">		 if(root == null) return;</span><br><span class="line">		 </span><br><span class="line">		 searchBinaryTree(alist, root.left, k1, k2);</span><br><span class="line">		 </span><br><span class="line">		 int val = root.val;</span><br><span class="line">		 if(val &gt;= k1 &amp;&amp; val &lt;= k2) &#123;</span><br><span class="line">			 alist.add(val);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 searchBinaryTree(alist, root.right, k1, k2);</span><br><span class="line">			</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<p>改进算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) &#123;</span><br><span class="line">	        ArrayList&lt;Integer&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">	        mySearch(aList, root, k1, k2);</span><br><span class="line">	        return aList;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	 private void mySearch(ArrayList&lt;Integer&gt; alist,TreeNode root, int k1, int k2) &#123;</span><br><span class="line">		 if(root == null) return;</span><br><span class="line">		 </span><br><span class="line">		 int val = root.val;</span><br><span class="line">		 if(val &lt; k1) &#123;</span><br><span class="line">			 mySearch(alist, root.right, k1, k2); </span><br><span class="line">		 &#125; else if(val &gt; k2) &#123;</span><br><span class="line">			 mySearch(alist, root.left, k1, k2); </span><br><span class="line">		 &#125;	else &#123;</span><br><span class="line">			 searchBinaryTree(alist, root, k1, k2);</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 private void searchBinaryTree(ArrayList&lt;Integer&gt; alist,TreeNode root, int k1, int k2) &#123;</span><br><span class="line">         if(root == null) return;</span><br><span class="line"></span><br><span class="line">         searchBinaryTree(alist, root.left, k1, k2);</span><br><span class="line"></span><br><span class="line">         int val = root.val;</span><br><span class="line">         if(val &gt;= k1 &amp;&amp; val &lt;= k2) &#123;</span><br><span class="line">             alist.add(val);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         searchBinaryTree(alist, root.right, k1, k2);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二叉查找树的遍历</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>二叉查找树迭代器</title>
    <url>/2017/03/19/blog_article/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计实现一个带有下列属性的二叉查找树的迭代器：<br>元素按照递增的顺序被访问（比如中序遍历）<br>next()和hasNext()的询问操作要求均摊时间复杂度是O(1)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><code>递归遍历二叉树</code><br>1、new迭代器时遍历二叉查找树，遍历的顺序采取右序遍历。遍历的元素保存到Stack里<br>2、hasNext方法判断stack是否为空<br>3、next方法从stack里pop</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BSTIterator &#123;</span><br><span class="line">    //@param root: The root of binary tree.</span><br><span class="line">    private Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    public BSTIterator(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        stack = new Stack&lt;&gt;();</span><br><span class="line">        addNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //@return: True if there has next node, or false</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        return !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addNode(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(root.right);</span><br><span class="line">        stack.push(root);</span><br><span class="line">        addNode(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //@return: return next node</span><br><span class="line">    public TreeNode next() &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>二叉查找树</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的序列化和反序列化</title>
    <url>/2017/03/01/blog_article/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个算法，并编写代码来序列化和反序列化二叉树。将树写入一个文件被称为“序列化”，读取文件后重建同样的二叉树被称为“反序列化”。<br>如何反序列化或序列化二叉树是没有限制的，你只需要确保可以将二叉树序列化为一个字符串，并且可以将字符串反序列化为原来的树结构。<br>样例：二叉树{3,9,20,#,#,15,7}<br>数结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>序列化：其实就是如何遍历二叉树。<br>因为不知道二叉树有多少个节点，所以考虑ArrayList。<br>因为考虑到要反序列化，所以对空的子节点，其val用“#”标识。<br>因为是动态的添加字符到字符串，考虑StringBuilder。</p>
<ul>
<li>初始化List和StringBuilder<br>先取root的val，append到StringBuilder。然后把root add到List。</li>
<li>遍历list，将当前节点的左右子节点add到List，将子节点的val append到StringBuilder<ul>
<li>如果子节点为null，将”#”append到StringBuilder</li>
</ul>
</li>
</ul>
<p>反序列化：其实就是根据字符串恢复二叉树。<br>首先将字符串处理成String[]{val1,val2,val3 …}的形式<br>用val1创建root<br>因为String[]保存的是完全二叉树的val（空节点为”#”），考虑遍历String[]恢复二叉树<br>因为不知道二叉树包含多少个节点，考虑用ArrayList保存节点<br>用Index指向当前恢复的节点在List中的下标</p>
<ul>
<li>遍历String[]<ul>
<li>读完一组val，创建左右子节点并加入List，当前节点的left、right指向子节点，index++</li>
<li>如果读到“#”，不创建子节点，但读完一组后，index++（因为要准确恢复二叉树）</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String serialize(TreeNode root) &#123;</span><br><span class="line">		 if(root == null) return null;</span><br><span class="line">	        StringBuilder sBuilder = new StringBuilder(&quot;&#123;&quot;);</span><br><span class="line">	        sBuilder.append(root.val);</span><br><span class="line">	        ArrayList&lt;TreeNode&gt; aList = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">	        aList.add(root);</span><br><span class="line">	        for(int i = 0; i &lt; aList.size(); i++) &#123;</span><br><span class="line">	        	if(aList.get(i) == null) continue;</span><br><span class="line">	        	aList.add(aList.get(i).left);</span><br><span class="line">	        	aList.add(aList.get(i).right);</span><br><span class="line">	        	if(aList.get(i).left != null) &#123;</span><br><span class="line">	        		sBuilder.append(&quot;,&quot; + aList.get(i).left.val);</span><br><span class="line">	        	&#125;else &#123;</span><br><span class="line">					sBuilder.append(&quot;,#&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">	        	</span><br><span class="line">	        	if(aList.get(i).right != null) &#123;</span><br><span class="line">	        		sBuilder.append(&quot;,&quot; + aList.get(i).right.val);</span><br><span class="line">	        	&#125;else &#123;</span><br><span class="line">	        		sBuilder.append(&quot;,#&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        sBuilder.append(&quot;&#125;&quot;);</span><br><span class="line">	        return sBuilder.toString();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public TreeNode deserialize(String data) &#123;</span><br><span class="line">		 	if(data == null)	return null;</span><br><span class="line">	        String[] strings = data.substring(1, data.length()-1).split(&quot;,&quot;);</span><br><span class="line">	        TreeNode root = new TreeNode(Integer.parseInt(strings[0]));</span><br><span class="line">	        ArrayList&lt;TreeNode&gt; aList = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">	        aList.add(root);</span><br><span class="line">	        int index = 0;</span><br><span class="line">	        boolean isLeft = true;</span><br><span class="line">	        for(int i = 1; i &lt; strings.length; i++) &#123;</span><br><span class="line">	        	if(!strings[i].equals(&quot;#&quot;)) &#123;</span><br><span class="line">	        		TreeNode node = new TreeNode(Integer.parseInt(strings[i]));</span><br><span class="line">	        		if(isLeft) &#123;</span><br><span class="line">	        			aList.get(index).left = node;</span><br><span class="line">	        			aList.add(node);</span><br><span class="line">	        		&#125;else &#123;</span><br><span class="line">						aList.get(index).right = node;</span><br><span class="line">						aList.add(node);</span><br><span class="line">					&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	isLeft = !isLeft;</span><br><span class="line">	        	if(isLeft)	index++;</span><br><span class="line">	        &#125;</span><br><span class="line">	        return root;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>二叉树的遍历（用ArrayList保存当前读取的节点和子节点<code>将要读取的节点</code>）</li>
<li>二叉树的还原（用ArrayList保存当前恢复的节点和其指向的子节点<code>将要恢复的节点</code>）</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的所有路径</title>
    <url>/2017/03/26/blog_article/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给一棵二叉树，找出从根节点到叶子节点的所有路径。<br>例子：给出下面这棵二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure>
<p>所有根到叶子的路径为：<br>[<br>  “1-&gt;2-&gt;5”,<br>  “1-&gt;3”<br>]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>递归。<br>如果当前节点存在左右子树，优先递归左子树，再递归右子树。<br>如果当前节点不存在子树，将当前节点添加到String后，将String加入到list</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;String&gt; strings;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        strings = new ArrayList&lt;&gt;();</span><br><span class="line">        String str = &quot;&quot;;</span><br><span class="line">        findLeaf(root, str);</span><br><span class="line">        return strings;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void findLeaf(TreeNode root, String str) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String  str1 = root.val + &quot;-&gt;&quot;;</span><br><span class="line">        str = str + str1;</span><br><span class="line">        if(root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            strings.add(str.substring(0, str.length()-2));</span><br><span class="line">            return;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            findLeaf(root.left, str);</span><br><span class="line">            findLeaf(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/2017/03/20/blog_article/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的距离。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分治法。<br>求最大深度，当前节点左子节点的最大深度和右子节点的最大深度的较大值加一，就是将当前结点作为root的深度<br>所以，对每个节点：<br>递归左子节点得到一个深度，递归右子节点得到一个深度，然后区最大值+1，返回给自己的父节点</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return getDepth(root, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int getDepth(TreeNode root, int num) &#123;</span><br><span class="line">        int leftNum = num;</span><br><span class="line">        int rightNum = num;</span><br><span class="line">        if(root.left != null) &#123;</span><br><span class="line">            leftNum = getDepth(root.left, num+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right != null) &#123;</span><br><span class="line">            rightNum = getDepth(root.right, num+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(leftNum, rightNum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二叉树</li>
<li>分治法</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2017/03/04/blog_article/%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数字列表，返回其所有可能的排列。（你可以假设没有重复数字）<br>例子：给出一个列表[1,2,3]，其全排列为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="递归1（穷举法）"><a href="#递归1（穷举法）" class="headerlink" title="递归1（穷举法）"></a>递归1（穷举法）</h2><p>对于长度为n的数组，其全排列为：第n位的值与长度为n-1的全排列的组合。<br>考虑每次递归，选择一个未出现在List中的数组元素添加到队列，再向下递归，直到组成一种排列。<br>那怎么实现全排列呢？体现在添加元素要遍历数组，如果递归回退后，要在List里删除之前添加的元素，继续查找新的元素添加到List。</p>
<blockquote>
<p>所以，每一次递归，遍历数组，在List里添加一个新元素a，再向下递归。递归返回后，在List里删除之前添加的元素a，再遍历a元素之后的元素，找到新元素并添加到List，继续向下递归。<br>递归返回后，不需要从头遍历数组，因为上一次添加到List的元素a前面的元素已经都试过了。</p>
</blockquote>
<p>递归终止条件：</p>
<ul>
<li>如果List的元素个数与数组个数相同，表示完成了一种组合，将该List添加到保存List的链表里，终止递归</li>
<li>如果遍历完了数组，则终止递归</li>
</ul>
<h2 id="递归2（交换法）"><a href="#递归2（交换法）" class="headerlink" title="递归2（交换法）"></a>递归2（交换法）</h2><p>对于[1,2]，其全排序的方法为：1与1交换，与2的全排序。1与2交换，与1的全排序。<br>对于[1,2,3]，其全排序为：1与1交换，与[2,3]的全排序。1与2交换，与[1,3]的全排序。1与3交换，与[2,1]的全排序。</p>
<blockquote>
<p>由此可知，求全排列，就是拿当前元素（这里为1）与包括其自身在内的后面的元素交换，与后面元素的全排列的组合（因此可采用递归）。<br>注意，在递归返回时，需要将之前交换的位置还原。例如[1,3,2]添加到List后，之前互换的3、2需要还原各自的位置回到[1,2,3]，不然会影响之后的递归，因为递归算法的条件是基于初始数组位置不变递归的。</p>
</blockquote>
<h2 id="非递归1（后继法）"><a href="#非递归1（后继法）" class="headerlink" title="非递归1（后继法）"></a>非递归1（后继法）</h2><p>把每一种排列当作一个数。例如对数组[1,2,3]，其全排列包含6!个数字，没毛病<br>所以如果能找到这6!个数，也就找到了全排列</p>
<ul>
<li>首先将数组按升序排序</li>
<li>找每个数字的后继（比当前排序表示的值大的当中的最小的那个）<ul>
<li><p>从最右开始遍历数组，找到极大值（设极大值的下标是max，满足num[max-1] &lt; num[max]即可）</p>
</li>
<li><p>找到max右边（包含max）大于num[max-1]的数中的最小值，与num[max-1]交换</p>
<blockquote>
<p>其实只要找到第一个比num[max-1]小的数，其前面一个就是满足条件的数，因为max及其右边的数字都是降序的，不然不满足求极大值的条件！</p>
</blockquote>
</li>
<li><p>从max位到数组最右边倒序排列，即找到了后继数</p>
</li>
</ul>
</li>
<li>当找不到极大值max时，说明已经找到了所有的数，完成了全排列</li>
</ul>
<blockquote>
<p>以求243765为例，求其后继数：<br>找到极大值max&#x3D;7，交换5和3，变成：245763，再倒叙排列从7开始到末尾的数字，即763变成367，所以后继数为：245367</p>
</blockquote>
<h2 id="非递归2（逆序数阶乘进制法）"><a href="#非递归2（逆序数阶乘进制法）" class="headerlink" title="非递归2（逆序数阶乘进制法）"></a>非递归2（逆序数阶乘进制法）</h2><ul>
<li><p>什么是逆序数？<br><code>定义逆序数：比数字a大且位于a的右边的数字的个数。</code><br>为什么是右边呢？因为阶乘进制位于最左边的位认为是最高位</p>
<blockquote>
<p>举个例子：对于[1,2,3,4,5]，其一种排列为：32451，那么其逆序数为：22100</p>
</blockquote>
</li>
<li><p>什么是阶乘进制？<br>n进制大家都知道，是当前位的值 * n的位数次方之和。<br>阶乘进制就是：<code>当前位的值乘以当前位数的阶乘之和</code>，注意最低位的位数为0!</p>
<blockquote>
<p>对于上面的逆序数22100，其阶乘进制表示的数为：2乘以4的阶乘与2乘以3的阶乘与1乘以2的阶乘之和</p>
</blockquote>
</li>
<li><p>逆序数、阶乘进制的运用<br>对于n个不同元素的数组，全排列有n!种。<br>每种排列对应的逆序数转化成阶乘进制后，值的范围恰巧是0~n!-1，即每种排列对应的逆序数对应一个阶乘进制的值。</p>
</li>
<li><p>求全排列，也就转化成：</p>
<ul>
<li>先求对于阶乘进制在0~n!-1的值对应的逆序数</li>
<li>再将逆序数还原成对应的排列<br>求逆序数：对逆序数22100，其对应的阶乘进制的值为62，根据62求其逆序数的方法：</li>
<li>最高位：62 &#x2F; 4！ &#x3D; 2，次高位：（62%4！）&#x2F; 3！&#x3D; 2 …<br>求逆序数（对于22100）对应的排序：</li>
<li>最高位为2，可知其右边有两个数字比它大，所以该位置的值是第三大的数</li>
<li>求后面的数时，别忘了忽略之前已经排好的数</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归1"><a href="#递归1" class="headerlink" title="递归1"></a>递归1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; listHolder;</span><br><span class="line">	</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        listHolder = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        fullPack(nums, list);</span><br><span class="line">        return listHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	private void fullPack(int[] nums, List&lt;Integer&gt; list) &#123;</span><br><span class="line">		if(list.size() == nums.length) &#123;</span><br><span class="line">			Integer[] result = list.toArray(new Integer[list.size()]);</span><br><span class="line">			List&lt;Integer&gt; listCopy = new ArrayList(Arrays.asList(result));</span><br><span class="line">			listHolder.add(listCopy);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">			if(!list.contains(nums[i]))&#123;</span><br><span class="line">				list.add(nums[i]);</span><br><span class="line">				fullPack(nums, list);</span><br><span class="line">				list.remove(list.size()-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归2"><a href="#递归2" class="headerlink" title="递归2"></a>递归2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static List&lt;List&lt;Integer&gt;&gt; listHolder;</span><br><span class="line">	</span><br><span class="line">	public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">		listHolder = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">		</span><br><span class="line">		//转化为List</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		for(int num : nums) &#123;</span><br><span class="line">			list.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		myPermute(0, list);</span><br><span class="line">		return listHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static void myPermute(int start, List&lt;Integer&gt; nums) &#123;</span><br><span class="line">		if(start == nums.size()-1) &#123;</span><br><span class="line">			List&lt;Integer&gt; aList = new ArrayList&lt;Integer&gt;(nums);</span><br><span class="line">			listHolder.add(aList);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">			swap(nums, start, i);</span><br><span class="line">			myPermute(start+1, nums);</span><br><span class="line">			swap(nums, i, start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static void swap(List&lt;Integer&gt; nums, int i, int j) &#123;</span><br><span class="line">		int tmp = nums.get(i);</span><br><span class="line">		nums.set(i, nums.get(j));</span><br><span class="line">		nums.set(j, tmp);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>递归</li>
<li>int[]数组转化为List<Integer><ul>
<li>List的泛型类型是Integer不是int，所以需要先把int[]转化为Integer，方法就是遍历复制</li>
<li>然后将Integer[]数组转为队列：<br>  <code>new ArrayList&lt;Integer&gt;(Arrays.asList(integers))</code></li>
</ul>
</li>
<li>链表转数组<br><code>Integer[] result = list.toArray(new Integer[list.size()]);</code></li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>公共子字符串</title>
    <url>/2017/04/19/blog_article/%E7%AE%97%E6%B3%95/%E5%85%AC%E5%85%B1%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给两个字符串，找出最长公共子字符串</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>DP。<br>给定字符串s1，s2，长度分别为m和n。<br>如果s2的某个字符与s1匹配，那么当前位置最长公公字符串为：前一个字符处与s1匹配的字符个数+1<br>如果dp[i][j]表示s1到第i个字符和s2到第j个字符已经匹配的字符个数，那么当dp[i+1][j+1]匹配时，<br>递推公式：dp[i+1][j+1]&#x3D;dp[i][j]+1<br>其实只需要一维数组，因为每次取到s2的某个字符，匹配时，只需要找出前一个字符已经匹配的字符个数+1。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    	System.out.println(new Main().getLCS(&quot;abcefedge&quot;, &quot;fbcefed&quot;));</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public String getLCS(String s1, String s2) &#123;</span><br><span class="line">    	int n = s1.length();</span><br><span class="line">    	int[] dp = new int[n+1];</span><br><span class="line">    	</span><br><span class="line">    	int max = 0;</span><br><span class="line">    	int endIndex = 0;</span><br><span class="line">    	for(int i = 0; i &lt; s2.length(); i++) &#123;	// i为s2当前字符的下标</span><br><span class="line">    		char c = s2.charAt(i);</span><br><span class="line">    		for(int j = s1.length(); j &gt;= 1; j--) &#123;</span><br><span class="line">    			if(s1.charAt(j-1) == c) &#123;	// j-1为s1当前字符的下标</span><br><span class="line">    				dp[j] = dp[j-1] + 1;</span><br><span class="line">    				if(dp[j] &gt; max) &#123;</span><br><span class="line">    					max = dp[j];	// 公共字符串的长度</span><br><span class="line">    					endIndex = i;	// 公公字符串尾字符在s2字符串的下标</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	if(max == 0) &#123;</span><br><span class="line">    		return null;</span><br><span class="line">    	&#125;else &#123;</span><br><span class="line">    		String string = s2.substring(endIndex-max+1, endIndex+1);</span><br><span class="line">    		return string;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>DP</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>删除二叉查找树的节点</title>
    <url>/2017/03/19/blog_article/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵具有不同节点值的二叉查找树，删除树中与给定值相同的节点。如果树中没有相同值的节点，就不做任何处理。你应该保证处理之后的树仍是二叉查找树。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>递归。<br>找不到，返回null<br>找到了，分两种情况：<br>1、如果节点的left或right为null，返回那个不为null的，如果都为null，返回null<br>2、如果节点的left或right都不为null，将left的right节点加到right的左子树的最后一个node的left处，返回left</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TreeNode removeNode(TreeNode root, int value) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(value &gt; root.val) &#123;</span><br><span class="line">            root.right = removeNode(root.right, value);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else if(value &lt; root.val) &#123;</span><br><span class="line">            root.left = removeNode(root.left, value);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(root.left == null || root.right == null) &#123;</span><br><span class="line">                if(root.left == null) &#123;</span><br><span class="line">                    return root.right;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return root.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                    TreeNode tmp = root.right;</span><br><span class="line">                    while(tmp.left != null) &#123;</span><br><span class="line">                        tmp = tmp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp.left = root.left.right;</span><br><span class="line">                    root.left.right = root.right;</span><br><span class="line">                return root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>二叉查找树</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>加油站</title>
    <url>/2017/03/13/blog_article/%E7%AE%97%E6%B3%95/%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油gas[i]，并且从第_i_个加油站前往第_i_+1个加油站需要消耗汽油cost[i]。<br>你有一辆油箱容量无限大的汽车，现在要从某一个加油站出发绕环路一周，一开始油箱为空。<br>求可环绕环路一周时出发的加油站的编号，若不存在环绕一周的方案，则返回-1。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>贪心。<br>从起点出发，每次判断能否到达下一站，如果能，出发。不能，将下一站设为起点。<br>如果中途发现到不了下一站了，那么之前经过的任意一站都无法作为起点，因为这次旅途的起点就是满足出发条件的，既然到中途发现到不了下一站了，那么从中间站点出发到当前站肯定也到不了下一站。<br>如果在最后一站失败，直接失败，因为之前所有的站多作为起点试过了<br>如果最后一站没失败，可能需要从最后一站到起点站继续行驶，当行驶到起点，则成功。</p>
<blockquote>
<p>如果当前能从当前站出发，就出发。即，利用贪心，每次都做最利于当前情况的选择</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int start = 0;  </span><br><span class="line">        int last = 0;       // 行驶到当前位置剩余油量</span><br><span class="line">        </span><br><span class="line">        for(int i = start; i &lt; gas.length; i++) &#123;</span><br><span class="line">            if((gas[i]+last-cost[i]) &gt;= 0) &#123;</span><br><span class="line">                last = gas[i]+last-cost[i];     // 继续行驶</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                if(i == gas.length-1) &#123;</span><br><span class="line">                    return -1;      // 如果跑到最后一站失败了，就真的失败了</span><br><span class="line">                &#125;</span><br><span class="line">                start = i+1;        // 选择从下一个加油站出发</span><br><span class="line">                last = 0;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(start != 0) &#123;    // 不是从起点出发,继续行驶</span><br><span class="line">            for(int j = 0; j &lt; start; j++) &#123;</span><br><span class="line">                if((gas[j]+last-cost[j]) &gt;= 0) &#123;</span><br><span class="line">                    last = gas[j]+last-cost[j];</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return -1;      </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return start;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 0;   // 从起点出发的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>贪心</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>单词变换</title>
    <url>/2017/04/07/blog_article/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个单词列表，一个初始单词和一个最终单词，初始单词需要通过单词列表逐步变换到最终单词，求变换所需的最短变换路径长度。<br>变换规则：每次只能变动1个字母（不可交换位置，如：从abc变成cba属于变动了2个字母），每次变换只能从单词列表中选取。<br>例如：初始单词hot，最终单词dog，单词列表[got, dot, god, dog, lot, log]，最短变换路径为[hot,dot,dog]，最短变换路径长度为3。<br>注：单词列表中包含最终单词，不包含初始单词；列表中每一项单词长度与初始单词、最终单词相同；列表中单词不重复；所有字母均为小写。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>BFS。<br>每次将差一个字符且之前未添加的单词加入list，遍历list是一个一个遍历，即广度优先，直到找到到目标单词的最短路径</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	</span><br><span class="line">	class Node&#123;</span><br><span class="line">		String string;</span><br><span class="line">		int count;</span><br><span class="line">		public Node(String string, int count) &#123;</span><br><span class="line">			this.string = string;</span><br><span class="line">			this.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public ArrayList&lt;String&gt; list;</span><br><span class="line">	public String head;</span><br><span class="line">	public String tail;</span><br><span class="line">	public ArrayList&lt;Node&gt; res;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Main main = new Main();</span><br><span class="line">		main.init();</span><br><span class="line">		System.out.println(main.calculating());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int calculating() &#123;</span><br><span class="line">		res = new ArrayList&lt;&gt;();</span><br><span class="line">		res.add(new Node(head, 1));</span><br><span class="line">		int index = 0;		// 当前访问的hashMap下标</span><br><span class="line">		while(index &lt; res.size()) &#123;</span><br><span class="line">			Node node = res.get(index++);</span><br><span class="line">			String tar = node.string;</span><br><span class="line">			for(String string : list) &#123;</span><br><span class="line">				if(isOneDiff(tar, string)) &#123;		// 如果只比tar差一个字符</span><br><span class="line">					if(!containString(string)) &#123;		// 如果没访问过string</span><br><span class="line">						if(isOneDiff(tail, string)) &#123;		// 满足条件，输出结果</span><br><span class="line">							return node.count+2;</span><br><span class="line">						&#125;else &#123;</span><br><span class="line">							res.add(new Node(string, node.count+1));</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean containString(String string) &#123;</span><br><span class="line">		for(Node node : res) &#123;</span><br><span class="line">			if(node.string.equals(string)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean isOneDiff(String tar, String tmp) &#123;</span><br><span class="line">		int count = 0;</span><br><span class="line">		for(int i = 0; i &lt; tar.length(); i++) &#123;</span><br><span class="line">			if(tar.charAt(i) != tmp.charAt(i)) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return count == 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		head = scanner.nextLine();</span><br><span class="line">		tail = scanner.nextLine();</span><br><span class="line">		list = new ArrayList&lt;&gt;();</span><br><span class="line">		while(scanner.hasNext()) &#123;</span><br><span class="line">			String string = scanner.next();</span><br><span class="line">			if(!string.equals(tail)) &#123;		// 不加入tail</span><br><span class="line">				list.add(string);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>BFS</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>双核处理</title>
    <url>/2017/04/22/blog_article/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%A0%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。<br>输入例子:<br>5<br>3072 3072 7168 3072 1024</p>
<p>输出例子:<br>9216</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将问题转化为：求所有输入的数据中，累加最接近输入的总和的一半的结果，那么最少时间就是总和减去这个最接近一半的累加和<br>即：mid &#x3D; sum&#x2F;2。求累加和最接近mid的值为多少。<br>转化为了经典的背包问题  </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int n = scanner.nextInt();</span><br><span class="line">        int[] nums = new int[n];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = scanner.nextInt()/1024;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = sum/2;</span><br><span class="line">        </span><br><span class="line">        int[] dp = new int[mid+1];</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        	int tmp = nums[i];</span><br><span class="line">        	for(int j = mid; j &gt;= 0; j--) &#123;</span><br><span class="line">        		if(tmp &lt;= j) &#123;</span><br><span class="line">        			dp[j] = Math.max(dp[j], dp[j-tmp]+tmp); </span><br><span class="line">        		&#125;else &#123;</span><br><span class="line">        			break;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1024*sum - dp[mid]*1024);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>DP</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>反传数组</title>
    <url>/2017/04/11/blog_article/%E7%AE%97%E6%B3%95/%E5%8F%8D%E4%BC%A0%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个长度为n的整数数组a，元素均不相同，问数组是否存在这样一个片段，只将该片段翻转就可以使整个数组升序排列。其中数组片段[l,r]表示序列a[l], a[l+1], …, a[r]。原始数组为<br>a[1], a[2], …, a[l-2], a[l-1], a[l], a[l+1], …, a[r-1], a[r], a[r+1], a[r+2], …, a[n-1], a[n]，<br>将片段[l,r]反序后的数组是<br>a[1], a[2], …, a[l-2], a[l-1], a[r], a[r-1], …, a[l+1], a[l], a[r+1], a[r+2], …, a[n-1], a[n]。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一个数组保存原始数据，另一个数组保存排序后的数据<br>找到两个数组对应元素不相同的最左边和最右边下标<br>比较这个范围内的数组元素是否满足对称关系，如果满足，输出yes，否则输出no</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		while(scanner.hasNextInt())</span><br><span class="line">		&#123;</span><br><span class="line">			int len = scanner.nextInt();</span><br><span class="line">			int[] array = new int[len];</span><br><span class="line">			int[] copy = new int[len];</span><br><span class="line">			for(int i=0;i&lt;len;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				array[i] = scanner.nextInt();</span><br><span class="line">				copy[i] = array[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(copy);</span><br><span class="line">			int left = 0,right = len-1;</span><br><span class="line">			while(left&lt;len &amp;&amp; copy[left]==array[left]) left++;</span><br><span class="line">			while(right&gt;=0 &amp;&amp; copy[right]==array[right]) right--;</span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">			int i;</span><br><span class="line">			for(i=0;i&lt;=right-left;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(copy[left+i]!=array[right-i])</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">			if(i&gt;right-left)</span><br><span class="line">				System.out.println(&quot;yes&quot;);</span><br><span class="line">			else</span><br><span class="line">				System.out.println(&quot;no&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>数组</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>合并k个排序链表</title>
    <url>/2017/03/14/blog_article/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>归并。</p>
<ul>
<li>对左半部分的链表排序，排序后返回一个链表A</li>
<li>对右半部分的链表排序，排序后返回一个链表B</li>
<li>对链表A和链表B排序<br>这样做，每次都对两个链表排序，返回排序后的链表，归并后得到最后所有链表的排序结果<br>注意：<br>当我将链表A和B传入排序方法时，因为A和B其实是指向排序链表的一个引用，所以传入方法里的A和B没有任何数据！<br><code>切记！不要将对JAVA类的引用作为实参，如果想将函数的返回值作为实参，直接将函数作为参数</code><br><code>对于基本数据类型、String，因为是复制值不是指向数据区，所以引用也可以作为实参</code></li>
</ul>
</li>
<li><p>堆</p>
<blockquote>
<p>堆这种数据结构的好处在于，返回最值的效率很高</p>
</blockquote>
</li>
</ul>
<p>将所有头节点加入堆后，每次取堆中最小节点，再把最小节点的next节点加入堆。<br>当堆为空时，完成了对所有链表的排序</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul>
<li><p>归并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123;  </span><br><span class="line">        // write your code here</span><br><span class="line">        if(lists.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">		return  myMerge(lists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	private ListNode myMerge(List&lt;ListNode&gt; lists) &#123;</span><br><span class="line">		if(lists.size() == 1) &#123;</span><br><span class="line">			return lists.get(0);		// 递归终止条件</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int mid = lists.size() / 2;</span><br><span class="line">		</span><br><span class="line">		return mySort(myMerge(lists.subList(0, mid)), myMerge(lists.subList(mid, lists.size())));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private ListNode mySort(ListNode left, ListNode right) &#123;</span><br><span class="line">		ListNode head;</span><br><span class="line">		ListNode listNode;</span><br><span class="line">		ListNode nextNode;</span><br><span class="line">		</span><br><span class="line">		// init ListNode</span><br><span class="line">		if(left == null &amp;&amp; right == null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			if(left == null) &#123;</span><br><span class="line">				return right;</span><br><span class="line">			&#125;else if (right == null) &#123;</span><br><span class="line">				return left;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				if(left.val &lt;= right.val) &#123;</span><br><span class="line">					listNode = new ListNode(left.val);</span><br><span class="line">					head = listNode;</span><br><span class="line">					left = left.next;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					listNode = new ListNode(right.val);</span><br><span class="line">					head = listNode;</span><br><span class="line">					right = right.next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// fill ListNode</span><br><span class="line">		while(left != null &amp;&amp; right != null) &#123;</span><br><span class="line">			if(left.val &lt;= right.val) &#123;</span><br><span class="line">				nextNode = new ListNode(left.val);</span><br><span class="line">				left = left.next;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				nextNode = new ListNode(right.val);</span><br><span class="line">				right = right.next;</span><br><span class="line">			&#125;</span><br><span class="line">			listNode.next = nextNode;</span><br><span class="line">			listNode = nextNode;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left == null) &#123;</span><br><span class="line">			while(right != null) &#123;</span><br><span class="line">				nextNode = new ListNode(right.val);</span><br><span class="line">				right = right.next;</span><br><span class="line">				listNode.next = nextNode;</span><br><span class="line">				listNode = nextNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(right == null) &#123;</span><br><span class="line">			while(left != null) &#123;</span><br><span class="line">				nextNode = new ListNode(left.val);</span><br><span class="line">				left = left.next;</span><br><span class="line">				listNode.next = nextNode;</span><br><span class="line">				listNode = nextNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123;  </span><br><span class="line">        // write your code here</span><br><span class="line">		ListNode tmp;</span><br><span class="line">		ListNode head;</span><br><span class="line">		PriorityQueue&lt;ListNode&gt; priorityQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;()&#123;		// 匿名内部类实现一个比较器</span><br><span class="line">			public int compare(ListNode arg0, ListNode arg1) &#123;</span><br><span class="line">				if(arg0.val &lt; arg1.val) &#123;</span><br><span class="line">					return -1;</span><br><span class="line">				&#125;else if(arg0.val == arg1.val) &#123;</span><br><span class="line">					return 0;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					return 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		// 初始化结果链表的头部节点</span><br><span class="line">		for(ListNode listNode : lists) &#123;</span><br><span class="line">			if(listNode != null) &#123;</span><br><span class="line">				priorityQueue.add(listNode);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ListNode listNode = priorityQueue.poll();</span><br><span class="line">		if(listNode.next != null) &#123;</span><br><span class="line">			priorityQueue.add(listNode.next);</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = new ListNode(listNode.val);</span><br><span class="line">		head = tmp;</span><br><span class="line">		</span><br><span class="line">		// 每次取出当前优先队列的最小元素，如果最小元素所在的链表有next，加入next</span><br><span class="line">		// 当优先队列为空，则表示取完了所有链表里的元素</span><br><span class="line">		while(!priorityQueue.isEmpty()) &#123;</span><br><span class="line">			listNode = priorityQueue.poll();</span><br><span class="line">			tmp.next = listNode;</span><br><span class="line">			tmp = tmp.next;</span><br><span class="line">			if(listNode.next != null) &#123;</span><br><span class="line">				priorityQueue.add(listNode.next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>归并</li>
<li>堆</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>合并排序数组</title>
    <url>/2017/02/28/blog_article/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>合并两个排序的整数数组A和B变成一个新的数组。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>两个数组分别按照从左到右取元素进行比较，取较小值写入数组，该值所在数组下标递增。<br>重复上述步骤，直到比完其中一个数组，将另一个数组的值复制过去即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] mergeSortedArray(int[] A, int[] B) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        int length = A.length + B.length;</span><br><span class="line">        int[] res = new int[length];</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 0;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while(i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">            if(A[i] &lt; B[j]) &#123;</span><br><span class="line">                res[count++] = A[i++]; </span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                res[count++] = B[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i == A.length) &#123;</span><br><span class="line">            while(j &lt; B.length) &#123;</span><br><span class="line">                res[count++] = B[j++];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            while(i &lt; A.length) &#123;</span><br><span class="line">                res[count++] = A[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>简单逻辑</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>大楼轮廓</title>
    <url>/2017/03/16/blog_article/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>水平面上有 N 座大楼，每座大楼都是矩阵的形状，可以用三个数字表示 (start, end, height)，分别代表其在x轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 N 座大楼的外轮廓线。<br>外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>扫描法<br>1、将每栋大楼的开始坐标和高度作为节点，终止坐标和高度作为节点，可以用一个class来描述。<br>注意：节点class还需要增加当前节点是开始节点还是终止节点<br>所以，先通过给定的数据构造这些节点对象，将节点对象根据坐标较小的规则添加到堆中，堆使用PriorityQueue，自己创建比较器Comparator<br>2、从堆中弹出节点，从左到右开始扫描每一个节点<br>对于开始节点，将高度保存到一个堆中，根据高度决定是否已经扫描出了一个轮廓。<br>对于终止节点，根据高度判断是否已经扫描出了一个轮廓，再将该高度从堆中删除<br>3、最后一个节点扫描完后，即将所有的轮廓都扫描出来了</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buildingOutline(int[][] buildings) &#123;</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		// 将首尾坐标节点加入堆</span><br><span class="line">		PriorityQueue&lt;Node&gt; priorityQueue = new PriorityQueue&lt;&gt;(new MyComparator());</span><br><span class="line">		int number = 0;		// 大楼编号</span><br><span class="line">		for(int[] building : buildings) &#123;</span><br><span class="line">			priorityQueue.add(new Node(building[0], building[2], true, number));</span><br><span class="line">			priorityQueue.add(new Node(building[1], building[2], false, number));</span><br><span class="line">			number++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 从第一个节点开始扫描</span><br><span class="line">		PriorityQueue&lt;Integer&gt; hight = new PriorityQueue&lt;&gt;(new MyReverseComparator());		// 保存当前有效的高度的堆</span><br><span class="line">		Node first = priorityQueue.poll();</span><br><span class="line">		hight.add(first.high);</span><br><span class="line">		int start = first.index;		// 始终指向扫描通过的线段的开端</span><br><span class="line">		</span><br><span class="line">		// 开始向后扫描</span><br><span class="line">		while(!priorityQueue.isEmpty()) &#123;</span><br><span class="line">			Node node = priorityQueue.poll();</span><br><span class="line">			if(node.isStart) &#123;		// 线段的开端节点</span><br><span class="line">				if(hight.isEmpty()) &#123;</span><br><span class="line">					hight.add(node.high);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				if(node.high &gt; hight.peek()) &#123;		// 扫描到更高的开端节点</span><br><span class="line">					res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(start, node.index, hight.peek())));</span><br><span class="line">					start = node.index;		// 更新start指向</span><br><span class="line">				&#125;</span><br><span class="line">				hight.add(node.high);		// 将线段的开端节点的高度加入堆</span><br><span class="line">			&#125;else &#123;		// 线段的尾部节点</span><br><span class="line">				if(node.high == hight.peek()) &#123;		// 尾部节点即当前最高的线段的尾部节点</span><br><span class="line">					res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(start, node.index, hight.peek())));</span><br><span class="line">					start = node.index;		// 更新start指向</span><br><span class="line">				&#125;</span><br><span class="line">				hight.remove(node.high);		// 移除这段线段</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	class MyComparator implements Comparator&lt;Node&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compare(Node arg0, Node arg1) &#123;</span><br><span class="line">		return (arg0.index - arg1.index) &gt; 0 ? 1 : </span><br><span class="line">			 (arg0.index - arg1.index) &lt; 0 ? -1 : 0; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyReverseComparator implements Comparator&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return o1 &lt; 02 ? 1 : o1 &gt; o2 ? -1 : 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">	public int index;	// 节点位置</span><br><span class="line">	public int high;</span><br><span class="line">	public boolean isStart;</span><br><span class="line">	public int number;		// 大楼编号</span><br><span class="line">	</span><br><span class="line">	public Node(int index, int high, boolean isStart, int number) &#123;</span><br><span class="line">		this.index = index;</span><br><span class="line">		this.high = high;</span><br><span class="line">		this.isStart = isStart;</span><br><span class="line">		this.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>堆</li>
<li>扫描法</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2017/03/06/blog_article/%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个含不同整数的集合，返回其所有的子集，子集中的元素排列必须是非降序的，解集必须不包含重复的子集</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对含有n个不同元素的集合，其子集有2^n种。<br>对每一个元素，只有两种情况：包含与不包含。假设包含用1表示，不包含用0表示，那这n个元素就可以排列成一个二进制数，而数的范围恰巧就是0~2^n - 1</p>
<blockquote>
<p>二进制0和1就代表了两种情况，所以每一个子集必然对应一个二进制数</p>
</blockquote>
<p>所以可以通过逆向的思路求解子集：</p>
<blockquote>
<p>对在0~2^n -1的每个数 i，求其对应的二进制数，用数组a保存结果。<br>访问数组a的每一个元素，如果不为0，该位置对应的集合中的元素加入list</p>
</blockquote>
<p>例：对集合[1,2,3]，其对应的值的范围在0~7<br>当i&#x3D;6时，其二进制为110，则将1、2加入到list，再将list加入到listHolder即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listHolder;</span><br><span class="line">    </span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        // 子集非降序，那我先按升序排一遍</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		// 添加第i位，则addOrNot[i]=1,否则为0</span><br><span class="line">		int[] addOrNot = new int[nums.length];</span><br><span class="line">        listHolder = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        int count = getCount(nums.length);</span><br><span class="line">        // 遍历0~2^num.length-1，根据当前值i，构造addOrNot数组（存储i的二进制表示），输出一种子集，遍历完得到所有子集</span><br><span class="line">        for(int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        	int tmpNum = i;</span><br><span class="line">        	for(int j = nums.length-1; j &gt;=0; j--) &#123;</span><br><span class="line">        		addOrNot[j] = tmpNum / getCount(j);</span><br><span class="line">        		tmpNum %= getCount(j);</span><br><span class="line">        	&#125;</span><br><span class="line">        	// 访问addOrNot，将值为1指向的元素添加到List</span><br><span class="line">        	ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        	for(int k = 0; k &lt; addOrNot.length; k++) &#123;</span><br><span class="line">        		if(addOrNot[k] == 1) &#123;</span><br><span class="line">        			list.add(nums[k]);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	listHolder.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return listHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int getCount(int n) &#123;</span><br><span class="line">		int res = 1;</span><br><span class="line">		for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			res *= 2;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二进制的应用</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>字符串查找</title>
    <url>/2017/03/02/blog_article/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li><p>KMP算法的典型应用</p>
</li>
<li><p>KMP的核心思想是要构造next数组。</p>
</li>
<li><p>next[i]的含义<br><code>target的第i个字符及其之前的字符组成的子字符串与从target头部开始匹配的字符个数</code></p>
</li>
<li><p>next数组的求法<br>初始化：next[0]&#x3D;next[1]&#x3D;0</p>
</li>
<li><p>next数组在字符串查找中，扮演了极其重要的角色。</p>
<ul>
<li>当target[i]和source[j]不匹配时，不需要完全回退到target[0]重新开始比较，通过查找next数组，可以知道source[j-1]处已经匹配了多少个target字符，所以source[j]可以从其后的target字符开始比较，无需回退source，大大减少了重复比较的次数。</li>
</ul>
</li>
<li><p>不用KMP的暴力比较，其时间复杂度是<br><code>O(source.length() * target.length())</code></p>
</li>
<li><p>KMP的时间复杂度是<br><code>O(source.length() + target.length())</code><br>此图帮助你理解KMP的思想：<br><img src="http://img.blog.csdn.net/20130924000026250"></p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int[] next;</span><br><span class="line">    public int strStr(String source, String target) &#123;</span><br><span class="line">        // 特殊情况处理</span><br><span class="line">        if(source == null || target == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // 预处理target字符串，得到next数组</span><br><span class="line">		kmpPreview(target);</span><br><span class="line">		</span><br><span class="line">		int sourceIndex = 0;</span><br><span class="line">		int targetIndex = 0;</span><br><span class="line">		while(sourceIndex != source.length()) &#123;	// 如果访问完了source还未找到匹配，则不包含target</span><br><span class="line">			//对应字符相等的处理</span><br><span class="line">			if(source.charAt(sourceIndex) == target.charAt(targetIndex)) &#123;</span><br><span class="line">				// target匹配成功</span><br><span class="line">				if(targetIndex == target.length()-1) &#123;</span><br><span class="line">					return sourceIndex - target.length() + 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					sourceIndex++;</span><br><span class="line">					targetIndex++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;	// 对应字符不等的处理</span><br><span class="line">				// 如果回退到target头部仍不相等，则放弃当前的进度，开始比较source的下一个字符</span><br><span class="line">				if (targetIndex == 0) &#123;</span><br><span class="line">					sourceIndex++;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// 对应字符不等的处理，由next数组回退target下标，依然和当前的source对应的字符比较，利用了之前比较的进度</span><br><span class="line">					targetIndex = next[targetIndex];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 不包含target</span><br><span class="line">		return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">	 * @intention:构造next数组。next[i]表示s的第i个字符及其之前的字符组成的子字符串，与从s头开始完全匹配的字符个数</span><br><span class="line">	 */</span><br><span class="line">	private void kmpPreview(String s) &#123;</span><br><span class="line">		next = new int[s.length()+1];</span><br><span class="line">		next[0] = 0;</span><br><span class="line">		next[1] = 0;</span><br><span class="line">		for(int i = 2; i &lt;= s.length(); i++) &#123;</span><br><span class="line">			if(s.charAt(i-1) == s.charAt(next[i-1])) &#123;</span><br><span class="line">				next[i] = next[i-1] + 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				next[i] = 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>KMP算法</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>实现Trie</title>
    <url>/2017/03/25/blog_article/%E7%AE%97%E6%B3%95/%E5%AE%9E%E7%8E%B0Trie/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个 Trie，包含 insert, search, 和 startsWith 这三个方法。<br>例子：<br>insert(“lintcode”)<br>search(“code”) &#x2F;&#x2F; return false<br>startsWith(“lint”) &#x2F;&#x2F; return true<br>startsWith(“linterror”) &#x2F;&#x2F; return false<br>insert(“linterror”)<br>search(“lintcode) &#x2F;&#x2F; return true<br>startsWith(“linterror”) &#x2F;&#x2F; return true</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>单词查找树：<br>每个节点维护一个node[256]的数组<br>当前字符作为下标对应的node非空，所以每个单词都会形成一个链表<br>多个单词构成的链表组合起来，形成了单词查找树</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    // Initialize your data structure here.</span><br><span class="line">    public TrieNode[] next;</span><br><span class="line">    public boolean isWord;</span><br><span class="line">    public TrieNode() &#123; </span><br><span class="line">        next = new TrieNode[256];</span><br><span class="line">        isWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addWord() &#123;</span><br><span class="line">        isWord = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line">    private TrieNode root;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Inserts a word into the trie.</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        for(int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            if(tmp.next[word.charAt(i)] == null) &#123;</span><br><span class="line">                tmp.next[word.charAt(i)] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next[word.charAt(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.addWord();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns if the word is in the trie.</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        if(word.length() == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(tmp != null &amp;&amp; i != word.length()) &#123;</span><br><span class="line">            tmp = tmp.next[word.charAt(i)];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i == word.length()) &#123;</span><br><span class="line">            if(tmp != null &amp;&amp; tmp.isWord) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns if there is any word in the trie</span><br><span class="line">    // that starts with the given prefix.</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        if(prefix.length() == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        while(tmp != null &amp;&amp; i != prefix.length()) &#123;</span><br><span class="line">            tmp = tmp.next[prefix.charAt(i++)];</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>字符串查找</li>
<li>单词查找树</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>尾部的零</title>
    <url>/2017/02/28/blog_article/%E7%AE%97%E6%B3%95/%E5%B0%BE%E9%83%A8%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个算法，计算出n阶乘中尾部零的个数</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>n阶乘能产生尾数0，换言之就是问n阶乘能乘出多少个10<br>10分解成两个质数相乘就是：2 * 5<br>考虑 &lt;&#x3D;n 的数中，能分解出多少对 2 &amp;&amp; 5<br>分解的2肯定比5多<br>问题也就转化成了，&lt;&#x3D;n 的数中，能分解出多少个5<br>n&#x2F;5 得到能分解出1个5的个数<br>n&#x2F;5&#x2F;5 得到能分解出两个5的个数<br>…<br>所以一个while循环就可以搞定</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public long trailingZeros(long n) &#123;</span><br><span class="line">        // write your code her</span><br><span class="line">        long count = 0;</span><br><span class="line">        while(n / 5 != 0) &#123;</span><br><span class="line">            n = n / 5;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>数学题</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>带最小值操作的栈</title>
    <url>/2017/03/02/blog_article/%E7%AE%97%E6%B3%95/%E5%B8%A6%E6%9C%80%E5%B0%8F%E5%80%BC%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个带有取最小值min方法的栈，min方法将返回当前栈中的最小值。<br>你实现的栈将支持push，pop 和 min 操作，所有操作要求都在O(1)时间内完成。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑用ArrayList实现栈操作，配合队列的get\remove方法实现push\pop操作<br>实现取最小值功能需要注意：<br><code> 虽然可以简单的用一个变量保存list中的最小元素，但当该元素pop后怎么办呢？</code><br>解决办法：<br>用另一个list保存list中的最小值，每次push，如果值不大于list末尾的值，则添加到list中。<br>每次pop，如果pop的值与List末尾元素相等，则删除该元素<br>这样做，保证了此list末尾元素始终保存当前栈内最小值</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; aList;</span><br><span class="line">	ArrayList&lt;Integer&gt; minList;</span><br><span class="line">	</span><br><span class="line">	public MinStack() &#123;</span><br><span class="line">		this.aList = new ArrayList&lt;&gt;();</span><br><span class="line">		this.minList = new ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void push(int number) &#123;</span><br><span class="line">		if (aList.size() == 0) &#123;</span><br><span class="line">			aList.add(number);</span><br><span class="line">			minList.add(number);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			aList.add(number);</span><br><span class="line">			if (number &lt;= minList.get(minList.size()-1)) &#123;</span><br><span class="line">				minList.add(number);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int pop() &#123;</span><br><span class="line">		int popNum = aList.remove(aList.size()-1);</span><br><span class="line">		if(popNum == minList.get(minList.size()-1)) &#123;</span><br><span class="line">			minList.remove(minList.size()-1);</span><br><span class="line">		&#125;</span><br><span class="line">		return popNum;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    public int min() &#123;</span><br><span class="line">	    return minList.get(minList.size()-1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>栈的实现</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>带重复元素的子集</title>
    <url>/2017/03/06/blog_article/%E7%AE%97%E6%B3%95/%E5%B8%A6%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个可能具有重复数字的列表，返回其所有可能的子集<br>注意事项</p>
<ul>
<li>子集中的每个元素都是非降序的</li>
<li>两个子集间的顺序是无关紧要的</li>
<li>解集中不能包含重复子集</li>
</ul>
<p>样例<br>如果 S &#x3D; [1,2,2]，一个可能的答案为：<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先将数组升序排序，将空集添加到结果集里。<br>排序后，从头开始遍历数组，每次访问一个元素，判断其是否重复<br>对于新元素i，这样处理：</p>
<ul>
<li>访问结果集里的每个list，在其后添加i组成新的list加入到结果集（构造新的子集）</li>
</ul>
<p>对于重复元素j，这样处理：</p>
<ul>
<li>该元素的加入，新产生的子集个数为前一个元素产生的子集数<ul>
<li>因为只有在前一个子集之后加入元素j组成的子集才是不在结果集里的！</li>
<li>为什么是前一个元素？因为提前给数组排序了，j元素一定与前一个元素相同！</li>
</ul>
</li>
<li>访问结果集中的最后m个List（这些队列就是前一个元素添加到结果集的子集），在这些链表的末尾添加元素j，加入到结果集</li>
</ul>
<blockquote>
<p>新元素会对其之前的所有子集产生影响，重复元素只会影响前一个重复元素产生的新子集</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">         // write your code here</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		// 保存nums中不重复的元素</span><br><span class="line">		ArrayList&lt;Integer&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">		// count[i]表示遍历到nums[i]时，新加入的子集个数</span><br><span class="line">		int[] count = new int[nums.length];</span><br><span class="line">		// 保存结果</span><br><span class="line">		ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listHolder = new ArrayList&lt;&gt;();</span><br><span class="line">		// 预先加入空集</span><br><span class="line">		listHolder.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">		// 求非空集合</span><br><span class="line">		for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">			// 如果前面不存在该元素，取listHolder所有的list，在其后面加入该元素作为新的list加入到listHolder</span><br><span class="line">			if(!aList.contains(nums[i])) &#123;</span><br><span class="line">				aList.add(nums[i]);</span><br><span class="line">				count[i] = listHolder.size();</span><br><span class="line"></span><br><span class="line">				for(int j = 0; j &lt; count[i]; j++) &#123;</span><br><span class="line">					ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(listHolder.get(j));</span><br><span class="line">					list.add(nums[i]);</span><br><span class="line">					listHolder.add(list);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;else &#123;	// 新子集只能通过在前一个元素新产生的子集后加入该元素来构造</span><br><span class="line">				int listHolderSize = listHolder.size();</span><br><span class="line">				count[i] = count[i-1];</span><br><span class="line">				for(int j = count[i]; j &gt; 0; j--) &#123;</span><br><span class="line">					ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(listHolder.get(listHolderSize - j));</span><br><span class="line">					list.add(nums[i]);</span><br><span class="line">					listHolder.add(list);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return listHolder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>带重复元素的排列</title>
    <url>/2017/03/06/blog_article/%E7%AE%97%E6%B3%95/%E5%B8%A6%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个具有重复数字的列表，找出列表所有不同的排列。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>参考不带重复元素的全排列，讨论那四种方法是否适合带重复元素的全排列。</p>
<ul>
<li><p>穷举法<br>因为包含重复元素，穷举法显然不合适。</p>
</li>
<li><p>交换法<br>对于不带重复元素的全排列，交换法是最合适的。但如果包含重复元素，交换的过程中会出现许多重复元素之间的交换，这种交换显然是错误的，所以交换法不合适。</p>
</li>
<li><p>逆序阶乘进制法<br>直接不能用！因为对于包含重复元素的n个元素的数组，其全排列不会有n!种情况。</p>
<blockquote>
<p>其实，只有后继法最合适！</p>
</blockquote>
</li>
<li><p>后继法<br>后继法首先将数组按照升序排列，之后找当前数的下一个后继，每种后继都对应一种排列。直到最后找不到后继，完成全排列。<br>当出现重复元素时，不但不会影响原先的求后继数算法，而且还会减少求后继数的次数（因为有重复元素），<code>所以后继法本身就最合适于带重复元素的全排列！</code></p>
<blockquote>
<p>个人认为，不带重复元素的全排列，最适合用逆序阶乘进制法，交换法因为用递归所以稍逊</p>
</blockquote>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; listHolder;</span><br><span class="line">    </span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        listHolder = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if(nums.length == 0) &#123;</span><br><span class="line">            listHolder.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            return listHolder;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        addToListHolder(nums);</span><br><span class="line">        myPermuteUnique(nums);</span><br><span class="line">        return listHolder;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    private void addToListHolder(int[] nums) &#123;</span><br><span class="line">        Integer[] integers = new Integer[nums.length];</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        	integers[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        listHolder.add(new ArrayList&lt;Integer&gt;(Arrays.asList(integers)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void myPermuteUnique(int[] nums) &#123;</span><br><span class="line">		int maxIndex;</span><br><span class="line">		int switchIndex;</span><br><span class="line">		// 如果存在极大值，寻找排列</span><br><span class="line">		while((maxIndex = getMaxIndex(nums)) != -1) &#123;</span><br><span class="line">			int beforeMax = nums[maxIndex-1];</span><br><span class="line">			switchIndex = maxIndex;</span><br><span class="line">			// 寻找可交换元素下标</span><br><span class="line">			for(int i = maxIndex+1; i &lt; nums.length; i++) &#123;</span><br><span class="line">				if(nums[i] &gt; beforeMax) &#123;</span><br><span class="line">					switchIndex = i;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 交换元素</span><br><span class="line">			swap(maxIndex-1, switchIndex, nums);</span><br><span class="line">			// 从MaxIndex开始是降序排列，需要倒序得到后继数</span><br><span class="line">			int i = maxIndex;</span><br><span class="line">			int j = nums.length-1;</span><br><span class="line">			while(i &lt; j) &#123;</span><br><span class="line">				swap(i, j, nums);</span><br><span class="line">				i++;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			// 找到一种排列，添加到List</span><br><span class="line">			addToListHolder(nums);</span><br><span class="line">		&#125;</span><br><span class="line">		// 不存在MAX时，表示找到了所有排序</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void swap(int i, int j, int[] nums) &#123;</span><br><span class="line">		int tmp = nums[i];</span><br><span class="line">		nums[i] = nums[j];</span><br><span class="line">		nums[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private int getMaxIndex(int[] nums) &#123;</span><br><span class="line">		int i = nums.length-1;</span><br><span class="line">		while(i &gt; 0) &#123;</span><br><span class="line">			if(nums[i] &gt; nums[i-1]) &#123;</span><br><span class="line">				return i;</span><br><span class="line">			&#125;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>全排列</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>异或</title>
    <url>/2017/03/30/blog_article/%E7%AE%97%E6%B3%95/%E5%BC%82%E6%88%96/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)&#x2F;2个结果。请求出这些结果中大于m的有多少个。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将数组的每个数的二进制insert到单词树中，单词树的每个节点维护一个count，记录到当前节点的数字的个数<br>到单词树中查找数组的每个数字，从最高位开始与tar比较，讨论：<br>如果数字当前位为1，tar该位为1，则访问节点代表0的子节点<br>后面的逻辑很简单，不举例了</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class TrieNode&#123;</span><br><span class="line">	TrieNode[]next = new TrieNode[2];</span><br><span class="line">	int count = 0;</span><br><span class="line">	int digit = 0;</span><br><span class="line">	public TrieNode(int digit)&#123;</span><br><span class="line">		this.digit = digit;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void insert(TrieNode root, int number)&#123;</span><br><span class="line">		TrieNode prev = root;</span><br><span class="line">		for(int i = 31; i &gt;= 0; i--)&#123;</span><br><span class="line">			int digit = (number &gt;&gt; i) &amp; 1;</span><br><span class="line">			if(prev.next[digit] == null)&#123;</span><br><span class="line">				prev.next[digit] = new TrieNode(digit);</span><br><span class="line">			&#125;</span><br><span class="line">			prev = prev.next[digit];</span><br><span class="line">			prev.count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  public static int query(TrieNode root, int a, int m, int k)&#123;</span><br><span class="line">		if(root == null)&#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		TrieNode prev = root;</span><br><span class="line">		for(int i = k; i &gt;= 0; i--)&#123;</span><br><span class="line">			int mDigit = (m &gt;&gt; i) &amp; 1;</span><br><span class="line">			int aDigit = (a &gt;&gt; i) &amp; 1;</span><br><span class="line">			if(mDigit == 1 &amp;&amp; aDigit == 1)&#123;</span><br><span class="line">				if(prev.next[0] == null)&#123;</span><br><span class="line">					return 0;</span><br><span class="line">				&#125; else&#123;</span><br><span class="line">					prev = prev.next[0];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if(mDigit == 1 &amp;&amp; aDigit == 0)&#123;</span><br><span class="line">				if(prev.next[1] == null)&#123;</span><br><span class="line">					return 0;</span><br><span class="line">				&#125; else&#123;</span><br><span class="line">					prev = prev.next[1];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if(mDigit == 0 &amp;&amp; aDigit == 0)&#123;</span><br><span class="line">				return query(prev.next[0], a, m, i-1) + (prev.next[1] == null ? 0 : prev.next[1].count);</span><br><span class="line">			&#125; else if(mDigit == 0 &amp;&amp; aDigit == 1)&#123;</span><br><span class="line">				return query(prev.next[1], a, m, i-1) + (prev.next[0] == null ? 0 : prev.next[0].count);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TrieNode root = new TrieNode(-1);</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		int n = sc.nextInt();</span><br><span class="line">		int m = sc.nextInt();</span><br><span class="line">		int[]array = new int[n];</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			insert(root, array[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		long result = 0;</span><br><span class="line">		for(int number : array)&#123;</span><br><span class="line">			result += query(root, number, m, 31);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(result / 2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>Trie</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>打印[]对</title>
    <url>/2017/03/31/blog_article/%E7%AE%97%E6%B3%95/%E6%89%93%E5%8D%B0%5B%5D%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对于[ [ [ ] ] [ ] ]，打印：<br>+—–+<br>|+—+|<br>|+-+|<br>| |</p>
<p>| |<br>|+-+|<br>|+—+|<br>+-+<br>| |</p>
<p>| |<br>+-+<br>+—–+<br>对于[][]，打印：<br>+-+<br>| |</p>
<p>| |<br>+-+<br>+-+<br>| |</p>
<p>| |<br>+-+<br>请根据输入的[]配对，打印恰当的图形</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用一个栈记录<code>[</code>出现的次数，碰到<code>]</code>时，将计数器pop出list<br>根据计数器的值，打印图形，并将每行打印push到另一个栈里（因为图形对称，所以栈保存后半部分的内容）<br>每次碰到从<code>]</code>变到<code>[</code>时，栈里添加一个新的计数器</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Stack&lt;Integer&gt; list = new Stack&lt;&gt;();</span><br><span class="line">		Stack&lt;String&gt; strings = new Stack&lt;&gt;();		// 为了对称输出，保存下半部分</span><br><span class="line">		list.push(0);</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		String string = scanner.nextLine();</span><br><span class="line">		boolean isContinue = true;	// 碰到]为false</span><br><span class="line">		for(int i = 0; i &lt; string.length(); i++) &#123;</span><br><span class="line">			char tmp = string.charAt(i);</span><br><span class="line">			if (isContinue) &#123;</span><br><span class="line">				if(tmp == &#x27;[&#x27;) &#123;	// 连续[，更新计数器</span><br><span class="line">					list.set(list.size()-1, list.peek()+1);</span><br><span class="line">				&#125;else &#123;		// 碰到]，即出现配对</span><br><span class="line">					isContinue = false;</span><br><span class="line">					int count = list.pop();</span><br><span class="line">					if(count == 1) &#123;	// 最近的配对[]只有一个[, 直接打印</span><br><span class="line">						System.out.println(&quot;+-+&quot;);</span><br><span class="line">						System.out.println(&quot;| |&quot;);</span><br><span class="line">						System.out.println();</span><br><span class="line">						System.out.println(&quot;| |&quot;);</span><br><span class="line">						System.out.println(&quot;+-+&quot;);</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					// 配对超过一个[的字符串输出</span><br><span class="line">					String string2 = &quot;+&quot;;</span><br><span class="line">					for(int j = 0; j &lt; 2*count - 1; j++) &#123;</span><br><span class="line">						string2 += &quot;-&quot;;</span><br><span class="line">					&#125;</span><br><span class="line">					string2 += &quot;+&quot;;</span><br><span class="line">					System.out.println(string2);</span><br><span class="line">					strings.push(string2);</span><br><span class="line">					count--;</span><br><span class="line">					while(count &gt; 1) &#123;	</span><br><span class="line">						string2 = &quot;|+&quot;;</span><br><span class="line">						for(int j = 0; j &lt; 2*count - 1; j++) &#123;</span><br><span class="line">							string2 += &quot;-&quot;;</span><br><span class="line">						&#125;</span><br><span class="line">						string2 += &quot;+|&quot;;</span><br><span class="line">						System.out.println(string2);</span><br><span class="line">						strings.push(string2);</span><br><span class="line">						count--;</span><br><span class="line">					&#125;</span><br><span class="line">					if(string.charAt(i+1) == &#x27;]&#x27;) &#123;		// 连续]时，最内层的[]代表的字符串要加&quot;|&quot;</span><br><span class="line">						System.out.println(&quot;|+-+|&quot;);</span><br><span class="line">						System.out.println(&quot;| |&quot;);</span><br><span class="line">						System.out.println();</span><br><span class="line">						System.out.println(&quot;| |&quot;);</span><br><span class="line">						System.out.println(&quot;|+-+|&quot;);</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						System.out.println(&quot;+-+&quot;);</span><br><span class="line">						System.out.println(&quot;| |&quot;);</span><br><span class="line">						System.out.println();</span><br><span class="line">						System.out.println(&quot;| |&quot;);</span><br><span class="line">						System.out.println(&quot;+-+&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else &#123;		// 前一个是]</span><br><span class="line">				if(tmp == &#x27;[&#x27;) &#123;	// 添加新的配对计数器</span><br><span class="line">					list.push(1);</span><br><span class="line">					isContinue = true; </span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					System.out.println(strings.pop());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>栈</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>按层打印二叉树</title>
    <url>/2017/04/07/blog_article/%E7%AE%97%E6%B3%95/%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树的前序（根、左、右）和中序（左、根、右）的打印结果，输出此二叉树按层（从左往右）打印结果。<br>例如一棵二叉树前序：1 2 4 5 3；中序：4 2 5 1 3。可以构建出下图所示二叉树：<br>         1<br>        &#x2F;  <br>      2     3<br>    &#x2F;  <br>  4     5<br>按层打印的结果则为：1 2 3 4 5。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据序列还原二叉树，再层次遍历。<br>1、根据前序还原1-2-4<br>2、对后面的节点（5、3）依次添加到二叉树，添加规则：<br>找到节点i在中序的下标，从后往前遍历其左边的元素，当发现左边的节点j在已经还原的二叉树中时（其一定是节点i的根节点），根据节点i在节点j的左侧还是右侧（由中序可以判断得到），就可以将节点i添加到二叉树正确的位置</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	// 定义节点</span><br><span class="line">	class Node&#123;</span><br><span class="line">		int val;</span><br><span class="line">		Node left;</span><br><span class="line">		Node right;</span><br><span class="line">		public Node(int val) &#123;</span><br><span class="line">			this.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public  ArrayList&lt;Integer&gt; gzy;	// 保存根左右的序列</span><br><span class="line">	public  ArrayList&lt;Integer&gt; zgy;	// 保存左跟右的序列</span><br><span class="line">	public  ArrayList&lt;Node&gt; pack;		// 保存已经排好的节点</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Main main = new Main();</span><br><span class="line">		main.getResult();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void getResult() &#123;</span><br><span class="line">		// init</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		int count = scanner.nextInt();</span><br><span class="line">		gzy = new ArrayList&lt;&gt;();</span><br><span class="line">		zgy = new ArrayList&lt;&gt;();</span><br><span class="line">		for(int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">			gzy.add(scanner.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">			zgy.add(scanner.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		pack = new ArrayList&lt;&gt;();		// 已经还原的节点</span><br><span class="line">		</span><br><span class="line">		// exception</span><br><span class="line">		if(count == 1) &#123;</span><br><span class="line">			System.out.println(gzy.get(0));</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 构造最左侧节点的二叉树</span><br><span class="line">		Node node = new Node(gzy.get(0));</span><br><span class="line">		pack.add(node);</span><br><span class="line">		int index1 = 1;		// 根左右的下标</span><br><span class="line">		Node tmp = node;</span><br><span class="line">		while(gzy.get(index1) != zgy.get(0)) &#123;		// 如果没访问到最左边的叶子节点,继续还原最左侧二叉树</span><br><span class="line">			tmp.left = new Node(gzy.get(index1++));</span><br><span class="line">			tmp = tmp.left;</span><br><span class="line">			pack.add(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		tmp.left = new Node(gzy.get(index1++));</span><br><span class="line">		pack.add(tmp.left);</span><br><span class="line">		</span><br><span class="line">		// 加入剩余的节点完善二叉树</span><br><span class="line">		for(int k = index1; k &lt; gzy.size(); k++) &#123;</span><br><span class="line">			fillErCS(gzy.get(k));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 层次遍历</span><br><span class="line">		ArrayList&lt;Node&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		res.add(node);</span><br><span class="line">		int num = 0;</span><br><span class="line">		while(res.size() != num) &#123;</span><br><span class="line">			System.out.print(res.get(num).val + &quot; &quot;);</span><br><span class="line">			if(res.get(num).left != null) &#123;</span><br><span class="line">				res.add(res.get(num).left);</span><br><span class="line">			&#125;</span><br><span class="line">			if(res.get(num).right != null) &#123;</span><br><span class="line">				res.add(res.get(num).right);</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 将值为val的节点加入二叉树</span><br><span class="line">	private void fillErCS(int val) &#123;</span><br><span class="line">		int index = zgy.indexOf(val);</span><br><span class="line">		// 每一个遍历的节点都是val节点的根或者在其左边</span><br><span class="line">		for(int i = index-1; i &gt;= 0; i--) &#123;</span><br><span class="line">			if(findNode(zgy.get(i)) != null) &#123;	// 找到待插入节点的根节点或者其左边的节点</span><br><span class="line">				Node node = findNode(zgy.get(i));</span><br><span class="line">				insert(node, val);</span><br><span class="line">				break;</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 将节点val插入二叉树</span><br><span class="line">	private void insert(Node node, int val) &#123;</span><br><span class="line">		if(zgy.indexOf(node.val) &gt; zgy.indexOf(val)) &#123;	// node在待插入节点的右边</span><br><span class="line">			if(node.left == null) &#123;</span><br><span class="line">				node.left = new Node(val);</span><br><span class="line">				pack.add(node.left);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			insert(node.left, val);</span><br><span class="line">		&#125;else &#123;		// node在待插入节点的左边或是其根</span><br><span class="line">			if(node.right == null) &#123;</span><br><span class="line">				node.right = new Node(val);</span><br><span class="line">				pack.add(node.right);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			insert(node.right, val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 根据val找到pack里的节点</span><br><span class="line">	private Node findNode(int val) &#123;</span><br><span class="line">		for(Node node : pack) &#123;</span><br><span class="line">			if(node.val == val) &#123;</span><br><span class="line">				return node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二叉树</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>排序矩阵中从小到大第k个数</title>
    <url>/2017/03/26/blog_article/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%AC%ACk%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个排序矩阵中找从小到大的第 k 个整数。<br>排序矩阵的定义为：每一行递增，每一列也递增。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用堆。<br>将矩阵中的第一列元素加入堆中<br>从堆中取出最小元素，再将该元素所在数组的下一个元素加入堆中，重复k次</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int kthSmallest(int[][] matrix, int k) &#123;</span><br><span class="line">       // write your code here</span><br><span class="line">	if(matrix.length == 0) &#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	PriorityQueue&lt;Element&gt; heap = new PriorityQueue&lt;&gt;();</span><br><span class="line">	int row = matrix.length;</span><br><span class="line">	for(int j = 0; j &lt; row; j++) &#123;</span><br><span class="line">		heap.add(new Element(j, 0, matrix[j][0]));</span><br><span class="line">	&#125;</span><br><span class="line">	int count = 1; </span><br><span class="line">	while(count &lt; k) &#123;</span><br><span class="line">	    if(heap.size() == 0) &#123;</span><br><span class="line">	        break;</span><br><span class="line">	    &#125;</span><br><span class="line">		Element top = heap.poll();</span><br><span class="line">		count++;</span><br><span class="line">		if(top.col == matrix[0].length-1) &#123;</span><br><span class="line">		    continue;</span><br><span class="line">		&#125;</span><br><span class="line">		heap.add(new Element(top.row, top.col+1, matrix[top.row][top.col+1]));</span><br><span class="line">	&#125;</span><br><span class="line">	if(count &lt; k) &#123;</span><br><span class="line">	    return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return heap.poll().val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Element implements Comparable&lt;Element&gt;&#123;</span><br><span class="line">   	public int val;</span><br><span class="line">   	public int col;</span><br><span class="line">   	public int row;</span><br><span class="line">   	public Element(int row, int col, int val) &#123;</span><br><span class="line">   		this.row = row;</span><br><span class="line">   		this.col = col;</span><br><span class="line">   		this.val = val;</span><br><span class="line">   	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Element o) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return this.val &gt; o.val ? 1 :  </span><br><span class="line">			   this.val &lt; o.val ? -1 : 0;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>堆</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>数据流中位数</title>
    <url>/2017/03/20/blog_article/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数字是不断进入数组的，在每次添加一个新的数进入数组的同时返回当前新数组的中位数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用一个大顶堆一个小顶堆即可。<br>参考：滑动窗口的中位数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Help implements Comparable&lt;Help&gt;&#123;</span><br><span class="line">		public int val;</span><br><span class="line">		</span><br><span class="line">		public Help(int val) &#123;</span><br><span class="line">			this.val = val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public int compareTo(Help o) &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line">			return this.val &lt; o.val ? 1 :</span><br><span class="line">				   this.val &gt; o.val ? -1 : 0;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int[] medianII(int[] nums) &#123;</span><br><span class="line">    	// init</span><br><span class="line">    	int[] ret = new int[nums.length];</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Help&gt; maxHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">        ret[0] = nums[0];</span><br><span class="line">        maxHeap.add(new Help(nums[0]));</span><br><span class="line">        </span><br><span class="line">        // find mid after first</span><br><span class="line">        for(int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        	if(nums[i] &gt; maxHeap.peek().val) &#123;</span><br><span class="line">        		minHeap.add(nums[i]);</span><br><span class="line">        	&#125;else &#123;</span><br><span class="line">        		maxHeap.add(new Help(nums[i]));</span><br><span class="line">        	&#125;</span><br><span class="line">    </span><br><span class="line">        	if(i % 2 == 0) &#123;</span><br><span class="line">    			if(maxHeap.size() &gt; minHeap.size()) &#123;</span><br><span class="line">    				while((maxHeap.size() - minHeap.size()) != 1) &#123;</span><br><span class="line">    					minHeap.add(maxHeap.poll().val);</span><br><span class="line">    				&#125;</span><br><span class="line">    				ret[i] = maxHeap.peek().val;</span><br><span class="line">    			&#125;else &#123;</span><br><span class="line">    				while((maxHeap.size() - minHeap.size()) != 1) &#123;</span><br><span class="line">    					maxHeap.add(new Help(minHeap.poll()));</span><br><span class="line">    				&#125;</span><br><span class="line">    				ret[i] = maxHeap.peek().val;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			if(maxHeap.size() &gt; minHeap.size()) &#123;</span><br><span class="line">    				while(maxHeap.size() != minHeap.size()) &#123;</span><br><span class="line">    					minHeap.add(maxHeap.poll().val);</span><br><span class="line">    				&#125;</span><br><span class="line">    				ret[i] = maxHeap.peek().val;</span><br><span class="line">    			&#125;else &#123;</span><br><span class="line">    				while(maxHeap.size() != minHeap.size()) &#123;</span><br><span class="line">    					maxHeap.add(new Help(minHeap.poll()));</span><br><span class="line">    				&#125;</span><br><span class="line">    				ret[i] = maxHeap.peek().val;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>堆</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>旋转字符串</title>
    <url>/2017/03/01/blog_article/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串和一个偏移量，根据偏移量旋转字符串(从左向右旋转)。<br>例如，对于字符串<code>abcdefg</code>，offset&#x3D;1 &#x3D;&gt; “gabcdef”</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>k（偏移量）次移位法<ul>
<li>对于偏移量k，每次从左到右移位一次，移动k次即可</li>
<li>注意，每次移位先保存最左边的char，然后从右二开始从左到右一个一个移位</li>
</ul>
</li>
<li>对称变换法<ul>
<li>对于一个字符串，如果将其分成两部分，对于每一部分均对称变换，然后再对合起来的字符串对称变换，字符串的相对位置不变。</li>
<li>所以对于偏移量为k，其效果是将最右边的k位移到左边。考虑将最右边的k位对称变换，将左边开始的n-k位对称变换，之后再对合起来的字符串对称变换即可。</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void rotateString(char[] str, int offset) &#123;</span><br><span class="line">            if(str.length == 0) return;</span><br><span class="line">            offset = offset % str.length;</span><br><span class="line">	        mysubRotate(str, 0, str.length-offset-1);</span><br><span class="line">	        mysubRotate(str, str.length-offset, str.length-1);</span><br><span class="line">	        mysubRotate(str, 0, str.length-1);</span><br><span class="line">&#125;</span><br><span class="line">	    </span><br><span class="line">private void mysubRotate(char[] str, int start, int end) &#123;</span><br><span class="line">	        while(start &lt; end) &#123;</span><br><span class="line">	            char tmp = str[start];</span><br><span class="line">	            str[start] = str[end];</span><br><span class="line">	            str[end] = tmp;</span><br><span class="line">	            start++;</span><br><span class="line">	            end--;</span><br><span class="line">	        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>字符串处理</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>最大子数组</title>
    <url>/2017/03/11/blog_article/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>贪心。每次访问的元素，判断其是否应该在子数组中，分这两种情况处理。</p>
<blockquote>
<p>用curMax[i]表示访问到nums[i]时，子数组最大的和。</p>
</blockquote>
<p>讨论：</p>
<ul>
<li>当curMax[i]+nums[i+1] &lt; 0，curMax[i+1]&#x3D;0，因为nums[i+1]一定不在最大子数组里，置零不要让其影响之后的curMax[i]的计算</li>
<li>当curMax[i]+nums[i+1] &gt;&#x3D; 0，更新curMax[i+1]，并判断是否要更新最大子数组的和。<blockquote>
<p>虽然nums[i+1]可能是负数，但只要curMax[i+1]是正的，则其仍可能作为最大子数组的一部分！</p>
</blockquote>
</li>
</ul>
<p>上面的讨论其实在假设curMax[i]&gt;&#x3D;0时绝对是正确的，所以可以做一些预处理：</p>
<ul>
<li>找到第一个大于等于0的nums[i]的下标i，从这里开始运用动态规划</li>
<li>同时，用一个变量表示数组的最大值，如果数组全是负数，输出这个最大值即可</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int exception = nums[0];    // 如果全负，返回最大值</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(nums[i] &gt; exception) &#123;</span><br><span class="line">                exception = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i] &gt;= 0) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(start == nums.length-1) &#123;    // 如果全负数，返回最大值</span><br><span class="line">            return exception;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int res = nums[start];  // 保存子数组最大值</span><br><span class="line">        int[] curMax = new int[nums.length];    // 表示当前位置的子数组最大值</span><br><span class="line">        curMax[start] = nums[start];</span><br><span class="line">        for(int i = start+1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int tmp = curMax[i-1]+nums[i];</span><br><span class="line">            if(tmp &lt; 0) &#123;   </span><br><span class="line">                curMax[i] = 0;  // 别影响后面的</span><br><span class="line">            &#125;else &#123;     // 如果大于0，更新curMax[i]</span><br><span class="line">                curMax[i] = tmp;</span><br><span class="line">                if(res &lt; curMax[i]) &#123;</span><br><span class="line">                    res = curMax[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>


<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>动态规划（贪心）</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>最小调整代价</title>
    <url>/2017/03/27/blog_article/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E8%B0%83%E6%95%B4%E4%BB%A3%E4%BB%B7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给一个整数数组，调整每个数的大小，使得相邻的两个数的差小于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少<br>你可以假设数组中每个整数都是正整数，且小于等于100<br>样例<br>对于数组[1, 4, 2, 3]和target&#x3D;1，最小的调整方案是调整为[2, 3, 2, 3]，调整代价之和是2。返回2。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>DP。<br><code>动态规划一般是用数组表示结果集，每次新元素加入时动态更新数组的数据</code>。所以首先就要明确怎么定义数组。<br>每个新元素，都可能会调整到1~100。所以考虑用一个二维数组，row对应n个元素，col为101（位置0没用，因为是正整数）<br>二维数组的意义是什么呢？<br>cost[i][j]表示第i个元素调整到位置j后，所需要付出的最小的代价和。所以其依赖于前一个元素调整到[j-target,j+target]范围内的最小代价和。<br>更新公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前元素到j的代价与上一个元素的代价之和，在上一个元素有效区间内的最小代价</span><br><span class="line">cost[i][j] = Math.min(cost[i][j], cost[i-1][k]+tmpCost); </span><br></pre></td></tr></table></figure>

<p>最后代价和会保存在cost[n-1][]中，找到最小值就是最小的代价和。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int MinAdjustmentCost(ArrayList&lt;Integer&gt; A, int target) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        int n = A.size();</span><br><span class="line">        int[][] cost = new int[n][101];     // A[i][j]：第i个元素移动到位置j时需要付出的最小代价和（算上之前的代价）</span><br><span class="line">        for(int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            cost[0][i] = Math.abs(i-A.get(0));       // 初始化第一个元素的代价</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; n; i++) &#123;        // 从第二个元素开始，DP代价数组</span><br><span class="line">            for(int j = 1; j &lt;= 100; j++) &#123;</span><br><span class="line">                cost[i][j] = Integer.MAX_VALUE;     // 为了DP迭代服务</span><br><span class="line">                int tmpCost = Math.abs(A.get(i)-j);     // 当前元素到位置j的代价</span><br><span class="line">                int min = Math.max(1, j-target);        //min和max为上一个元素的代价数组起作用的范围</span><br><span class="line">                int max = Math.min(100, j+target);</span><br><span class="line">                for(int k = min; k &lt;= max; k++) &#123;       // k表示在上一个元素起作用范围内的下标</span><br><span class="line">                    // 动态规划当前元素到位置j的代价：</span><br><span class="line">                    // 当前元素到j的代价与上一个元素的代价之和，在上一个元素有效区间内的最小代价</span><br><span class="line">                    cost[i][j] = Math.min(cost[i][j], cost[i-1][k]+tmpCost);            </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 求最小的总代价和</span><br><span class="line">        int res = cost[n-1][1];</span><br><span class="line">        for(int i = 2; i &lt;= 100; i++) &#123;</span><br><span class="line">            if(res &gt; cost[n-1][i]) &#123;</span><br><span class="line">                res = cost[n-1][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>DP</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>最近公共祖先</title>
    <url>/2017/03/26/blog_article/%E7%AE%97%E6%B3%95/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。<br>例子：对于下面这棵二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  4</span><br><span class="line"> / \</span><br><span class="line">3   7</span><br><span class="line">   / \</span><br><span class="line">  5   6</span><br></pre></td></tr></table></figure>
<p>LCA(3, 5) &#x3D; 4<br>LCA(5, 6) &#x3D; 7<br>LCA(6, 7) &#x3D; 7</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>注意：这里是二叉树，并非二叉查找树！<br>在二叉树中递归查找这两个元素的过程中，将这两个元素路径上的父节点都加入到两个list中<br>从头访问list元素较少的那个list，判断其元素是否存在于另一个list中，存在即找到公共祖先，不存在则没有公共祖先<br><code>如何将元素所有的祖先都加入到list且是按照由近祖先到远祖先的顺序？</code><br>1、从二叉树的根节点开始，判断当前节点是否为tar，是则添加到list里，返回true<br>2、当前节点 !&#x3D; tar，递归左子树，并判断递归函数返回的结果：<br>i、如果为true，表示找到tar了，将当前结点加入到list，返回true，因为当前节点就是祖先！<br>ii、如果为false，表示没找到tar，则递归右子树，并判断递归函数返回的结果，判断的处理逻辑同上！</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode A, TreeNode B) &#123;</span><br><span class="line">        // exp</span><br><span class="line">        if(A.val == root.val || B.val == root.val) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        // init stack to hold father</span><br><span class="line">        ArrayList&lt;TreeNode&gt; listA = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; listB = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // find A</span><br><span class="line">        findLoc(root, A, listA);</span><br><span class="line">        findLoc(root, B, listB);</span><br><span class="line">        </span><br><span class="line">        // find common root</span><br><span class="line">        if(listA.size() &lt; listB.size()) &#123;</span><br><span class="line">            for(int i = 0; i &lt; listA.size(); i++) &#123;</span><br><span class="line">                if(listB.contains(listA.get(i))) &#123;</span><br><span class="line">                    return listA.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int i = 0; i &lt; listB.size(); i++) &#123;</span><br><span class="line">                if(listA.contains(listB.get(i))) &#123;</span><br><span class="line">                    return listB.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 当前节点找不到，找左子树，左子树找不到，找右子树</span><br><span class="line">    private boolean findLoc(TreeNode root, TreeNode tar, ArrayList&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val == tar.val) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!findLoc(root.left, tar, list)) &#123;   // 当前节点未找到，且左子树没找到</span><br><span class="line">            if(findLoc(root.right, tar, list)) &#123;   // 右子树找到了</span><br><span class="line">                list.add(root);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else &#123;     // 右子树没找到</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;     // 当前节点没找到，左子树找到了</span><br><span class="line">            list.add(root);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二叉树</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>最长非降序子数组</title>
    <url>/2017/04/19/blog_article/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>找出数组中非降序最长子数组</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>DP。<br>dp[n]记录第i个元素位置处满足条件子数组的长度。<br>如果第i个元素大于等于第i-1个元素，<br>迭代公式：dp[i]&#x3D;dp[i-1]+1</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    	int[] res = new Main().getIncreaseLen(new int[]&#123;1,2,3,5,4,6,7,8,9&#125;);</span><br><span class="line">    	for(int n : res) &#123;</span><br><span class="line">    		System.out.print(n);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public int[] getIncreaseLen(int[] num) &#123;</span><br><span class="line">    	int n = num.length;</span><br><span class="line">    	int[] dp = new int[n];</span><br><span class="line">    	dp[0] = 1;</span><br><span class="line">    	int max = 1;	// 最长非降序个数</span><br><span class="line">    	int index = 0;		// 指向最长非降序子数组的末尾</span><br><span class="line">    	for(int i = 1; i &lt; num.length; i++) &#123;</span><br><span class="line">    		if(num[i] &gt;= num[i-1]) &#123;</span><br><span class="line">    			dp[i] = dp[i-1] + 1;</span><br><span class="line">    			if(dp[i] &gt; max) &#123;</span><br><span class="line">    				max = dp[i];</span><br><span class="line">    				index = i;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			dp[i] = 1;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	int[] res = new int[max];</span><br><span class="line">    	for(int j = 0; j &lt; max; j++) &#123;</span><br><span class="line">    		res[j] = num[index-max+1+j];</span><br><span class="line">    	&#125;</span><br><span class="line">    	return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>DP</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>有序字符串搜索</title>
    <url>/2017/04/12/blog_article/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一些字符串，请写一个算法，从中搜索出包含您输入的字符序列的那些字符串，按匹配度的高低排序输出。没有任何一个字符串匹配上，输出-1。<br>字符串源source 如下：<br>“AB”,<br>“ABC”,<br>“ACB”,<br>“ABCD”,<br>“ADBCF”,<br>“ABDCF”,<br>“ABDC”,<br>“ABDFCG”,<br>“ABDFGC”,<br>“ABDEFG”,<br>“GABCEFG”</p>
<p>若输入查找的有序字符序列为”ABC”，则运算结果如下（请注意结果的排序规则）。<br>ABC         （匹配    ABC）(完全匹配上，匹配度最大)<br>ABCD      （匹配    ABC.）<br>ABDC      （匹配    AB.C）<br>ABDCF    （匹配    AB.C.）<br>ABDFCG （匹配    AB..C.）<br>ABDFGC （匹配    AB…C）<br>ADBCF    （匹配   A.BC.）<br>GABCEFG（匹配  .ABC…）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>Tries查找基本实现稍作修改即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*请完成下面这个函数，实现题目要求的功能*/</span><br><span class="line">/*当然，你也可以不按照下面这个模板来作答，完全按照自己的想法来 ^-^ */</span><br><span class="line">/******************************开始写代码******************************/</span><br><span class="line">    static class Node&#123;</span><br><span class="line">    	Node[] nodes = new Node[256];</span><br><span class="line">    	boolean isWord = false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	public String[] doFilter(String[] source, String filter) &#123;</span><br><span class="line">    	// 构造单词树</span><br><span class="line">		Node root = new Node();</span><br><span class="line">    	Node tmp = root;</span><br><span class="line">		for(String string : source) &#123;</span><br><span class="line">    		for(int i = 0; i &lt; string.length(); i++) &#123;</span><br><span class="line">    			if(tmp.nodes[string.charAt(i) + 0] == null) &#123;</span><br><span class="line">    				tmp.nodes[string.charAt(i) + 0] = new Node();</span><br><span class="line">    			&#125;</span><br><span class="line">    			tmp = tmp.nodes[string.charAt(i) + 0];</span><br><span class="line">    		&#125;</span><br><span class="line">    		tmp.isWord = true;</span><br><span class="line">    		tmp = root;</span><br><span class="line">    	&#125;</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();	// 保存满足条件的字符串</span><br><span class="line">		findRes(result, 0, filter, root, &quot;&quot;);</span><br><span class="line">		int L = result.size();</span><br><span class="line">		String[] strings = new String[L];</span><br><span class="line">		for(int i = 0; i &lt; L; i++) &#123;</span><br><span class="line">			strings[i] = result.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		return strings;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @param list</span><br><span class="line">	 * @param index:当前root需要找的下一个filter字符下标</span><br><span class="line">	 * @param filter</span><br><span class="line">	 * @param root</span><br><span class="line">	 * @param string</span><br><span class="line">	 */</span><br><span class="line">	public void findRes(ArrayList&lt;String&gt; list, int index ,String filter, Node root, String string) &#123;</span><br><span class="line">		if(index == filter.length()) &#123;	// 找到匹配</span><br><span class="line">			if(root.isWord) &#123;</span><br><span class="line">				list.add(string);	// 是单词，加入结果集</span><br><span class="line">			&#125;</span><br><span class="line">			deepFind(list, root, string);	// 全部匹配后继续向下搜索符合要求的单词</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		char c = filter.charAt(index);</span><br><span class="line">		if(root.nodes[c+0] != null) &#123;	// 优先匹配当前字符</span><br><span class="line">			Node before = root;		// 递归返回时保证依然能找到当前节点</span><br><span class="line">			root = root.nodes[c+0];</span><br><span class="line">			string = string + c;</span><br><span class="line">			findRes(list, index+1, filter, root, string);</span><br><span class="line">			string = string.substring(0, string.length()-1);</span><br><span class="line">			root = before;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int k = 0; k &lt; 256; k++) &#123;</span><br><span class="line">			if(k == c+0) &#123;		// 避免重复搜索</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(root.nodes[k+0] != null) &#123;</span><br><span class="line">				Node before = root;		// 递归返回时保证依然能找到当前节点</span><br><span class="line">				root = root.nodes[k+0];</span><br><span class="line">				string = string + (char)k;</span><br><span class="line">				findRes(list, index, filter, root, string);</span><br><span class="line">				string = string.substring(0, string.length()-1);</span><br><span class="line">				root = before;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public void deepFind(ArrayList&lt;String&gt; list, Node root, String string) &#123;</span><br><span class="line">		for(int k = 0; k &lt; 256; k++) &#123;</span><br><span class="line">			if(root.nodes[k] != null) &#123;</span><br><span class="line">				Node before = root;		// 递归返回时保证依然能找到当前节点</span><br><span class="line">				root = root.nodes[k];</span><br><span class="line">				string = string + (char)k;</span><br><span class="line">				if(root.isWord) &#123;</span><br><span class="line">					list.add(string);</span><br><span class="line">				&#125;</span><br><span class="line">				deepFind(list, root, string);</span><br><span class="line">				string = string.substring(0, string.length()-1);</span><br><span class="line">				root = before;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">/******************************结束写代码******************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">     </span><br><span class="line">      String[] _source = &#123;</span><br><span class="line">                &quot;AB&quot;,</span><br><span class="line">                &quot;ABC&quot;,</span><br><span class="line">                &quot;ACB&quot;,</span><br><span class="line">                &quot;ABCD&quot;,</span><br><span class="line">                &quot;ADBCF&quot;,</span><br><span class="line">                &quot;ABDCF&quot;,</span><br><span class="line">                &quot;ABDC&quot;,</span><br><span class="line">                &quot;ABDFCG&quot;,</span><br><span class="line">                &quot;ABDFGC&quot;,</span><br><span class="line">                &quot;ABDEFG&quot;,</span><br><span class="line">                &quot;GABCEFG&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">      </span><br><span class="line">        Scanner in = new Scanner(System.in);    </span><br><span class="line">        ArrayList&lt;String&gt; _filter = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        while(in.hasNext()) &#123;</span><br><span class="line">        	_filter.add(in.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line">        Main main = new Main();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; _filter.size(); i++) &#123;</span><br><span class="line">        	String[] res = main.doFilter(_source, _filter.get(i));</span><br><span class="line">            if(res.length == 0) &#123;</span><br><span class="line">            	System.out.println(-1);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">            	for(int res_i=0; res_i &lt; res.length; res_i++) &#123;</span><br><span class="line">                    System.out.println(String.valueOf(res[res_i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>Tries</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>次数的期望值</title>
    <url>/2017/03/31/blog_article/%E7%AE%97%E6%B3%95/%E6%AC%A1%E6%95%B0%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小嗨玩电子游戏。 每当他在游戏中完成任务时，小嗨都有机会获得一个传奇的物品。<br>一开始概率为P％。 每次Little Hi完成任务而没有获得传奇物品，概率将上升Q％。 由于概率越来越高，他最终会得到一个传奇物品。<br>获得传奇物品后，概率将重置为⌊P&#x2F;（2I）⌋％（⌊x⌋表示最大整数，不超过x），其中我是其已有的传奇物品的数量。 每当Little Hi完成任务时，概率也将上升Q％，直到他获得另一个传奇物品。<br>现在，小嗨想知道他要完成的N个传奇物品的预期数量。<br>假设P &#x3D; 50，Q &#x3D; 75，N &#x3D; 2，如下图所示，预期的任务数是<br>2 * 50％* 25％+ 3 * 50％* 75％* 100％+ 3 * 50％* 100％* 25％+ 4 * 50％* 100％* 75％* 100％&#x3D; 3.25</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>构造二叉树，每个节点都有两个子节点，一个表示获得了奖励，另一个表示没得到奖励。<br>每个节点维护四个属性：获得的奖励数，到达该节点需要的概率，该节点的深度（即已经尝试的次数），到达该节点已经失败了的次数<br>按照题意，递归创建该二叉树<br>递归终止条件：<br>当节点的奖励数达到要求时返回<br>再递归遍历二叉树，根据每个节点的概率和叶子节点的深度即可求出最后的期望值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.awt.image.RescaleOp;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">import sun.java2d.pipe.SpanIterator;</span><br><span class="line"></span><br><span class="line">class Node&#123;</span><br><span class="line">	public int num;</span><br><span class="line">	public double possible;</span><br><span class="line">	public Node left;	// 成功</span><br><span class="line">	public Node Right;</span><br><span class="line">	public int depth;</span><br><span class="line">	public int failTime;</span><br><span class="line">	public Node(int num, double possible, int depth, int faliTime) &#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">		this.possible = possible;</span><br><span class="line">		this.depth = depth;</span><br><span class="line">		this.failTime = faliTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	private static int N;</span><br><span class="line">	private static double P;</span><br><span class="line">	private static double Q;</span><br><span class="line">	public static float res = 0;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		N = scanner.nextInt();</span><br><span class="line">		P = scanner.nextDouble();</span><br><span class="line">		Q = scanner.nextDouble();</span><br><span class="line">		</span><br><span class="line">		Node root = new Node(0, 1, 0, 0);</span><br><span class="line">		root.left = new Node(root.num+1, P, 1, 0);</span><br><span class="line">		root.Right = new Node(root.num, 1-P, 1, 1);</span><br><span class="line">		</span><br><span class="line">		constructLeft(root.left);</span><br><span class="line">		constructRight(root.Right);</span><br><span class="line">		</span><br><span class="line">		getPossible(root, 1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(Main.res);</span><br><span class="line">	&#125;</span><br><span class="line">	private static void getPossible(Node root, float single) &#123;</span><br><span class="line">		if(root == null ) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(root.num &lt;= N) &#123;</span><br><span class="line">			single *= root.possible;</span><br><span class="line">		&#125;</span><br><span class="line">		if(root.num == N) &#123;</span><br><span class="line">			single *= root.depth;</span><br><span class="line">			res += single;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		getPossible(root.left, single);</span><br><span class="line">		getPossible(root.Right, single);</span><br><span class="line">	&#125;</span><br><span class="line">	private static void constructLeft(Node root) &#123;</span><br><span class="line">		if(root.num == N) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		root.left = new Node(root.num+1, P/(2*root.num), root.depth+1, 0);</span><br><span class="line">		root.Right = new Node(root.num, 1-(root.left.possible), root.depth+1, root.failTime+1);</span><br><span class="line">		constructLeft(root.left);</span><br><span class="line">		constructRight(root.Right);</span><br><span class="line">	&#125;</span><br><span class="line">	private static void constructRight(Node root) &#123;</span><br><span class="line">		if(root.num == N) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(root.possible+Q*root.failTime &gt;= 1) &#123;</span><br><span class="line">			</span><br><span class="line">			root.left = new Node(root.num+1, 1, root.depth+1, 0);</span><br><span class="line">			constructLeft(root.left);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			root.left = new Node(root.num+1, root.possible+Q*root.failTime, root.depth+1, 0);</span><br><span class="line">			root.Right = new Node(root.num, 1-(root.left.possible), root.depth+1, root.failTime+1);</span><br><span class="line">			constructLeft(root.left);</span><br><span class="line">			constructRight(root.Right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>递归</li>
<li>二叉树</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>汉字读数</title>
    <url>/2017/04/16/blog_article/%E7%AE%97%E6%B3%95/%E6%B1%89%E5%AD%97%E8%AF%BB%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个汉字描述的数字，要求将其转化为普通数字。<br>例子：一千两百三十四万五千六百七十八<br>输出：12345678</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>逻辑题<br>读到”亿”和”万”，就将前面已经读到的数字都乘以指定的进制。<br>读到”十””百””千”，将前一个数字乘以指定的进制后加到结果中</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static long transfer(String str) &#123;</span><br><span class="line">    	String[] num = &#123;&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;&#125;;</span><br><span class="line">    	String[] jinzhi = &#123;&quot;十&quot;,&quot;百&quot;,&quot;千&quot;&#125;;</span><br><span class="line">    	ArrayList&lt;String&gt; numL = new ArrayList&lt;&gt;(Arrays.asList(num));		// 数字集合</span><br><span class="line">    	ArrayList&lt;String&gt; jinzhiL = new ArrayList&lt;&gt;(Arrays.asList(jinzhi));		// 进制集合</span><br><span class="line">    	</span><br><span class="line">    	long res = 0;</span><br><span class="line">    	ArrayList&lt;Integer&gt; hasReadNum = new ArrayList&lt;&gt;();</span><br><span class="line">    	boolean hasAdd = false;		// 最近一次读到的数字是否计算过</span><br><span class="line">    	for(int i = 0; i &lt; str.length()-1; i++) &#123;</span><br><span class="line">    		char tmp = str.charAt(i);</span><br><span class="line">    		if(numL.contains(tmp+&quot;&quot;)) &#123;</span><br><span class="line">    			hasReadNum.add(numL.indexOf(tmp+&quot;&quot;)+1);</span><br><span class="line">    			hasAdd = false;</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			if(jinzhiL.contains(tmp+&quot;&quot;)) &#123;</span><br><span class="line">    				int jzs = (int)Math.pow(10, jinzhiL.indexOf(tmp+&quot;&quot;)+1);</span><br><span class="line">    				res += jzs*hasReadNum.get(hasReadNum.size()-1);</span><br><span class="line">    				hasAdd = true;</span><br><span class="line">    			&#125;else &#123;</span><br><span class="line">    				if((tmp+&quot;&quot;).equals(&quot;亿&quot;)) &#123;</span><br><span class="line">    					if(hasAdd) &#123;	// 前一个数字已经累加到res</span><br><span class="line">    						res *= 10000;</span><br><span class="line">    					&#125;else &#123;</span><br><span class="line">    						res += hasReadNum.get(hasReadNum.size()-1);</span><br><span class="line">    						res *= 100000000;</span><br><span class="line">    					&#125;</span><br><span class="line">    				&#125;else if((tmp+&quot;&quot;).equals(&quot;万&quot;)) &#123;</span><br><span class="line">    					if(hasAdd) &#123;</span><br><span class="line">    						res *= 10000;</span><br><span class="line">    					&#125;else &#123;</span><br><span class="line">    						res += hasReadNum.get(hasReadNum.size()-1);</span><br><span class="line">    						res *= 10000;</span><br><span class="line">    					&#125;</span><br><span class="line">    				&#125;else &#123;</span><br><span class="line">    					</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	String string = str.charAt(str.length()-1) + &quot;&quot;;</span><br><span class="line">    	if(numL.contains(string)) &#123;</span><br><span class="line">    		res += numL.indexOf(string)+1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>逻辑题</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口的中位数</title>
    <url>/2017/03/19/blog_article/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n 个整数的数组，和一个大小为 k 的滑动窗口,从左到右在数组中滑动这个窗口，找到数组中每个窗口内的最大值<br>样例<br>对于数组 [1,2,7,8,5], 滑动大小 k &#x3D; 3 的窗口时，返回 [2,7,7]<br>最初，窗口的数组是这样的：<br>[ | 1,2,7 | ,8,5] , 返回中位数 2;<br>接着，窗口继续向前滑动一次。<br>[1, | 2,7,8 | ,5], 返回中位数 7;<br>接着，窗口继续向前滑动一次。<br>[1,2, | 7,8,5 | ], 返回中位数 7;</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、构造一个大顶堆一个小顶堆<br>2、对前k个元素，将小于num[0]的元素放入大顶堆，大于num[0]的元素放入小顶堆<br>3、平衡小顶堆和大顶堆元素的数目后，得到中位数<br>4、从堆中删除nums[0]<br>5、每次根据后一个元素大小决定其放入的堆，平衡两个堆的数目后，得到中位数<br>6、删除旧元素后，回到第五步，直到访问完所有元素</p>
<blockquote>
<p>堆中增加元素lgn复杂度，遍历数组的复杂度为n，所以时间复杂度：nlgn</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;  </span><br><span class="line">    public class minComparator implements Comparator&lt;Integer&gt; &#123;  </span><br><span class="line">        public int compare(Integer a, Integer b)&#123;  </span><br><span class="line">            if(a &gt; b) return 1;  </span><br><span class="line">            else if(a == b) return 0;  </span><br><span class="line">            else return -1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public class maxComparator implements Comparator&lt;Integer&gt; &#123;  </span><br><span class="line">         public int compare(Integer a, Integer b)&#123;  </span><br><span class="line">            if(a &gt; b) return -1;  </span><br><span class="line">            else if(a == b) return 0;  </span><br><span class="line">            else return 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * @param nums: A list of integers. </span><br><span class="line">     * @return: The median of the element inside the window at each moving. </span><br><span class="line">     */  </span><br><span class="line">    public ArrayList&lt;Integer&gt; medianSlidingWindow(int[] nums, int k) &#123;  </span><br><span class="line">        // write your code here  </span><br><span class="line">    	ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    	// exception</span><br><span class="line">    	if(k == 1) &#123;</span><br><span class="line">    		Integer[] ints = new Integer[nums.length];</span><br><span class="line">    		for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    			ints[i] = nums[i];</span><br><span class="line">    		&#125;</span><br><span class="line">    		return new ArrayList&lt;Integer&gt;(Arrays.asList(ints));</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(k == 2) &#123;</span><br><span class="line">    		for(int i = 0; i &lt; nums.length-1; i++) &#123;</span><br><span class="line">    			res.add(Math.min(nums[i], nums[i+1]));</span><br><span class="line">    		&#125;</span><br><span class="line">    		return res;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	// init heap</span><br><span class="line">    	PriorityQueue&lt;Integer&gt; MaxHeap = new PriorityQueue&lt;&gt;(new maxComparator());</span><br><span class="line">    	PriorityQueue&lt;Integer&gt; MinHeap = new PriorityQueue&lt;&gt;(new minComparator());</span><br><span class="line">    	MaxHeap.add(nums[0]);</span><br><span class="line">    	for(int i = 1; i &lt; k; i++) &#123; </span><br><span class="line">    		if(nums[i] &gt; nums[0]) &#123;</span><br><span class="line">    			MinHeap.add(nums[i]);</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			MaxHeap.add(nums[i]);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(k % 2 == 1) &#123;</span><br><span class="line">    		if(MinHeap.size() &gt; MaxHeap.size()) &#123;</span><br><span class="line">    			while(( MinHeap.size()-MaxHeap.size() ) != 1) &#123;		</span><br><span class="line">        			MaxHeap.add(MinHeap.poll());</span><br><span class="line">       			&#125;</span><br><span class="line">       			res.add(MinHeap.peek());</span><br><span class="line">       			// 删除旧元素，并使得小堆和大堆平衡</span><br><span class="line">       			MaxHeap.add(MinHeap.poll());</span><br><span class="line">       			MaxHeap.remove(nums[0]);</span><br><span class="line">       		&#125;else &#123;</span><br><span class="line">        		while( ( MaxHeap.size()-MinHeap.size() ) != 1 ) &#123;</span><br><span class="line">        			MinHeap.add(MaxHeap.poll());</span><br><span class="line">       			&#125;</span><br><span class="line">        		res.add(MaxHeap.peek());</span><br><span class="line">        		// 删除旧元素，并使得小堆和大堆平衡</span><br><span class="line">        		MinHeap.add(MaxHeap.poll());</span><br><span class="line">        		MinHeap.remove(nums[0]);</span><br><span class="line">       		&#125;</span><br><span class="line">    	&#125;else &#123;</span><br><span class="line">    		if(MaxHeap.size() &gt; MinHeap.size()) &#123;</span><br><span class="line">    			while(MaxHeap.size() != MinHeap.size()) &#123;</span><br><span class="line">    				MinHeap.add(MaxHeap.poll());</span><br><span class="line">    			&#125;</span><br><span class="line">    			res.add(MaxHeap.peek());</span><br><span class="line">    			MinHeap.remove(nums[0]);</span><br><span class="line">    		&#125;else if(MaxHeap.size() &lt; MinHeap.size()) &#123;</span><br><span class="line">    			while( MaxHeap.size() != MinHeap.size() )&#123;</span><br><span class="line">    				MaxHeap.add(MinHeap.poll());</span><br><span class="line">    			&#125;</span><br><span class="line">    			res.add(MaxHeap.peek());</span><br><span class="line">    			MaxHeap.remove(nums[0]);</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			res.add(MaxHeap.peek());</span><br><span class="line">    			MaxHeap.remove(nums[0]);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	// 寻找第k个数字之后的中位数</span><br><span class="line">    	for(int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">    		// 新数入堆</span><br><span class="line">    		if(nums[i] &gt; MinHeap.peek()) &#123;</span><br><span class="line">    			MinHeap.add(nums[i]);</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			MaxHeap.add(nums[i]);</span><br><span class="line">    		&#125;</span><br><span class="line">    		// 分K为偶数奇数找到中位数</span><br><span class="line">    		if(k % 2 == 1) &#123;</span><br><span class="line">    			if(MinHeap.size() &gt; MaxHeap.size()) &#123;</span><br><span class="line">    				// 使大小堆数目平衡</span><br><span class="line">    				while(( MinHeap.size()-MaxHeap.size() ) != 1) &#123;		</span><br><span class="line">            			MaxHeap.add(MinHeap.poll());</span><br><span class="line">           			&#125;</span><br><span class="line">    				// 找到中位数</span><br><span class="line">           			res.add(MinHeap.peek());</span><br><span class="line">    			&#125;else &#123;</span><br><span class="line">    				// 使大小堆数目平衡</span><br><span class="line">    				while( ( MaxHeap.size()-MinHeap.size() ) != 1 ) &#123;</span><br><span class="line">            			MinHeap.add(MaxHeap.poll());</span><br><span class="line">           			&#125;</span><br><span class="line">    				// 找到中位数</span><br><span class="line">            		res.add(MaxHeap.peek());</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;else &#123;</span><br><span class="line">    			if(MaxHeap.size() &gt; MinHeap.size()) &#123;</span><br><span class="line">    				// 使大小堆数目平衡</span><br><span class="line">    				while(MaxHeap.size() != MinHeap.size()) &#123;</span><br><span class="line">        				MinHeap.add(MaxHeap.poll());</span><br><span class="line">        			&#125;</span><br><span class="line">    				// 找到中位数</span><br><span class="line">        			res.add(MaxHeap.peek());</span><br><span class="line">        		&#125;else if(MaxHeap.size() &lt; MinHeap.size()) &#123;</span><br><span class="line">        			// 使大小堆数目平衡</span><br><span class="line">        			while( MaxHeap.size() != MinHeap.size() )&#123;</span><br><span class="line">        				MaxHeap.add(MinHeap.poll());</span><br><span class="line">        			&#125;</span><br><span class="line">        			// 找到中位数</span><br><span class="line">        			res.add(MaxHeap.peek());</span><br><span class="line">        		&#125;else &#123;</span><br><span class="line">        			// 找到中位数</span><br><span class="line">        			res.add(MaxHeap.peek());</span><br><span class="line">        		&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    		// 丢掉最左边的数</span><br><span class="line">   			if(nums[i-k+1] &gt;= MinHeap.peek()) &#123;</span><br><span class="line">   				MinHeap.remove(nums[i-k+1]);</span><br><span class="line">   			&#125;else &#123;</span><br><span class="line">   				MaxHeap.remove(nums[i-k+1]);</span><br><span class="line">   			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return res;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">    	Solution solution = new Solution();</span><br><span class="line">    	ArrayList&lt;Integer&gt; list = solution.medianSlidingWindow(new int[]&#123;1,2,3,5,3,5,1,2,7,4,3,9,6&#125;, 1);</span><br><span class="line">    	for(int num : list) &#123;</span><br><span class="line">    		System.out.print(num);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>堆</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>生成括号</title>
    <url>/2017/03/31/blog_article/%E7%AE%97%E6%B3%95/%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。<br>例子：n &#x3D; 3，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((()))</span><br><span class="line">(()())</span><br><span class="line">(())()</span><br><span class="line">()(())</span><br><span class="line">()()()</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>递归。<br>一看这道题就是有通用的解决办法，又是让你输出所有结果，肯定用到递归。<br>例如n&#x3D;3，最容易想到<code>（（（）））</code>，之后呢？<br>对于最后一个左括号，如果可以将其改为右括号，就是另一种情况。<br>所以思路就有了：<br>1、优先递归输出左括号再输出右括号<br>2、递归返回时，判断输出最后一个左括号的调用能否输出右括号，能就输出右括号再向下递归<br>牵扯到判断，所以需要记录当前递归处的左右括号的个数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String s;</span><br><span class="line">    private ArrayList&lt;String&gt; res;</span><br><span class="line">    public ArrayList&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        res = new ArrayList&lt;String&gt;();</span><br><span class="line">        produce(n, n, res, &quot;&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private void produce(int left, int right, ArrayList&lt;String&gt;res, String tmp)&#123;</span><br><span class="line">        if(left == 0 &amp;&amp; right == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &gt; 0)&#123;</span><br><span class="line">            produce(left-1, right, res, tmp+&quot;(&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right &gt; 0 &amp;&amp; left &lt; right)&#123;</span><br><span class="line">            produce(left, right-1, res, tmp+&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>递归</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>第k大元素</title>
    <url>/2017/02/28/blog_article/%E7%AE%97%E6%B3%95/%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在数组中找到第k大的元素</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑快排的做法，每次对数组的第一个元素排序，排序后根据其位置将数组一分为二，再对左、右子数组重复之前的做法，其基本思想是分治。<br>为了找到第k大的元素，参考快排，我们对第一个元素排序后，对其进行判断，分三种情况：</p>
<ul>
<li>该元素就是第k大的，直接输出</li>
<li>该元素小于第k大的，对该元素的右子数组递归，终止条件即找到第k大</li>
<li>该元素大于第k大的，对该元素的左子数组递归 ，终止条件即找到第k大</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int kthLargestElement(int k, int[] nums) &#123;</span><br><span class="line">        return getK(nums, 0, nums.length-1, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int getK(int[] nums, int start, int end, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(start &gt;= end)    &#123;return nums[start];&#125;</span><br><span class="line">        int tar = nums[start];</span><br><span class="line">        int lo = start;</span><br><span class="line">        int i = start+1;</span><br><span class="line">        int j = end;</span><br><span class="line">        while(i &lt;= j)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[lo])&#123;</span><br><span class="line">                swap(nums, i, lo);</span><br><span class="line">                i++;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[i] == nums[lo]) &#123;i++;&#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k &lt; (lo+1))  &#123;</span><br><span class="line">            return getK(nums, start, lo-1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(k &gt; i)  &#123;</span><br><span class="line">            return getK(nums, i, end, k);</span><br><span class="line">        &#125;</span><br><span class="line">        else    return tar;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void swap(int[] nums, int i, int j)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>快排<ul>
<li>快排涉及到将第一个元素排序，保证左边小于等于，右边大于等于。注意数组可能有重复元素。所以其做法应该是：<br>  另lo指向待排序元素，i&#x3D;lo+1，j指向最后一个元素。<br>  排序过程中考虑三种情况：<ul>
<li>1、[i] &lt; [lo]，交换i-lo，i++，lo++<br>  排序前：lo i . . . . . . j<br>  排序后：. lo i . . . . . j</li>
<li>2、 [i] &#x3D; [lo] ，i++<br>  排序前：lo i . . . . . . j<br>  排序后：lo . i . . . . . j</li>
<li>3、 [i] &gt; [lo]，交换i-j，j–<br>  排序前：lo i . . . . . . j<br>  排序后：lo i . . . . . j .</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>统计数字</title>
    <url>/2017/02/28/blog_article/%E7%AE%97%E6%B3%95/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>计算数字k在0到n中的出现的次数，k可能是0~9的一个值</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对每一个0到n的数字i，将i转化为String，取String的每一个char，比较其值是否为k。<br>int转化为String： int + “”<br>取String字符的方法：charAt<br>char和int的比较是char和int数值对应的AscII码的比较</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int digitCounts(int k, int n) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            String str = i + &quot;&quot;;</span><br><span class="line">            for(int j = 0; j &lt; str.length(); j++) &#123;</span><br><span class="line">                if(str.charAt(j) == (48+k)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>int转化为字符串</li>
<li>charAt方法</li>
<li>char和int值的比较</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>翻转二叉树</title>
    <url>/2017/03/20/blog_article/%E7%AE%97%E6%B3%95/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>样例<br>  1               1<br> &#x2F; \             &#x2F; <br>2   3   &#x3D;&gt;  3   2<br>   &#x2F;              <br>  4                4</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分治法。<br>对于当前节点root，先翻转左右节点，再递归左节点，然后递归右节点</p>
<blockquote>
<p>必须先翻转再递归，即先当前节点，再左，再右的顺序。思考一下你就懂了！</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void invertBinaryTree(TreeNode root) &#123;</span><br><span class="line">       // write your code here</span><br><span class="line">       if(root == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode tmp = root.left;</span><br><span class="line">       root.left = root.right;</span><br><span class="line">       root.right = tmp;</span><br><span class="line">       invertBinaryTree(root.left);</span><br><span class="line">       invertBinaryTree(root.right); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>二叉树</li>
<li>分治法</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>翻转字符串</title>
    <url>/2017/03/08/blog_article/%E7%AE%97%E6%B3%95/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，逐个翻转字符串中的每个单词。例如“how are you”，输出“you are how”<br>说明：</p>
<ul>
<li>单词的构成：无空格字母构成一个单词</li>
<li>输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括</li>
<li>如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先需要把字符串前面的空格符去掉<br>然后遍历字符串，将遇到的每个单词add到一个字符串list里<br>最后倒序访问list，拼成字符串即可<br><br>唯一的难点：<br>如何判断已经读完了一个单词？<br>遇到空格就算读完了吗？那如果单词之间间隔了超过一个空格怎么办？</p>
<blockquote>
<p>考虑用一个boolean变量，表示是否读完了一个单词。初始化为false。<br>当读到第一个空格时，设为true，将读到的单词add到list。<br>继续向下遍历每个字符，如果为空格，仍为true，表示读完了一个单词。<br>当读到字符非空时，将变量值为false，表示又要开始读单词了。如此反复即可。</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private StringBuilder stringBuilder;</span><br><span class="line">private List&lt;String&gt; wordList;</span><br><span class="line">   public String reverseWords(String s) &#123;</span><br><span class="line">       wordList = new ArrayList&lt;&gt;();</span><br><span class="line">	s = delBlankFromBegin(s);</span><br><span class="line">	boolean aWordFinish = false;</span><br><span class="line">       stringBuilder = new StringBuilder();</span><br><span class="line">       for(int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">       	// 空格符的ASCII是32</span><br><span class="line">       	if(s.charAt(i) != &#x27; &#x27;) &#123;</span><br><span class="line">       		// 如果s最后一个字符不为空格，将最后一个单词添加到字符串中</span><br><span class="line">       		if(i == s.length()-1) &#123;</span><br><span class="line">       			addWord(s, i+1);</span><br><span class="line">       			break;</span><br><span class="line">       		&#125;</span><br><span class="line">       		</span><br><span class="line">       		if(aWordFinish == true) &#123;</span><br><span class="line">       			aWordFinish = false;</span><br><span class="line">       		&#125;</span><br><span class="line">       	&#125;else &#123;</span><br><span class="line">       		if(aWordFinish == true) &#123;</span><br><span class="line">       			continue;</span><br><span class="line">       		&#125;</span><br><span class="line">			addWord(s, i);</span><br><span class="line">			aWordFinish = true;</span><br><span class="line">		&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i = wordList.size()-1; i &gt;=0; i--) &#123;</span><br><span class="line">       	stringBuilder.append(wordList.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       return stringBuilder.toString();</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">private void addWord(String s, int i) &#123;</span><br><span class="line">	StringBuilder local = new StringBuilder();</span><br><span class="line">	int tmp = i-1;</span><br><span class="line">	while(tmp &gt;= 0  &amp;&amp; s.charAt(tmp) != &#x27; &#x27;) &#123;</span><br><span class="line">		tmp--;</span><br><span class="line">	&#125;</span><br><span class="line">	local.append(s.substring(tmp+1, i));</span><br><span class="line">	local.append(&quot; &quot;);</span><br><span class="line">	wordList.add(local.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String delBlankFromBegin(String s) &#123;</span><br><span class="line">	for(int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">		if(s.charAt(i) != &#x27; &#x27;) &#123;</span><br><span class="line">			s = s.substring(i, s.length());</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>字符串处理<br>void StringBuilder.append(String s)<br>String StringBuilder.toString()</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>股神</title>
    <url>/2017/04/11/blog_article/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>经过严密的计算，小赛买了一支股票，他知道从他买股票的那天开始，股票会有以下变化：第一天不变，以后涨一天，跌一天，涨两天，跌一天，涨三天，跌一天…依此类推。<br>为方便计算，假设每次涨和跌皆为1，股票初始单价也为1，请计算买股票的第n天每股股票值多少钱？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>数学推导</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Main main = new Main();</span><br><span class="line">		Scanner scanner =  new Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		main.res = new ArrayList&lt;&gt;();</span><br><span class="line">		while(scanner.hasNext()) &#123;</span><br><span class="line">			main.calculating(scanner.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		main.res.forEach(Object -&gt; System.out.println(Object));</span><br><span class="line">	&#125;</span><br><span class="line">	public ArrayList&lt;Integer&gt; res;</span><br><span class="line">	public void calculating(int n) &#123;</span><br><span class="line">		int x = (int)(Math.sqrt(2*n) - 1);</span><br><span class="line">		int j = x*(x+1) / 2;</span><br><span class="line">		int delta = n - j;</span><br><span class="line">		if(delta &gt; x+1) &#123;</span><br><span class="line">			delta = delta - x -1;</span><br><span class="line">			x = x+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(delta == x+1) &#123;</span><br><span class="line">			delta = delta - 2;</span><br><span class="line">		&#125;</span><br><span class="line">		int tmp;</span><br><span class="line">		if(x &gt;= 2) &#123;</span><br><span class="line">			tmp = 1+(x-1)*(x-2)/2;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			tmp = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		res.add(tmp+delta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>数学题</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2017/03/27/blog_article/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>动态规划。<br><code>动态规划与贪心的不同</code>：<br>DP每次取得的新元素，都会导致刷新一遍结果集。因此DP当前取得的结果集，并不是最优解，每次取得的新元素都会改变结果集。<br>贪心必须保证每次取得新元素，只对当前结果产生影响，不会更新过去的结果集。所以贪心必须保证当前得到的解就是最优解。<br><code>对于这道题</code>：<br>使用一个buf[m+1]的数组保存结果集。buf[i]表示背包重量为i时可以装入的最大重量。<br>每次访问一个元素A[i]，更新结果集buf：<br>buf[j] &#x3D; max（buf[ j-A[i] ]+A[i]，buf[j]）<br>虽然buf[j]在每次访问新元素A[i]时，都表示当前承重为j的背包可以装入的最大重量，但每次新元素到来时，buf数组的值都可能改变。所以是<code>动态</code>的！</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int backPack(int m, int[] A) &#123;</span><br><span class="line">        int n = A.length;  </span><br><span class="line">        int[] buf = new int[m+1];</span><br><span class="line">        for (int i = 0; i &lt; n; i++)   </span><br><span class="line">        &#123;  </span><br><span class="line">            for (int j = m; j &gt;= A[i]; j--)  </span><br><span class="line">                buf[j] = Math.max(buf[j], A[i]+buf[j-A[i]]);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return buf[m];  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>动态规划</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题II</title>
    <url>/2017/03/27/blog_article/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98II/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>动态规划。<br>依靠限定条件：大小为m的背包，创建结果集buf[m+1]<br>每次访问一个新元素A[i]，更新结果集buf[]<br>buf[j] &#x3D; Math.max(buf[j],buf[j-A[i]]+V[i])</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int backPackII(int m, int[] A, int V[]) &#123;</span><br><span class="line">        int[] buf = new int[m+1];</span><br><span class="line">        for(int i = 0; i &lt; A.length; i++)&#123;</span><br><span class="line">            for(int j = m; j &gt;= A[i]; j--)&#123;</span><br><span class="line">                buf[j] = Math.max(buf[j],buf[j-A[i]]+V[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return buf[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>动态规划</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>落单的数 I II III</title>
    <url>/2017/03/11/blog_article/%E7%AE%97%E6%B3%95/%E8%90%BD%E5%8D%95%E7%9A%84%E6%95%B0I%20II%20III/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>落单的数I<br>给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p>
<p>落单的数II<br>给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。</p>
<p>落单的数III<br>给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>落单的数系列题目因为是找落单的数，可以使用亦或。因为两个相同的数，亦或的结果为0<br>所以落单的数I 很容易就解决了<br><br>还可以把数组元素加入到hashmap，元素值作为key，元素出现的个数作为value，当value &#x3D;&#x3D; 2时remove，最后遍历keyset把key输出即可<br>所以落单的数I II 很容易就解决了<br><br>落单的数III稍微复杂一点：</p>
<ul>
<li>亦或一遍，可以找到两个落单的数的亦或值</li>
<li>找到这个值的二进制中第一个不为0的数的所在位，将该位为0的所有元素亦或一遍，该位所有为1的元素亦或一遍，就可以找到这两个落单的数</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int singleNumber(int[] A) &#123;</span><br><span class="line">        if(A.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = A[0];</span><br><span class="line">        for(int i = 1; i &lt; A.length; i++) &#123;</span><br><span class="line">            n = n ^ A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int singleNumberII(int[] A) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">            if(map.containsKey(A[i])) &#123;</span><br><span class="line">            	map.put(A[i], map.get(A[i])+1);</span><br><span class="line">            	if(map.get(A[i]) == 3) &#123;</span><br><span class="line">            		map.remove(A[i]);</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">            	map.put(A[i], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(Integer key : map.keySet()) &#123;</span><br><span class="line">        	res = key;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Integer&gt; singleNumberIII(int[] A) &#123;</span><br><span class="line">        int res1 = A[0];   // 保存一遍亦或的结果</span><br><span class="line">        for(int i = 1; i &lt; A.length; i++) &#123;</span><br><span class="line">            res1 ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 找到亦或的二进制数第一个不为0的数</span><br><span class="line">        int j = 1;  // 第i位为1的值</span><br><span class="line">        while((res1 &amp; j) == 0) &#123;</span><br><span class="line">            j *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int res2 = 0;   // 落单的数</span><br><span class="line">        int res3 = 0;   // 落单的数</span><br><span class="line">        for(int num : A) &#123;</span><br><span class="line">            if((num &amp; j) == 0) &#123;</span><br><span class="line">                res2 ^= num;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                res3 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(res2);</span><br><span class="line">        list.add(res3);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>位操作</li>
<li>HashMap</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>通过考试</title>
    <url>/2017/04/09/blog_article/%E7%AE%97%E6%B3%95/%E9%80%9A%E8%BF%87%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小明同学要参加一场考试，考试一共有n道题目，小明必须做对至少60%的题目才能通过考试。考试结束后，小明估算出每题做对的概率，p1,p2,…,pn。你能帮他算出他通过考试的概率吗？<br>输入<br>输入第一行一个数n（1&lt;&#x3D;n&lt;&#x3D;100），表示题目的个数。第二行n个整数，p1,p2,…,pn。表示小明有pi%的概率做对第i题。（0&lt;&#x3D;pi&lt;&#x3D;100）<br>输出<br>小明通过考试的概率，最后结果四舍五入，保留小数点后五位。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二维数组DP。<br>对每一道题存在做对和做错两种情况，对于第i道题做对j道的概率为：<br><code>前i-1道做对j-1道且第i道做对的概率</code> + <code>前i-1道做对j道且第i道做错的概率</code></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner in = new Scanner(System.in);</span><br><span class="line">		int n = in.nextInt();</span><br><span class="line">		double[] p = new double[n];</span><br><span class="line">		for (int i = 0; i &lt; n; i++) p[i] = (double)in.nextInt() / 100;</span><br><span class="line">		double[][] dp = new double[n + 1][n + 1];</span><br><span class="line">		dp[0][0] = 1;</span><br><span class="line">		for (int i = 1; i &lt; n + 1; i++) &#123;</span><br><span class="line">			dp[i][0] = dp[i - 1][0] * (1 - p[i - 1]);</span><br><span class="line">			for (int j = 1; j &lt; n + 1; j++)&#123;</span><br><span class="line">				dp[i][j] = dp[i - 1][j - 1] * p[i - 1] + dp[i - 1][j] * (1 - p[i - 1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		double result = 0;</span><br><span class="line">		for (int i = (3 * n + 4) / 5; i &lt;= n; i++) &#123;</span><br><span class="line">			result += dp[n][i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(String.format(&quot;%.5f&quot;, result));</span><br><span class="line">		in.close();</span><br></pre></td></tr></table></figure>

<h1 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h1><ul>
<li>DP</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>链表求和</title>
    <url>/2017/03/07/blog_article/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。<br>例子：给出两个链表 3-&gt;1-&gt;5-&gt;null 和 5-&gt;9-&gt;2-&gt;null，返回 8-&gt;0-&gt;8-&gt;null</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据给出的链表头，以此向下访问链表中的每个节点，取出节点的val相加后创建新链表的节点，加入到新的链表里即可。<br>进位问题，考虑用一个list，如果val相加产生进位，则list加入1，否则加入0。每次val相加时读取list的最后一位即可。<br>思路很简单，但在链表操作的时候要小心！</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	private ArrayList&lt;Integer&gt; aList;</span><br><span class="line">	private ListNode ret;</span><br><span class="line">	</span><br><span class="line">	public ListNode addLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">		if(l1 == null) &#123;</span><br><span class="line">        	return l2;</span><br><span class="line">        &#125;else if(l2 == null)&#123;</span><br><span class="line">			return l1;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			aList = new ArrayList&lt;&gt;();</span><br><span class="line">			ListNode res = new ListNode((l1.val + l2.val) % 10);</span><br><span class="line">			ret = res;</span><br><span class="line">			if((l1.val + l2.val) &gt; 9) &#123;</span><br><span class="line">				aList.add(1);</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				aList.add(0);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			l1 = l1.next;</span><br><span class="line">			l2 = l2.next;</span><br><span class="line">			</span><br><span class="line">			while(l1 != null &amp;&amp; l2 != null) &#123;</span><br><span class="line">				int val = l1.val + l2.val + aList.get(aList.size()-1);</span><br><span class="line">				res.next = new ListNode(val % 10);</span><br><span class="line">				res = res.next;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">				if(val &gt; 9) &#123;</span><br><span class="line">					aList.add(1);</span><br><span class="line">	            &#125;else &#123;</span><br><span class="line">					aList.add(0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 收尾</span><br><span class="line">			if(!(l1 == null)) &#123;</span><br><span class="line">				continueAdd(l1, aList, res);</span><br><span class="line">			&#125; else if (!(l2 == null)) &#123;</span><br><span class="line">				continueAdd(l2, aList, res);</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				if(aList.get(aList.size()-1) == 1) &#123;</span><br><span class="line">					res.next = new ListNode(1);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return ret;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	private void continueAdd(ListNode listNode, ArrayList&lt;Integer&gt; list, ListNode res) &#123;</span><br><span class="line">		while(listNode != null) &#123;</span><br><span class="line">			int val = listNode.val + aList.get(aList.size()-1);</span><br><span class="line">			if(val &gt; 9) &#123;</span><br><span class="line">				aList.add(1);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">				aList.add(0);</span><br><span class="line">			&#125;</span><br><span class="line">			res.next = new ListNode(val % 10);</span><br><span class="line">			res = res.next;</span><br><span class="line">			listNode = listNode.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public ListNode initList(int[] num) &#123;</span><br><span class="line">		ListNode head = new ListNode(num[0]);</span><br><span class="line">		ListNode ret = head;</span><br><span class="line">		for(int i = 1; i &lt; num.length; i++) &#123;</span><br><span class="line">			head.next = new ListNode(num[i]);</span><br><span class="line">			head = head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>链表操作</li>
</ul>
<p>不得不说，链表操作其实涉及到不少知识。<br>此算法中，我尝试按照给定的int[]数组构造链表，返回链表头。<br>首先，取出int[0]构造头部节点，之后创建next节点，直到读完所有数组。注意，这时不能让head对象立刻指向其next，因为这时head.next为null，一旦这么做了，那么头部节点将永远是null！正确的做法是，先new head.next，再让head &#x3D; head.next<br>在java中，当使用 <code>a = b</code> （a、b均为JAVA对象）时，一定要慎重！<br>首先，你要保证，b对象已经new了！不然如果b&#x3D;null，那么a&#x3D;null，且不可逆（就算之后new了b）！为什么呢？</p>
<blockquote>
<p><code>a = b</code>的过程是：让a对象的栈指向b对象的堆！栈用来保存存储对象数据的堆地址。</p>
</blockquote>
<p>下面假设几种情况：<br><code>b = c</code>：如果在a的栈指向b的堆之前new过b了，那么b&#x3D;c不会影响a，只是b的栈会指向c的堆，此时b和c共享c的堆，而a独享b的堆。所以一旦让对象a指向对象b，那么对象a将会一直盯着b的堆，只有b的堆中的数据改变了才会影响a。<br><code>a = b之前并未new b</code>：这样会使得a并未真正指向一个堆，即a&#x3D;null。就算之后new b，也只是b的栈指向了自己的堆（内存分配一块区域保存b对象的数据），但a的栈还是没有指向堆，a仍为null。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>链表重排序</title>
    <url>/2017/04/18/blog_article/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定单向链表 LO-L1-L2… … -L(N-1)-LN<br>重排序后的链表为：LO-LN-L1-L(N-1)-L2-L(N-2)… …<br>要求时间复杂度O(n)，且只能改变next指针，不能增加额外的节点</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>遍历一遍，找到链表长度后，求出中间节点的index，同时用引用tail指向尾节点<br>再从头节点开始找到中间节点，从中间节点开始将链表反转<br>最后不断改变head和tail的next，以及head和tail的引用，即可完成链表的重排序</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	static class Node &#123;</span><br><span class="line">		public Node next;</span><br><span class="line">		public int num;</span><br><span class="line">		public Node(int num) &#123;</span><br><span class="line">			this.num = num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    	Node n1 = new Node(1);</span><br><span class="line">    	Node n2 = new Node(2);</span><br><span class="line">    	Node n3 = new Node(3);</span><br><span class="line">    	Node n4 = new Node(4);</span><br><span class="line">    	Node n5 = new Node(5);</span><br><span class="line">    	Node n6 = new Node(6);</span><br><span class="line">    	n1.next = n2;</span><br><span class="line">    	n2.next = n3;</span><br><span class="line">    	n3.next = n4;</span><br><span class="line">    	n4.next = n5;</span><br><span class="line">    	n5.next = n6;</span><br><span class="line">    	new Main().reverse(n1);</span><br><span class="line">    	while(n1 != null) &#123;</span><br><span class="line">    		System.out.println(n1.num);</span><br><span class="line">    		n1 = n1.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void reverse(Node head) &#123;</span><br><span class="line">    	 // 获取链表长度</span><br><span class="line">    	int length = 0;</span><br><span class="line">    	Node header = head;</span><br><span class="line">    	while(header.next != null) &#123;</span><br><span class="line">    		length++;</span><br><span class="line">    		header = header.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	Node tail = header;</span><br><span class="line">    	</span><br><span class="line">    	// 以中间节点作为头节点，反转链表</span><br><span class="line">    	int mid = (length+1)/2;</span><br><span class="line">    	int count = 0;</span><br><span class="line">    	Node start = head;</span><br><span class="line">    	while(count &lt; mid) &#123;</span><br><span class="line">    		count++;</span><br><span class="line">    		start = start.next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	// 从mid节点开始将链表反转</span><br><span class="line">    	Node cur = start.next;</span><br><span class="line">    	Node pre = start;</span><br><span class="line">    	while(cur != null) &#123;</span><br><span class="line">    		Node tmp = cur.next;</span><br><span class="line">    		cur.next = pre;</span><br><span class="line">    		pre = cur;</span><br><span class="line">    		cur = tmp;</span><br><span class="line">    		</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	// 重排链表</span><br><span class="line">    	while(head != tail &amp;&amp; head.next != tail) &#123;</span><br><span class="line">    		Node nextHead = head.next;</span><br><span class="line">    		Node nextTail = tail.next;</span><br><span class="line">    		head.next = tail;</span><br><span class="line">    		tail.next = nextHead;</span><br><span class="line">    		head = nextHead;</span><br><span class="line">    		tail = nextTail;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(head == tail) &#123;</span><br><span class="line">    		tail.next = null;</span><br><span class="line">    	&#125;else &#123;</span><br><span class="line">    		head.next = tail;</span><br><span class="line">    		tail.next = null;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="考差点"><a href="#考差点" class="headerlink" title="考差点"></a>考差点</h1><ul>
<li>链表</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title>小炒猪肝</title>
    <url>/2021/01/16/blog_article/%E7%94%9F%E6%B4%BB/%E5%8E%A8%E8%89%BA/%E5%B0%8F%E7%82%92%E7%8C%AA%E8%82%9D/</url>
    <content><![CDATA[<ul>
<li>简单清洗猪肝</li>
<li>猪肝切薄方片</li>
<li>码味腌制<ul>
<li>盐、胡椒粉、生抽、老抽、耗油、玉米淀粉、料酒、油</li>
</ul>
</li>
<li>锅干烧冒烟后放油，油量不完全没过猪肝最佳</li>
<li>待油冒烟后快速下入猪肝划散</li>
<li>加入料酒去腥</li>
<li>加入切好的红椒（菱形片）、蒜片</li>
<li>加入生抽调味</li>
<li>加入切好的香葱（半指长的小断）</li>
<li>加入盐、糖、鸡精，快速翻炒后出锅装盘</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>糖醋排骨</title>
    <url>/2021/01/17/blog_article/%E7%94%9F%E6%B4%BB/%E5%8E%A8%E8%89%BA/%E7%B3%96%E9%86%8B%E6%8E%92%E9%AA%A8/</url>
    <content><![CDATA[<ul>
<li>流水冲洗排骨的血水</li>
<li>腌制去腥，加盐、姜片、料酒</li>
<li>烧水，加葱、姜。水热后加料酒、花椒粒。水快开时下入排骨汆水，水开捞出</li>
<li>锅中下油，五成油温（150度）下入排骨煸炒出水汽，再加入蒜粒、料酒去腥</li>
<li>加入一把白糖，炒至糖融化挂在排骨上</li>
<li>加一点老抽上色</li>
<li>加香醋提味，炒至糖醋味充分融合</li>
<li>锅中加开水没过排骨即可</li>
<li>中小火煮15分钟，想肉质更软烂可以煮20分钟</li>
<li>水剩1&#x2F;3时，复加白糖</li>
<li>水快靠干时，复加少许白醋，大火收汁</li>
<li>出锅前撒少许香油、熟芝麻，即可起锅装盘</li>
</ul>
<p>要点：</p>
<ul>
<li>煸炒排骨要控制火候，油温不够会让排骨发柴</li>
<li>因为没有炒糖色，所以切记加老抽上色，否则菜品颜色不够</li>
<li>加香醋能提味，还能使肉质更软烂</li>
<li>起锅前复加白糖、香醋</li>
<li>熟芝麻、香油能增色增香</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>辣椒炒肉</title>
    <url>/2021/03/07/blog_article/%E7%94%9F%E6%B4%BB/%E5%8E%A8%E8%89%BA/%E8%BE%A3%E6%A4%92%E7%82%92%E8%82%89/</url>
    <content><![CDATA[<p>原料：</p>
<ul>
<li>猪前腿</li>
<li>螺丝椒</li>
<li>干辣椒</li>
<li>剁辣椒</li>
</ul>
<p>调料:</p>
<ul>
<li><p>盐、鸡精、白糖</p>
</li>
<li><p>味极鲜</p>
</li>
<li><p>豆豉</p>
</li>
<li><p>猪前腿肥瘦分离，切薄片</p>
</li>
<li><p>瘦肉码味：加盐、味极鲜</p>
</li>
<li><p>螺丝椒切滚刀块，下锅中小火煎至虎皮状，盛出备用</p>
</li>
<li><p>锅下底油，放入肥肉中小火煸炒至吐油，大概需要2分钟</p>
</li>
<li><p>加入干辣椒、豆豉，炒出香味</p>
</li>
<li><p>加入剁辣椒炒出香味</p>
</li>
<li><p>加入瘦肉，大火快速煸炒，大概需要3分钟，中途加入螺丝椒</p>
</li>
<li><p>加入少许盐、鸡精、白糖，炒匀后起锅装盘</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
