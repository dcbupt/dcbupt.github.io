<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.cat.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dcbupt.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="系统学习rocketmq源码">
<meta property="og:type" content="article">
<meta property="og:title" content="系统学习rocketmq源码">
<meta property="og:url" content="http://dcbupt.github.io/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="dcddc">
<meta property="og:description" content="系统学习rocketmq源码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://dcbupt.github.io/mq/rocketmq%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="http://dcbupt.github.io/images/mqFlush.png">
<meta property="article:published_time" content="2020-05-26T06:55:00.000Z">
<meta property="article:modified_time" content="2023-06-10T12:43:15.057Z">
<meta property="article:author" content="西米大人">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://dcbupt.github.io/mq/rocketmq%E6%9E%B6%E6%9E%84.png">

<link rel="canonical" href="http://dcbupt.github.io/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
  <title>系统学习rocketmq源码 | dcddc</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dcddc</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">西米大人的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dcbupt.github.io/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.png">
      <meta itemprop="name" content="西米大人">
      <meta itemprop="description" content="<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dcddc">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          系统学习rocketmq源码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 14:55:00" itemprop="dateCreated datePublished" datetime="2020-05-26T14:55:00+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 20:43:15" itemprop="dateModified" datetime="2023-06-10T20:43:15+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">系统学习系列</span></a>
                </span>
            </span>

          
            <span id="/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/" class="post-meta-item leancloud_visitors" data-flag-title="系统学习rocketmq源码" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度:</span>
              <span class="leancloud-visitors-count"></span>℃
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论:</span>
    
    <a title="valine" href="/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/" itemprop="commentCount"></span>℃
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>
            <div class="post-description"><blockquote class="blockquote-center">系统学习rocketmq源码</blockquote></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><p><img src="/mq/rocketmq%E6%9E%B6%E6%9E%84.png"></p>
<h1 id="客户端注册-rocketmq-组件"><a href="#客户端注册-rocketmq-组件" class="headerlink" title="客户端注册 rocketmq 组件"></a>客户端注册 rocketmq 组件</h1><p>如果是 sb 应用，rocketmq 提供 starter 方式自动装配 bean，需要引入依赖：rocketmq-spring-boot<br>spring.factories 文件里指定配置类<code>RocketMQAutoConfiguration</code>，由它注册 producer 和 consumer bean 到 bf</p>
<h2 id="注册-producer"><a href="#注册-producer" class="headerlink" title="注册 producer"></a>注册 producer</h2><ul>
<li>通过<code>@EnableConfigurationProperties(RocketMQProperties.class)</code>注册应用配置绑定 bean：<code>RocketMQProperties</code>，该 bean 包含了应用配置文件里对 rocketmq 的配置信息，producer 和 consumer 在创建过程中都通过该 bean 拿到并注入这些全局配置参数<ul>
<li>应用配置里 rocketmq 必备的配置项是 name-server(ns 地址)</li>
<li>如果指定了 producer.group 会创建 producer 实例</li>
<li>如果指定了 pull-consumer.group 和 pull-consumer.topic，会创建 consumer 实例</li>
</ul>
</li>
<li>producer 实例类型是<code>DefaultMQProducer</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Bean(PRODUCER_BEAN_NAME)</span><br><span class="line">@ConditionalOnMissingBean(DefaultMQProducer.class)</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;</span><br><span class="line">    &quot;name-server&quot;,</span><br><span class="line">    &quot;producer.group&quot;</span><br><span class="line">&#125;) public DefaultMQProducer defaultMQProducer(RocketMQProperties rocketMQProperties) &#123;</span><br><span class="line">    RocketMQProperties.Producer producerConfig = rocketMQProperties.getProducer();</span><br><span class="line">    String nameServer = rocketMQProperties.getNameServer();</span><br><span class="line">    String groupName = producerConfig.getGroup();</span><br><span class="line">    Assert.hasText(nameServer, &quot;[rocketmq.name-server] must not be null&quot;);</span><br><span class="line">    Assert.hasText(groupName, &quot;[rocketmq.producer.group] must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    String accessChannel = rocketMQProperties.getAccessChannel();</span><br><span class="line"></span><br><span class="line">    String ak = rocketMQProperties.getProducer().getAccessKey();</span><br><span class="line">    String sk = rocketMQProperties.getProducer().getSecretKey();</span><br><span class="line">    boolean isEnableMsgTrace = rocketMQProperties.getProducer().isEnableMsgTrace();</span><br><span class="line">    String customizedTraceTopic = rocketMQProperties.getProducer().getCustomizedTraceTopic();</span><br><span class="line"></span><br><span class="line">    DefaultMQProducer producer = RocketMQUtil.createDefaultMQProducer(groupName, ak, sk, isEnableMsgTrace, customizedTraceTopic);</span><br><span class="line"></span><br><span class="line">    producer.setNamesrvAddr(nameServer);</span><br><span class="line">    if (!StringUtils.isEmpty(accessChannel)) &#123;</span><br><span class="line">        producer.setAccessChannel(AccessChannel.valueOf(accessChannel));</span><br><span class="line">    &#125;</span><br><span class="line">    producer.setSendMsgTimeout(producerConfig.getSendMessageTimeout());</span><br><span class="line">    producer.setRetryTimesWhenSendFailed(producerConfig.getRetryTimesWhenSendFailed());</span><br><span class="line">    producer.setRetryTimesWhenSendAsyncFailed(producerConfig.getRetryTimesWhenSendAsyncFailed());</span><br><span class="line">    producer.setMaxMessageSize(producerConfig.getMaxMessageSize());</span><br><span class="line">    producer.setCompressMsgBodyOverHowmuch(producerConfig.getCompressMessageBodyThreshold());</span><br><span class="line">    producer.setRetryAnotherBrokerWhenNotStoreOK(producerConfig.isRetryNextServer());</span><br><span class="line">    producer.setUseTLS(producerConfig.isTlsEnable());</span><br><span class="line">    producer.setNamespace(producerConfig.getNamespace());</span><br><span class="line">    producer.setInstanceName(producerConfig.getInstanceName());</span><br><span class="line">    log.info(String.format(&quot;a producer (%s) init on namesrv %s&quot;, groupName, nameServer));</span><br><span class="line">    return producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册-consumer"><a href="#注册-consumer" class="headerlink" title="注册 consumer"></a>注册 consumer</h2><ul>
<li>consumer 实例类型是<code>DefaultLitePullConsumer</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Bean(CONSUMER_BEAN_NAME)@ConditionalOnMissingBean(DefaultLitePullConsumer.class)@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;</span><br><span class="line">    &quot;name-server&quot;,</span><br><span class="line">    &quot;pull-consumer.group&quot;,</span><br><span class="line">    &quot;pull-consumer.topic&quot;</span><br><span class="line">&#125;) public DefaultLitePullConsumer defaultLitePullConsumer(RocketMQProperties rocketMQProperties) throws MQClientException &#123;</span><br><span class="line">    RocketMQProperties.PullConsumer consumerConfig = rocketMQProperties.getPullConsumer();</span><br><span class="line">    String nameServer = rocketMQProperties.getNameServer();</span><br><span class="line">    String groupName = consumerConfig.getGroup();</span><br><span class="line">    String topicName = consumerConfig.getTopic();</span><br><span class="line">    Assert.hasText(nameServer, &quot;[rocketmq.name-server] must not be null&quot;);</span><br><span class="line">    Assert.hasText(groupName, &quot;[rocketmq.pull-consumer.group] must not be null&quot;);</span><br><span class="line">    Assert.hasText(topicName, &quot;[rocketmq.pull-consumer.topic] must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    String accessChannel = rocketMQProperties.getAccessChannel();</span><br><span class="line">    MessageModel messageModel = MessageModel.valueOf(consumerConfig.getMessageModel());</span><br><span class="line">    SelectorType selectorType = SelectorType.valueOf(consumerConfig.getSelectorType());</span><br><span class="line">    String selectorExpression = consumerConfig.getSelectorExpression();</span><br><span class="line">    String ak = consumerConfig.getAccessKey();</span><br><span class="line">    String sk = consumerConfig.getSecretKey();</span><br><span class="line">    int pullBatchSize = consumerConfig.getPullBatchSize();</span><br><span class="line">    boolean useTLS = consumerConfig.isTlsEnable();</span><br><span class="line"></span><br><span class="line">    DefaultLitePullConsumer litePullConsumer = RocketMQUtil.createDefaultLitePullConsumer(nameServer, accessChannel, groupName, topicName, messageModel, selectorType, selectorExpression, ak, sk, pullBatchSize, useTLS);</span><br><span class="line">    litePullConsumer.setEnableMsgTrace(consumerConfig.isEnableMsgTrace());</span><br><span class="line">    litePullConsumer.setCustomizedTraceTopic(consumerConfig.getCustomizedTraceTopic());</span><br><span class="line">    litePullConsumer.setNamespace(consumerConfig.getNamespace());</span><br><span class="line">    litePullConsumer.setInstanceName(consumerConfig.getInstanceName());</span><br><span class="line">    log.info(String.format(&quot;a pull consumer(%s sub %s) init on namesrv %s&quot;, groupName, topicName, nameServer));</span><br><span class="line">    return litePullConsumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册-RocketMQTemplate"><a href="#注册-RocketMQTemplate" class="headerlink" title="注册 RocketMQTemplate"></a>注册 RocketMQTemplate</h2><p>客户端不直接持有 producer 和 consumer，而是通过 RocketMQTemplate，该 bean 注册时从 bf 拿到 producer 和 consumer 实例并注入，然后在初始化阶段调用它们的 start 方法，启动 producer 和 consumer 实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean(destroyMethod = &quot;destroy&quot;)</span><br><span class="line">@Conditional(ProducerOrConsumerPropertyCondition.class)</span><br><span class="line">@ConditionalOnMissingBean(name = ROCKETMQ_TEMPLATE_DEFAULT_GLOBAL_NAME)</span><br><span class="line">public RocketMQTemplate rocketMQTemplate(RocketMQMessageConverter rocketMQMessageConverter) &#123;</span><br><span class="line">    RocketMQTemplate rocketMQTemplate = new RocketMQTemplate();</span><br><span class="line">    if (applicationContext.containsBean(PRODUCER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setProducer((DefaultMQProducer) applicationContext.getBean(PRODUCER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    if (applicationContext.containsBean(CONSUMER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setConsumer((DefaultLitePullConsumer) applicationContext.getBean(CONSUMER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    rocketMQTemplate.setMessageConverter(rocketMQMessageConverter.getMessageConverter());</span><br><span class="line">    return rocketMQTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    if (producer != null) &#123;</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    if (Objects.nonNull(consumer)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;Failed to startup PullConsumer for RocketMQTemplate&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动-producer-实例"><a href="#启动-producer-实例" class="headerlink" title="启动 producer 实例"></a>启动 producer 实例</h1><p>入口：org.apache.rocketmq.client.producer.DefaultMQProducer#start</p>
<p>调用 start 方法前，已经完成了 DefaultMQProducer 的实例化，在构造函数里设置一些默认的发送者配置信息，同时 new 了一个内部发送者实例<code>DefaultMQProducerImpl</code>，它们互相持有彼此的引用。配置信息包括：</p>
<ul>
<li>发送消息超时时间（默认 3 秒）</li>
<li>需要压缩的消息大小阈值（默认 4K）</li>
<li>发送消息失败后的重试次数（默认 2 次，不过这可能造成 consumer 收到重复消息）</li>
<li>发送消息的最大字节数（默认 4M）</li>
<li>producerGroupName，作为构造参数传入</li>
<li>mq 客户端信息，例如实例名、客户端 ip、ns 地址等<ul>
<li>定义在 <code>ClientConfig</code>，DefaultMQProducer 继承该类</li>
</ul>
</li>
</ul>
<p>需要注意，通过上面注册阶段的分析可知，发送者配置信息可以被应用配置文件里的配置覆盖。<br>不过应用配置里一般是定义一些 producer 和 consumer 个性化参数，对于一些敏感信息，例如实例名、客户端 ip、ns 地址等，我们一般沿用 ClientConfig 的实现而不在应用配置文件里指定。<br>ClientConfig 设置实例名和 ns 地址都通过系统属性获取，我们可以在应用启动脚本里设置这些系统属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public DefaultMQProducer(String namespace, String producerGroup, RPCHook rpcHook) &#123;</span><br><span class="line">    this.log = ClientLogger.getLog();</span><br><span class="line">    this.retryResponseCodes = new CopyOnWriteArraySet(Arrays.asList(17, 14, 1, 16, 204, 205));</span><br><span class="line">    this.createTopicKey = &quot;TBW102&quot;;</span><br><span class="line">    this.defaultTopicQueueNums = 4;</span><br><span class="line">    this.sendMsgTimeout = 3000;</span><br><span class="line">    this.compressMsgBodyOverHowmuch = 4096;</span><br><span class="line">    this.retryTimesWhenSendFailed = 2;</span><br><span class="line">    this.retryTimesWhenSendAsyncFailed = 2;</span><br><span class="line">    this.retryAnotherBrokerWhenNotStoreOK = false;</span><br><span class="line">    this.maxMessageSize = 4194304;</span><br><span class="line">    this.traceDispatcher = null;</span><br><span class="line">    this.namespace = namespace;</span><br><span class="line">    this.producerGroup = producerGroup;</span><br><span class="line">    this.defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultMQProducer 的 start 方法又会调用内部发送者 DefaultMQProducerImpl 的 start 方法，即 <code>producer 的启动流程实际是启动 DefaultMQProducerImpl</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void start() throws MQClientException &#123;</span><br><span class="line">    ...</span><br><span class="line">    this.defaultMQProducerImpl.start();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面具体看 DefaultMQProducerImpl 的 start 流程</p>
<h2 id="处理-mqClient-实例名"><a href="#处理-mqClient-实例名" class="headerlink" title="处理 mqClient 实例名"></a>处理 mqClient 实例名</h2><p>ClientConfig 设置了全局的实例名，默认取系统环境变量，缺省值 DEFAULT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;);</span><br></pre></td></tr></table></figure>

<p>sb 应用的配置文件里也可以指定 producer 所属 client 的实例名，该优先级更高。如果没指定，缺省也是 DEFAULT。<br>如果实例名为 DEFAULT，这里会修改实例名，改成：”{进程 pid}#{时间戳}” 这种格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void changeInstanceNameToPID() &#123;</span><br><span class="line">    if (this.instanceName.equals(&quot;DEFAULT&quot;)) &#123;</span><br><span class="line">        this.instanceName = UtilAll.getPid() + &quot;#&quot; + System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化-mqClient"><a href="#实例化-mqClient" class="headerlink" title="实例化 mqClient"></a>实例化 mqClient</h2><p><code>MQClientInstance</code>表示 mqClient 实例。<code>MQClientManager</code>是<code>MQClientInstance</code>的工厂，缓存已创建的<code>MQClientInstance</code>，Key 为{ip}#{mqClient 的实例名}，如果没有在环境变量或应用配置里指定 mqClient 实例名，则这里的 key 为：{ip}#{进程 pid}#{时间戳}。注意这时带了时间戳参数，因此有如下结论：</p>
<ul>
<li>如果没有指定 mq 客户端名，每个 producer 实例在启动时都会新建一个 mqClient</li>
<li>如果系统配置里指定了 mq 客户端名，所有 producer 共用一个 mqClient</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// mQClientFactory的类型就是MQClientInstance</span><br><span class="line">this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) &#123;</span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    MQClientInstance instance = this.factoryTable.get(clientId);</span><br><span class="line">    if (null == instance) &#123;</span><br><span class="line">        instance = new MQClientInstance(clientConfig.cloneClientConfig(), this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="producer-注册到-mqClient"><a href="#producer-注册到-mqClient" class="headerlink" title="producer 注册到 mqClient"></a>producer 注册到 mqClient</h2><p><code>DefaultMQProducerImpl</code>注册到<code>MQClientInstance</code></p>
<ul>
<li>mqClient 按 group 维度管理 producer、consumer 实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean registerProducer(String group, DefaultMQProducerImpl producer) &#123;</span><br><span class="line">    if (null != group &amp;&amp; null != producer) &#123;</span><br><span class="line">        MQProducerInner prev = (MQProducerInner) this.producerTable.putIfAbsent(group, producer);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            this.log.warn(&quot;the producer group[&#123;&#125;] exist already.&quot;, group);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动-MQClientInstance"><a href="#启动-MQClientInstance" class="headerlink" title="启动 MQClientInstance"></a>启动 MQClientInstance</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.mQClientFactory.start();</span><br></pre></td></tr></table></figure>

<h3 id="更新-ns-地址"><a href="#更新-ns-地址" class="headerlink" title="更新 ns 地址"></a>更新 ns 地址</h3><p>获取 nameserver 服务器地址（url+端口号）。ns 地址的获取优先级是：</p>
<ul>
<li>优先使用应用配置文件里指定的 ns 地址。在 bean 加载阶段会覆盖 ClientConfig 里 ns 的默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean(PRODUCER_BEAN_NAME)@ConditionalOnMissingBean(DefaultMQProducer.class)@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;</span><br><span class="line">    &quot;name-server&quot;,</span><br><span class="line">    &quot;producer.group&quot;</span><br><span class="line">&#125;) public DefaultMQProducer defaultMQProducer(RocketMQProperties rocketMQProperties) &#123;</span><br><span class="line">    RocketMQProperties.Producer producerConfig = rocketMQProperties.getProducer();</span><br><span class="line">    String nameServer = rocketMQProperties.getNameServer();</span><br><span class="line">    ...</span><br><span class="line">    producer.setNamesrvAddr(nameServer);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其次使用 ClientConfig 的 ns 默认值。它取了系统环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String namesrvAddr = NameServerAddressUtils.getNameServerAddresses();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String getNameServerAddresses() &#123;</span><br><span class="line">    return System.getProperty(&quot;rocketmq.namesrv.addr&quot;, System.getenv(&quot;NAMESRV_ADDR&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果前面都没拿到 ns 地址，向 ns 源服务器地址（也在系统环境变量配置，有缺省值）发起 http 请求，获取 ns 服务器地址<ul>
<li>rocketmq 提供了缺省的 ns 源服务器地址：<a target="_blank" rel="noopener" href="http://jmenv.tbsite.net:8080/rocketmq/nsaddr">http://jmenv.tbsite.net:8080/rocketmq/nsaddr</a></li>
<li>拿到 ns 地址更新到 nettyClient</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (null == this.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">    this.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 获取系统属性配置的ns源服务器地址</span><br><span class="line">public static String getWSAddr() &#123;</span><br><span class="line">    String wsDomainName = System.getProperty(&quot;rocketmq.namesrv.domain&quot;, DEFAULT_NAMESRV_ADDR_LOOKUP);</span><br><span class="line">    String wsDomainSubgroup = System.getProperty(&quot;rocketmq.namesrv.domain.subgroup&quot;, &quot;nsaddr&quot;);</span><br><span class="line">    String wsAddr = &quot;http://&quot; + wsDomainName + &quot;:8080/rocketmq/&quot; + wsDomainSubgroup;</span><br><span class="line">    if (wsDomainName.indexOf(&quot;:&quot;) &gt; 0) &#123;</span><br><span class="line">        wsAddr = &quot;http://&quot; + wsDomainName + &quot;/rocketmq/&quot; + wsDomainSubgroup;</span><br><span class="line">    &#125;</span><br><span class="line">    return wsAddr;</span><br><span class="line">&#125;...</span><br><span class="line">// 向ns源服务器地址发起http请求，获取ns服务器地址</span><br><span class="line">String url = this.wsAddr;</span><br><span class="line">HttpTinyClient.HttpResult result = HttpTinyClient.httpGet(url, null, null, &quot;UTF-8&quot;, timeoutMills);</span><br><span class="line">if (200 == result.code) &#123;</span><br><span class="line">    String responseStr = result.content;</span><br><span class="line">    if (responseStr != null) &#123;</span><br><span class="line">        return clearNewLine(responseStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;...</span><br><span class="line">// 注册ns服务器地址到nettyClient</span><br><span class="line">String[] addrArray = addrs.split(&quot;;&quot;);</span><br><span class="line">List &lt; String &gt; list = Arrays.asList(addrArray);</span><br><span class="line">this.remotingClient.updateNameServerAddressList(list);</span><br></pre></td></tr></table></figure>

<h3 id="启动-MQClientAPIImpl"><a href="#启动-MQClientAPIImpl" class="headerlink" title="启动 MQClientAPIImpl"></a>启动 MQClientAPIImpl</h3><p><code>MQClientAPIImpl</code>封装了通信接口给 mqClient 使用，它内部使用 Netty 通信。它的 start 方法会调用<code>NettyRemotingClient</code>的 start 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    this.remotingClient.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyRemotingClient 的 start 方法主要做了 2 件事。</p>
<h4 id="初始化-netty-客户端"><a href="#初始化-netty-客户端" class="headerlink" title="初始化 netty 客户端"></a>初始化 netty 客户端</h4><ul>
<li>初始化客户端 netty 环境，核心是添加 rocketmq 定义的网络通信 IO 数据的处理类 handler。需要注意的是：<ul>
<li>nioEventLoopGroup 在 NettyRemotingClient 的构造函数里实例化，只指定了一个 nioEventLoop 线程</li>
<li>为 IO 数据处理 handler 指定线程池来异步执行，提高 nioEventLoop 的线程利用率</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 为 IO 数据处理 handler 指定线程池来异步执行，提高 nioEventLoop 的线程利用率</span><br><span class="line">this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(nettyClientConfig.getClientWorkerThreads(), new ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger threadIndex = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Override public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;NettyClientWorkerThread_&quot; + this.threadIndex.incrementAndGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// nioEventLoopGroup在NettyRemotingClient的构造函数里实例化，只指定了一个 nioEventLoop 线程</span><br><span class="line">Bootstrap handler = this.bootstrap.group(this.eventLoopGroupWorker).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true).option(ChannelOption.SO_KEEPALIVE, false).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, nettyClientConfig.getConnectTimeoutMillis()).option(ChannelOption.SO_SNDBUF, nettyClientConfig.getClientSocketSndBufSize()).option(ChannelOption.SO_RCVBUF, nettyClientConfig.getClientSocketRcvBufSize()).handler(new ChannelInitializer &lt; SocketChannel &gt; () &#123;@Override public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        if (nettyClientConfig.isUseTLS()) &#123;</span><br><span class="line">            if (null != sslContext) &#123;</span><br><span class="line">                pipeline.addFirst(defaultEventExecutorGroup, &quot;sslHandler&quot;, sslContext.newHandler(ch.alloc()));</span><br><span class="line">                log.info(&quot;Prepend SSL handler&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.warn(&quot;Connections are insecure as SSLContext is null!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.addLast(defaultEventExecutorGroup, new NettyEncoder(), new NettyDecoder(), new IdleStateHandler(0, 0, nettyClientConfig.getClientChannelMaxIdleTimeSeconds()), new NettyConnectManageHandler(), new NettyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="定时清理过期的-ResponseFuture"><a href="#定时清理过期的-ResponseFuture" class="headerlink" title="定时清理过期的 ResponseFuture"></a>定时清理过期的 ResponseFuture</h4><ul>
<li>启动一个定时器，每隔 1 秒从 responseTable 移除已经超时的异步结果接收对象 ResponseFuture，并在 callback 线程池里提交任务，执行处理结果的 callback 方法<ul>
<li>nioEventLoop 执行业务 handler 的异步线程里解析响应，然后从 responseTable 根据 reqId 取出 ResponseFuture 并放入响应，再提交任务到线程池，回调 callback 方法处理结果。所以如果长时间没有新消息，responseTable 内存会一直存储接收结果的 ResponseFuture 对象，因此需要定时从 responseTable 清理过期的请求数据</li>
<li>callback 方法在固定线程数的线程池中执行，线程池数目取 cpu 核数，且最大不超过 4。see：org.apache.rocketmq.remoting.netty.NettyRemotingClient#publicExecutor</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.timer.scheduleAtFixedRate(new TimerTask() &#123;@Override public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            NettyRemotingClient.this.scanResponseTable();</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.error(&quot;scanResponseTable exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">1000 * 3, 1000);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void scanResponseTable() &#123;</span><br><span class="line">    final List &lt; ResponseFuture &gt; rfList = new LinkedList &lt; ResponseFuture &gt; ();</span><br><span class="line">    Iterator &lt; Entry &lt; Integer,</span><br><span class="line">    ResponseFuture &gt;&gt; it = this.responseTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry &lt; Integer, ResponseFuture &gt; next = it.next();</span><br><span class="line">        ResponseFuture rep = next.getValue();</span><br><span class="line"></span><br><span class="line">        if ((rep.getBeginTimestamp() + rep.getTimeoutMillis() + 1000) &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">            rep.release();</span><br><span class="line">            it.remove();</span><br><span class="line">            rfList.add(rep);</span><br><span class="line">            log.warn(&quot;remove timeout request, &quot; + rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (ResponseFuture rf: rfList) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executeInvokeCallback(rf);</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.warn(&quot;scanResponseTable, operationComplete Exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void executeInvokeCallback(final ResponseFuture responseFuture) &#123;</span><br><span class="line">    boolean runInThisThread = false;</span><br><span class="line">    ExecutorService executor = this.getCallbackExecutor();</span><br><span class="line">    if (executor != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executor.submit(new Runnable() &#123;</span><br><span class="line">                    @Override public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        responseFuture.executeInvokeCallback();</span><br><span class="line">                    &#125; catch(Throwable e) &#123;</span><br><span class="line">                        log.warn(&quot;execute callback in executor exception, and callback throw&quot;, e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        responseFuture.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            runInThisThread = true;</span><br><span class="line">            log.warn(&quot;execute callback in executor exception, maybe executor busy&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        runInThisThread = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runInThisThread) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            responseFuture.executeInvokeCallback();</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.warn(&quot;executeInvokeCallback Exception&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h3><h4 id="定时更新-ns-地址"><a href="#定时更新-ns-地址" class="headerlink" title="定时更新 ns 地址"></a>定时更新 ns 地址</h4><p>如果应用配置文件和系统环境变量都没有指定 ns 地址，使用单一定时线程池中的线程每隔 2 分钟去 ns 源服务器获取最新的 ns 服务器地址，更新到 nettyClient</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (null == this.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                MQClientInstance.this.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                log.error(&quot;ScheduledTask fetchNameServerAddr exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    1000 * 10, 1000 * 60 * 2, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时刷新-topic-消息路由"><a href="#定时刷新-topic-消息路由" class="headerlink" title="定时刷新 topic 消息路由"></a>定时刷新 topic 消息路由</h4><p>定时查询并刷新 mq 客户端发布和订阅的 topic 路由信息。获取所有 producer 和 consumer 发布和订阅的 topic，到 ns 查询 topic 的路由信息。执行频率来自配置，默认 30s 执行一次</p>
<ul>
<li><p>更新 mqClient 的<code>brokerAddrTable</code>、<code>topicRouteTable</code></p>
</li>
<li><p>更新 producer 的 topic 路由信息<code>topicPublishInfoTable</code></p>
<ul>
<li>producer 配置时不指定 topic，而是每次发送消息时去 topicPublishInfoTable 拿当前 topic 的路由信息，如果没有会从 ns 查询并更新到 topicPublishInfoTable</li>
</ul>
</li>
<li><p>更新 consumer 的负载均衡器<code>RebalanceImpl</code>的 topicSubscribeInfoTable</p>
<ul>
<li>consumer 订阅的 topic 从 RebalanceImpl 的 SubscriptionData 取出，构建 SubscriptionData 是在 consumer 实例的 start 方法里完成的</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQClientInstance.this.updateTopicRouteInfoFromNameServer();</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">10, this.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Iterator &lt; Entry &lt; String,</span><br><span class="line">MQConsumerInner &gt;&gt; it = this.consumerTable.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Entry &lt; String,</span><br><span class="line">    MQConsumerInner &gt; entry = it.next();</span><br><span class="line">    MQConsumerInner impl = entry.getValue();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        Set &lt; SubscriptionData &gt; subList = impl.subscriptions();</span><br><span class="line">        if (subList != null) &#123;</span><br><span class="line">            for (SubscriptionData subData: subList) &#123;</span><br><span class="line">                topicList.add(subData.getTopic());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator &lt; Entry &lt; String,</span><br><span class="line">MQProducerInner &gt;&gt; it = this.producerTable.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Entry &lt; String,</span><br><span class="line">    MQProducerInner &gt; entry = it.next();</span><br><span class="line">    MQProducerInner impl = entry.getValue();</span><br><span class="line">    if (impl != null) &#123;</span><br><span class="line">        Set &lt; String &gt; lst = impl.getPublishTopicList();</span><br><span class="line">        topicList.addAll(lst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (String topic: topicList) &#123;</span><br><span class="line">    this.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateTopicRouteInfoFromNameServer(final String topic) &#123;...topicRouteData = this.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, 1000 * 3);</span><br><span class="line">    if (topicRouteData != null) &#123;</span><br><span class="line">        TopicRouteData old = this.topicRouteTable.get(topic);</span><br><span class="line">        boolean changed = topicRouteDataIsChange(old, topicRouteData);...</span><br><span class="line">        if (changed) &#123;</span><br><span class="line">            TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line">            // 更新存储topic的broker地址</span><br><span class="line">            for (BrokerData bd: topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">                this.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新每个producer发布的topic路由信息，主要是topic的broker路由和MessageQueue信息</span><br><span class="line">            &#123;</span><br><span class="line">                TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">                publishInfo.setHaveTopicRouterInfo(true);</span><br><span class="line">                Iterator &lt; Entry &lt; String,</span><br><span class="line">                MQProducerInner &gt;&gt; it = this.producerTable.entrySet().iterator();</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    Entry &lt; String,</span><br><span class="line">                    MQProducerInner &gt; entry = it.next();</span><br><span class="line">                    MQProducerInner impl = entry.getValue();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新每个consumer订阅的topic路由信息，主要是topic的broker路由和MessageQueue信息</span><br><span class="line">            &#123;</span><br><span class="line">                Set &lt; MessageQueue &gt; subscribeInfo = topicRouteData2TopicSubscribeInfo(topic, topicRouteData);</span><br><span class="line">                Iterator &lt; Entry &lt; String,</span><br><span class="line">                MQConsumerInner &gt;&gt; it = this.consumerTable.entrySet().iterator();</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    Entry &lt; String,</span><br><span class="line">                    MQConsumerInner &gt; entry = it.next();</span><br><span class="line">                    MQConsumerInner impl = entry.getValue();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.updateTopicSubscribeInfo(topic, subscribeInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新topic路由信息</span><br><span class="line">            this.topicRouteTable.put(topic, cloneTopicRouteData);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时向-broker-发送心跳"><a href="#定时向-broker-发送心跳" class="headerlink" title="定时向 broker 发送心跳"></a>定时向 broker 发送心跳</h4><p>定时清理不能路由到 topic 的 broker，然后向<code>MQClientInstance</code>的所有可以路由到发布和订阅 topic 的 broker 发送心跳。执行频率来自配置，默认 30s 执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQClientInstance.this.cleanOfflineBroker();</span><br><span class="line">            MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;ScheduledTask sendHeartbeatToAllBroker exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>mqClient 的 brokerAddrTable 中删除已不能路由到 topic 的 broker 机器地址（broker 是主从架构），如果主从架构所有的 broker 机器都路由不到节点，删除 broker 逻辑节点</p>
<ul>
<li>brokerAddrTable 维度是 broker 逻辑节点，key&#x3D;brokerName，value 是 broker 逻辑节点中所有主从架构部署的物理机器地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, HashMap&lt;Long, String&gt;&gt; updatedTable = new ConcurrentHashMap&lt;String, HashMap&lt;Long, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;Entry&lt;String, HashMap&lt;Long, String&gt;&gt;&gt; itBrokerTable = this.brokerAddrTable.entrySet().iterator();</span><br><span class="line">while (itBrokerTable.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, HashMap&lt;Long, String&gt;&gt; entry = itBrokerTable.next();</span><br><span class="line">    String brokerName = entry.getKey();</span><br><span class="line">    HashMap&lt;Long, String&gt; oneTable = entry.getValue();</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Long, String&gt; cloneAddrTable = new HashMap&lt;Long, String&gt;();</span><br><span class="line">    cloneAddrTable.putAll(oneTable);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = cloneAddrTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Long, String&gt; ee = it.next();</span><br><span class="line">        String addr = ee.getValue();</span><br><span class="line">        if (!this.isBrokerAddrExistInTopicRouteTable(addr)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            log.info(&quot;the broker addr[&#123;&#125; &#123;&#125;] is offline, remove it&quot;, brokerName, addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果主从架构所有的broker机器都路由不到节点，删除broker逻辑节点</span><br><span class="line">    if (cloneAddrTable.isEmpty()) &#123;</span><br><span class="line">        itBrokerTable.remove();</span><br><span class="line">        log.info(&quot;the broker[&#123;&#125;] name&#x27;s host is offline, remove it&quot;, brokerName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        updatedTable.put(brokerName, cloneAddrTable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!updatedTable.isEmpty()) &#123;</span><br><span class="line">    this.brokerAddrTable.putAll(updatedTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private boolean isBrokerAddrExistInTopicRouteTable(final String addr) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, TopicRouteData&gt;&gt; it = this.topicRouteTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, TopicRouteData&gt; entry = it.next();</span><br><span class="line">        TopicRouteData topicRouteData = entry.getValue();</span><br><span class="line">        List&lt;BrokerData&gt; bds = topicRouteData.getBrokerDatas();</span><br><span class="line">        for (BrokerData bd : bds) &#123;</span><br><span class="line">            if (bd.getBrokerAddrs() != null) &#123;</span><br><span class="line">                boolean exist = bd.getBrokerAddrs().containsValue(addr);</span><br><span class="line">                if (exist)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向可路由到的 broker 物理节点发送心跳</p>
<ul>
<li>心跳信息包括 mq 客户端的 clientId、producerGroupName 和 consumerGroup 的订阅信息<code>SubscriptionData</code><ul>
<li>broker 按 consumerGroup 维度聚合组订阅信息。客户端拉取消息时，broker 会用到订阅信息来判断消息是否满足过滤条件（tag 过滤 or SQL 过滤）。消息过滤原理后面单独讲</li>
<li>如果同 group 中两个 consumer 订阅信息不同，broker 存储的 consumerGroup 订阅信息会被最新一次心跳数据覆盖，被覆盖订阅信息的 consumer 在拉取消息时，broker 可能会找不到 topic 的订阅信息而返回失败</li>
<li>如果 mqClient 只有 producer，只需要向 master 节点发送心跳</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 心跳信息包括mq客户端的clientId、所有producer和consumer信息</span><br><span class="line">    final HeartbeatData heartbeatData = this.prepareHeartbeatData();</span><br><span class="line">    ...</span><br><span class="line">    // brokerAddrTable是broker逻辑节点维度，每个逻辑节点包含多个broker物理节点，因为broker是主从架构</span><br><span class="line">    Iterator&lt;Entry&lt;String, HashMap&lt;Long, String&gt;&gt;&gt; it = this.brokerAddrTable.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, HashMap&lt;Long, String&gt;&gt; entry = it.next();</span><br><span class="line">        String brokerName = entry.getKey();</span><br><span class="line">        HashMap&lt;Long, String&gt; oneTable = entry.getValue();</span><br><span class="line">        if (oneTable != null) &#123;</span><br><span class="line">            // broker物理节点，key=0说明是master物理节点</span><br><span class="line">            for (Map.Entry&lt;Long, String&gt; entry1 : oneTable.entrySet()) &#123;</span><br><span class="line">                Long id = entry1.getKey();</span><br><span class="line">                String addr = entry1.getValue();</span><br><span class="line">                if (addr != null) &#123;</span><br><span class="line">                    // 如果mqClient没有consumer，只需和masterBroker保持心跳</span><br><span class="line">                    if (consumerEmpty) &#123;</span><br><span class="line">                        if (id != MixAll.MASTER_ID)</span><br><span class="line">                            continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        int version = this.mQClientAPIImpl.sendHearbeat(addr, heartbeatData, 3000);</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时发送-consumer-的消费位点"><a href="#定时发送-consumer-的消费位点" class="headerlink" title="定时发送 consumer 的消费位点"></a>定时发送 consumer 的消费位点</h4><p>定时把 consumer 在 messageQueue 的消费位点更新到 broker，目的是消费者集群重启后能继续从 broker 拉取后面未消费过的消息。执行频率来自配置，默认 5s 执行一次</p>
<ul>
<li>注意，只有集群模式才会把消费位点更新到 broker，广播模式只要在本地持久化消费位点即可<ul>
<li>广播模式只要本机器自己知道在 mq 上消费到哪里即可，宕机重启后也能继续消费后面的消息</li>
<li>集群模式如果宕机重启，需要重新负载均衡分配 mq 的消费者机器，所以不能消费者机器本地持久化位点，只有 broker 自己知道 mq 的消费位点，才能给“新的消费者机器”投递后续的消息</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQClientInstance.this.persistAllConsumerOffset();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;ScheduledTask persistAllConsumerOffset exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>遍历所有 Consumer 实例，然后从内存里获取 consumer 在每个 messageQueue 的当前消费位点</p>
<ul>
<li>当 messageQueue 数目大于 ConsumerGroup 下的实例数，一个 Consumer 实例有可能消费多个 messageQueue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, MQConsumerInner&gt;&gt; it = this.consumerTable.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, MQConsumerInner&gt; entry = it.next();</span><br><span class="line">    MQConsumerInner impl = entry.getValue();</span><br><span class="line">    impl.persistConsumerOffset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : this.offsetTable.entrySet()) &#123;</span><br><span class="line">    MessageQueue mq = entry.getKey();</span><br><span class="line">    AtomicLong offset = entry.getValue();</span><br><span class="line">    if (offset != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 将consumer对messageQueue的最新消费位点更新到broker</span><br><span class="line">        this.updateConsumeOffsetToBroker(mq, offset.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 messageQueue 所在 broker 的物理节点地址，更新 consumerGroup 在当前 messageQueue 的消费位点</p>
<ul>
<li>messageQueue 在同一个消费组 ConsumerGroup 下只能有一个消费者 Consumer（负载均衡里实现的），所以 messageQueue 记录消费位点是按消费组 ConsumerGroup 维度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,</span><br><span class="line">MQBrokerException, InterruptedException, MQClientException &#123;</span><br><span class="line">    // 从messageQueue所在broker获取一个物理节点地址</span><br><span class="line">    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());</span><br><span class="line">    if (null == findBrokerResult) &#123;</span><br><span class="line">        // 如果找不到broker，去ns获取topic的最新broker路由信息，并更新到本地</span><br><span class="line">        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">        // 再找一次mq所在的broker的物理节点地址</span><br><span class="line">        findBrokerResult = this.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (findBrokerResult != null) &#123;</span><br><span class="line">        UpdateConsumerOffsetRequestHeader requestHeader = new UpdateConsumerOffsetRequestHeader();</span><br><span class="line">        requestHeader.setTopic(mq.getTopic());</span><br><span class="line">        requestHeader.setConsumerGroup(this.groupName);</span><br><span class="line">        requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">        requestHeader.setCommitOffset(offset);</span><br><span class="line"></span><br><span class="line">        // 将mqClient对messageQueue的最新消费位点更新到broker</span><br><span class="line">        if (isOneway) &#123;</span><br><span class="line">            this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffsetOneway(</span><br><span class="line">                findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffset(</span><br><span class="line">                findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new MQClientException(&quot;The broker[&quot; + mq.getBrokerName() + &quot;] not exist&quot;, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动消息拉取线程"><a href="#启动消息拉取线程" class="headerlink" title="启动消息拉取线程"></a>启动消息拉取线程</h3><p>启动一个消息拉取线程，从阻塞队列<code>pullRequestQueue</code>拿消息拉取的 request，向 broker 发送请求批量拉取消息</p>
<ul>
<li>阻塞队列类型：LinkedBlockingQueue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Start pull service</span><br><span class="line">this.pullMessageService.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    log.info(&quot;Try to start service thread:&#123;&#125; started:&#123;&#125; lastThread:&#123;&#125;&quot;, getServiceName(), started.get(), thread);</span><br><span class="line">    if (!started.compareAndSet(false, true)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    stopped = false;</span><br><span class="line">    this.thread = new Thread(this, getServiceName());</span><br><span class="line">    this.thread.setDaemon(isDaemon);</span><br><span class="line">    this.thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PullRequest pullRequest = this.pullRequestQueue.take();</span><br><span class="line">            this.pullMessage(pullRequest);</span><br><span class="line">        &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;Pull Message Service Run Method exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取-consumer-实例"><a href="#获取-consumer-实例" class="headerlink" title="获取 consumer 实例"></a>获取 consumer 实例</h4><p>通过拉取消息请求所属的 ConsumerGroup，获取 Consumer 实例</p>
<ul>
<li>第一个拉取消息请求是 consumer 的 rebalance 负载均衡后放入的<ul>
<li>注意，消息拉取请求的维度是 messageQueue，即每个 messageQueue 都会有对应的拉取消息请求</li>
<li>后续该 consumer 在 mq 上的消息拉取请求都是复用这个 request</li>
</ul>
</li>
<li>这里 Consumer 直接强转成 DefaultMQPushConsumerImpl，说明消息拉取线程使用推模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mQClientFactory是MQClientInstance</span><br><span class="line">final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">if (consumer != null) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">    impl.pullMessage(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h4><p>DefaultMQPushConsumerImpl 发送拉取消息请求前，会做流控，如果触发流控，会通过一个延时任务，50ms 后再把这个消息拉取请求放入阻塞队列。</p>
<p>满足以下任一条件，触发流控：</p>
<ul>
<li>待处理的消息数超过阈值<ul>
<li>从 messageQueue 拉取到的消息会放入处理队列 processQueue，每次消费都从该队列取出。所以通过它能判断当前待处理消息数目</li>
<li>阈值可以通过配置 consumer 的 pullThresholdForQueue 修改</li>
</ul>
</li>
<li>待处理的消息大小超过阈值<ul>
<li>阈值可以通过配置 consumer 的 pullThresholdSizeForQueue 修改</li>
</ul>
</li>
<li>乱序消费 &amp;&amp; 处理队列的位点范围超过阈值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 处理队列缓存的消息数目或消息体大小超过阈值，延时拉取消息</span><br><span class="line">long cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span><br><span class="line"></span><br><span class="line">if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    if ((queueFlowControlTimes++%1000) == 0) &#123;</span><br><span class="line">        log.warn(&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;, this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!this.consumeOrderly) &#123;</span><br><span class="line">    // 乱序消费时，处理队列当前待处理消息的位点范围超过阈值（消费速度&lt;生成速度），执行流控，延时拉取消息</span><br><span class="line">    if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">        if ((queueMaxSpanFlowControlTimes++%1000) == 0) &#123;</span><br><span class="line">            log.warn(&quot;the queue&#x27;s messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;, processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) &#123;</span><br><span class="line">    if (!isStopped()) &#123;</span><br><span class="line">        this.scheduledExecutorService.schedule(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">                PullMessageService.this.executePullRequestImmediately(pullRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        timeDelay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.warn(&quot;PullMessageServiceScheduledThread has shutdown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void executePullRequestImmediately(final PullRequest pullRequest) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.pullRequestQueue.put(pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上报已消费的位点"><a href="#上报已消费的位点" class="headerlink" title="上报已消费的位点"></a>上报已消费的位点</h4><p>集群模式下，拉取消息请求里放入 consumer 在 mq 上已消费到的位点 commitOffsetValue，让 broker 做持久化。和定时上报 consumer 消费位点相互配合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 订阅模式，集群型表示消息在ConsumerGroup中只能被消费一次，广播型表示消息可以被ConsumerGroup中的每个Consumer消费一次</span><br><span class="line">// 集群订阅模式，拉取消息时传入commitOffsetValue，应该是告知broker，当前ConsumerGroup已经消费到该位点了，位点前的消息不能再被拉取</span><br><span class="line">if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">    commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">    if (commitOffsetValue &gt; 0) &#123;</span><br><span class="line">        commitOffsetEnable = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意拉取请求的起始位点 nextOffset 不是 commitOffsetValue。而是从 broker 拿到的响应 pullResult 里取出的，即 broker 会在响应里告诉 consumer，下一次消息拉取的起始位点</p>
<ul>
<li>首次拉取请求的 nextOffset 为 null，这时 broker 就会用到 consumer 上报的 commitOffsetValue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br></pre></td></tr></table></figure>

<h4 id="获取-broker-地址"><a href="#获取-broker-地址" class="headerlink" title="获取 broker 地址"></a>获取 broker 地址</h4><p>获取 messageQueue 所在的 broker 地址，然后调用 pullMessageAsync 异步拉取消息</p>
<ul>
<li>传入 Consumer 的 callback 接口用于收到消息后回调，消费批量拉取到的消息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">FindBrokerResult findBrokerResult =</span><br><span class="line">    // 挑选要从messageQueue所在的物理broker拉取消息，可能是master也可能是slave</span><br><span class="line">    this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</span><br><span class="line">        this.recalculatePullFromWhichNode(mq), false);</span><br><span class="line">if (null == findBrokerResult) &#123;</span><br><span class="line">    // 找不到broker，重新从ns刷一遍路由信息到内存，然后再找一遍</span><br><span class="line">    this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">    findBrokerResult =</span><br><span class="line">        this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</span><br><span class="line">            this.recalculatePullFromWhichNode(mq), false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (findBrokerResult != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();</span><br><span class="line">    requestHeader.setConsumerGroup(this.consumerGroup);</span><br><span class="line">    requestHeader.setTopic(mq.getTopic());</span><br><span class="line">    requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">    requestHeader.setQueueOffset(offset);   // pullRequest.getNextOffset()，拉取该位点后面的消息</span><br><span class="line">    requestHeader.setMaxMsgNums(maxNums);   // 批量拉取的最大消息数</span><br><span class="line">    requestHeader.setSysFlag(sysFlagInner);</span><br><span class="line">    requestHeader.setCommitOffset(commitOffset);</span><br><span class="line">    requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</span><br><span class="line">    requestHeader.setSubscription(subExpression);</span><br><span class="line">    requestHeader.setSubVersion(subVersion);</span><br><span class="line">    requestHeader.setExpressionType(expressionType);</span><br><span class="line"></span><br><span class="line">    String brokerAddr = findBrokerResult.getBrokerAddr();</span><br><span class="line">    if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</span><br><span class="line">        brokerAddr = computePullFromWhichFilterServer(mq.getTopic(), brokerAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 批量拉取消息，推模式异步拉取消息，提供callback接口，异步future结果返回后，通过注册在future的监听器回调callback方法消费批量拉取的消息</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);</span><br><span class="line">    switch (communicationMode) &#123;</span><br><span class="line">        case ONEWAY:</span><br><span class="line">            assert false;</span><br><span class="line">            return null;</span><br><span class="line">        case ASYNC:</span><br><span class="line">            this.pullMessageAsync(addr, request, timeoutMillis, pullCallback);</span><br><span class="line">            return null;</span><br><span class="line">        case SYNC:</span><br><span class="line">            return this.pullMessageSync(addr, request, timeoutMillis);</span><br><span class="line">        default:</span><br><span class="line">            assert false;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义-netty-响应的回调-callback"><a href="#定义-netty-响应的回调-callback" class="headerlink" title="定义 netty 响应的回调 callback"></a>定义 netty 响应的回调 callback</h4><p>调用底层 netty 发送异步消息拉取请求前，又定义了一个 callback，用于将 netty 的响应结果转成 PullResult，然后回调外层 Consumer 提供的 callback，真正消费批量消息</p>
<ul>
<li>体现了分层和单一职责的思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ResponseFuture responseFuture) &#123;</span><br><span class="line">        RemotingCommand response = responseFuture.getResponseCommand();</span><br><span class="line">        if (response != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response, addr);</span><br><span class="line">                assert pullResult != null;</span><br><span class="line">                pullCallback.onSuccess(pullResult);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                pullCallback.onException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立和-broker-的-tcp-连接"><a href="#建立和-broker-的-tcp-连接" class="headerlink" title="建立和 broker 的 tcp 连接"></a>建立和 broker 的 tcp 连接</h4><p>netty 在发送异步请求前，会到 channelTable 拿这个 broker 地址对应的 channel 连接通道。如果没有（第一次发送请求），会调用 connect 方法建立与 broker 的 tcp 连接，然后再把通道 channel 缓存到 channelTable</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private Channel getAndCreateChannel(final String addr) throws RemotingConnectException,</span><br><span class="line">InterruptedException &#123;</span><br><span class="line">    if (null == addr) &#123;</span><br><span class="line">        return getAndCreateNameserverChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelWrapper cw = this.channelTables.get(addr);</span><br><span class="line">    if (cw != null &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">        return cw.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.createChannel(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Channel createChannel(final String addr) throws InterruptedException &#123;</span><br><span class="line">    ChannelWrapper cw = this.channelTables.get(addr);</span><br><span class="line">    if (cw != null &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">        return cw.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.lockChannelTables.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean createNewConnection;</span><br><span class="line">            cw = this.channelTables.get(addr);</span><br><span class="line">            if (cw != null) &#123;</span><br><span class="line"></span><br><span class="line">                if (cw.isOK()) &#123;</span><br><span class="line">                    return cw.getChannel();</span><br><span class="line">                &#125; else if (!cw.getChannelFuture().isDone()) &#123;</span><br><span class="line">                    createNewConnection = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.channelTables.remove(addr);</span><br><span class="line">                    createNewConnection = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                createNewConnection = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (createNewConnection) &#123;</span><br><span class="line">                ChannelFuture channelFuture = this.bootstrap.connect(RemotingHelper.string2SocketAddress(addr));</span><br><span class="line">                log.info(&quot;createChannel: begin to connect remote host[&#123;&#125;] asynchronously&quot;, addr);</span><br><span class="line">                cw = new ChannelWrapper(channelFuture);</span><br><span class="line">                this.channelTables.put(addr, cw);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;createChannel: create channel exception&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.lockChannelTables.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.warn(&quot;createChannel: try to lock channel table, but timeout, &#123;&#125;ms&quot;, LOCK_TIMEOUT_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cw != null) &#123;</span><br><span class="line">        ChannelFuture channelFuture = cw.getChannelFuture();</span><br><span class="line">        if (channelFuture.awaitUninterruptibly(this.nettyClientConfig.getConnectTimeoutMillis())) &#123;</span><br><span class="line">            if (cw.isOK()) &#123;</span><br><span class="line">                log.info(&quot;createChannel: connect remote host[&#123;&#125;] success, &#123;&#125;&quot;, addr, channelFuture.toString());</span><br><span class="line">                return cw.getChannel();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.warn(&quot;createChannel: connect remote host[&quot; + addr + &quot;] failed, &quot; + channelFuture.toString(), channelFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.warn(&quot;createChannel: connect remote host[&#123;&#125;] timeout &#123;&#125;ms, &#123;&#125;&quot;, addr, this.nettyClientConfig.getConnectTimeoutMillis(), channelFuture.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-netty-发送请求"><a href="#通过-netty-发送请求" class="headerlink" title="通过 netty 发送请求"></a>通过 netty 发送请求</h4><p>使用 netty 发送消息异步拉取请求到 broker</p>
<ul>
<li>创建这次请求的<code>ResponseFuture</code>对象，封装这次请求的异步响应上下文，包括异步消息响应（收到响应后 set 进去）、reqId、callback 函数等</li>
<li>缓存 ResponseFuture，key 是 reqId<ul>
<li>reqId 的生成规则是一个全局自增数</li>
<li>拿到响应后通过 reqId 拿到<code>ResponseFuture</code>，填充响应结果，然后在 callback 线程池里回调内层 callback 转换响应结果，再回调外层 callback 处理消息</li>
<li>通过 reqId 关联请求和响应，是实现异步拉取消息（推模式）的关键点</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建这次请求的`ResponseFuture`对象，封装这次请求的响应上下文，包括从netty通道获取的响应结果、处理响应结果的回调方法等</span><br><span class="line">final ResponseFuture responseFuture = new ResponseFuture(channel, opaque, timeoutMillis - costTime, invokeCallback, once);</span><br><span class="line">// 缓存ResponseFuture，key是请求id，生成规则是一个全局自增数。拿到响应后通过请求id拿到`ResponseFuture`，填充响应结果，然后执行回调方法处理响应结果</span><br><span class="line">this.responseTable.put(opaque, responseFuture);</span><br><span class="line">try &#123;</span><br><span class="line">    channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void operationComplete(ChannelFuture f) throws Exception &#123;</span><br><span class="line">            if (f.isSuccess()) &#123;</span><br><span class="line">                responseFuture.setSendRequestOK(true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            requestFail(opaque);</span><br><span class="line">            log.warn(&quot;send a request command to channel &lt;&#123;&#125;&gt; failed.&quot;, RemotingHelper.parseChannelRemoteAddr(channel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 拿到响应后通过请求id拿到`ResponseFuture`，填充响应结果</span><br><span class="line">// 回调内层callback处理响应结果，最终回调外层callback消费消息</span><br><span class="line">public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) &#123;</span><br><span class="line">    final int opaque = cmd.getOpaque();</span><br><span class="line">    final ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">    if (responseFuture != null) &#123;</span><br><span class="line">        responseFuture.setResponseCommand(cmd);</span><br><span class="line">        responseTable.remove(opaque);</span><br><span class="line">        if (responseFuture.getInvokeCallback() != null) &#123;</span><br><span class="line">            executeInvokeCallback(responseFuture);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            responseFuture.putResponse(cmd);</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void executeInvokeCallback(final ResponseFuture responseFuture) &#123;</span><br><span class="line">    boolean runInThisThread = false;</span><br><span class="line">    ExecutorService executor = this.getCallbackExecutor();</span><br><span class="line">    if (executor != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executor.submit(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        responseFuture.executeInvokeCallback();</span><br><span class="line">                    &#125; catch(Throwable e) &#123;</span><br><span class="line">                        log.warn(&quot;execute callback in executor exception, and callback throw&quot;, e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        responseFuture.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            runInThisThread = true;</span><br><span class="line">            log.warn(&quot;execute callback in executor exception, maybe executor busy&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        runInThisThread = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runInThisThread) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            responseFuture.executeInvokeCallback();</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            log.warn(&quot;executeInvokeCallback Exception&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果是同步拉取消息"><a href="#如果是同步拉取消息" class="headerlink" title="如果是同步拉取消息"></a>如果是同步拉取消息</h4><p>以上说的都是异步拉取消息的方式，即推 Push 模式。如果是拉 Pull 模式，区别就是从异步拉取消息改为同步拉取消息。具体实现方式为：</p>
<ul>
<li>ResponseFuture 放入 table，然后通过和 broker 建连的 channel 发送请求，这和异步方式没差别</li>
<li>调用 CDL 的 await 方法，让拉取消息线程阻塞等待响应结果<ul>
<li>注意是带最长阻塞时间的</li>
</ul>
</li>
<li>收到响应后，通过 reqId 拿到 ResponseFuture，因为同步方式 ResponseFuture 不会包含 callback 函数，所以走 putResponse 方法，set 响应数据并执行 countDown。这会唤醒拉取消息线程，拿到响应数据开始执行消费逻辑。这也是同步和异步最大的区别</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request,</span><br><span class="line">    final long timeoutMillis)</span><br><span class="line">    throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException &#123;</span><br><span class="line">    final int opaque = request.getOpaque();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        final ResponseFuture responseFuture = new ResponseFuture(channel, opaque, timeoutMillis, null, null);</span><br><span class="line">        this.responseTable.put(opaque, responseFuture);</span><br><span class="line">        final SocketAddress addr = channel.remoteAddress();</span><br><span class="line">        channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture f) throws Exception &#123;</span><br><span class="line">                if (f.isSuccess()) &#123;</span><br><span class="line">                    responseFuture.setSendRequestOK(true);</span><br><span class="line">                    return;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    responseFuture.setSendRequestOK(false);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                responseTable.remove(opaque);</span><br><span class="line">                responseFuture.setCause(f.cause());</span><br><span class="line">                responseFuture.putResponse(null);</span><br><span class="line">                log.warn(&quot;send a request command to channel &lt;&quot; + addr + &quot;&gt; failed.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 同步拉取消息，线程hold一定时间等待response</span><br><span class="line">        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</span><br><span class="line">        if (null == responseCommand) &#123;</span><br><span class="line">            if (responseFuture.isSendRequestOK()) &#123;</span><br><span class="line">                throw new RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,</span><br><span class="line">                    responseFuture.getCause());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseCommand;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        this.responseTable.remove(opaque);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public RemotingCommand waitResponse(final long timeoutMillis) throws InterruptedException &#123;</span><br><span class="line">    this.countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    return this.responseCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void processResponseCommand(ChannelHandlerContext ctx, RemotingCommand cmd) &#123;</span><br><span class="line">    final int opaque = cmd.getOpaque();</span><br><span class="line">    final ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">    if (responseFuture != null) &#123;</span><br><span class="line">        responseFuture.setResponseCommand(cmd);</span><br><span class="line"></span><br><span class="line">        responseTable.remove(opaque);</span><br><span class="line"></span><br><span class="line">        if (responseFuture.getInvokeCallback() != null) &#123;</span><br><span class="line">            executeInvokeCallback(responseFuture);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            responseFuture.putResponse(cmd);</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.warn(&quot;receive response, but not matched any request, &quot; + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line">        log.warn(cmd.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费拉取到的消息"><a href="#消费拉取到的消息" class="headerlink" title="消费拉取到的消息"></a>消费拉取到的消息</h4><p>收到异步响应后 netty 回调业务 handler 处理消息，see：org.apache.rocketmq.remoting.netty.NettyRemotingClient.NettyClientHandler#channelRead0<br>在业务 handler 里通过 reqId 拿到对应 ResponseFuture 并把消息体赋给它。然后提交任务到 callback 线程池，异步调用 callback 线程来处理新消息<br>callback 线程将消息体转义为 pullResult 对象，然后回调业务 callback 的 onSuccess 方法开始真正处理新消息。</p>
<p>下面介绍的都是拿到了新消息后的逻辑，如果没拉取到新消息会立刻将请求放入阻塞队列</p>
<h5 id="设置下次拉取消息的起始位点"><a href="#设置下次拉取消息的起始位点" class="headerlink" title="设置下次拉取消息的起始位点"></a>设置下次拉取消息的起始位点</h5><p>读取在 messageQueue 上的消息拉取响应里返回的位点，作为下次拉取消息的起始位点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 读取messageQueue在消息拉取的响应里返回的位点，作为下次拉取消息的起始位点</span><br><span class="line">long prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br></pre></td></tr></table></figure>

<h5 id="消息放入-processQueue"><a href="#消息放入-processQueue" class="headerlink" title="消息放入 processQueue"></a>消息放入 processQueue</h5><p>拉取到的消息放入 processQueue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 消息List放入处理队列</span><br><span class="line">boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br></pre></td></tr></table></figure>

<h5 id="异步消费消息"><a href="#异步消费消息" class="headerlink" title="异步消费消息"></a>异步消费消息</h5><p>提交消费任务到线程池异步执行。按消费模式的不同，乱序（并发）消费使用 ConsumeMessageConcurrentlyService，顺序消费使用 ConsumeMessageOrderlyService</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建消费任务，提交到线程池执行</span><br><span class="line">// 如果是并发消费，消息list按最大批量消费数阈值分片后，提交并发消费任务到线程池 ✨</span><br><span class="line">// 如果是顺序消费，提交顺序消费任务到线程池 ✨</span><br><span class="line">DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(</span><br><span class="line">    pullResult.getMsgFoundList(),</span><br><span class="line">    processQueue,</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    dispatchToConsume);</span><br></pre></td></tr></table></figure>

<p>如果是乱序消费，消息 list 按单次消费消息数阈值分片后，提交多个并发消费任务到线程池</p>
<ul>
<li>消费阈值默认为 1，定义在 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#consumeMessageBatchMaxSize<ul>
<li>一般我们不改这个值，因为 listener 消费接口返回消费结果状态，如果多条消息一起消费，它们只能一起消费成功或失败</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">if (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">    ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">    try &#123;</span><br><span class="line">        this.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">        this.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    for (int total = 0; total &lt; msgs.size(); ) &#123;</span><br><span class="line">        List&lt;MessageExt&gt; msgThis = new ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">        for (int i = 0; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">            if (total &lt; msgs.size()) &#123;</span><br><span class="line">                msgThis.add(msgs.get(total));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.consumeExecutor.submit(consumeRequest);</span><br><span class="line">        &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">            for (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                msgThis.add(msgs.get(total));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行并发消费消息任务，先调用前置 hook</p>
<ul>
<li>hook 函数是调用 org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#registerConsumeMessageHook 方法注册到 consumer 的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = new ConsumeMessageContext();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(false);</span><br><span class="line">    ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用业务方 listener 消费批量消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br></pre></td></tr></table></figure>

<p>最后调用后置 hook</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    // 调用后置hook</span><br><span class="line">    ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理消费结果</p>
<ul>
<li>如果 listener 返回的消费状态为重试（消费失败了），消息发送回 broker，并传入消息重投最大次数和重投时间间隔<ul>
<li>重投次数由 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#maxReconsumeTimes 控制，默认为-1，然后被转成 16，即默认重投 16 次</li>
<li>重投时间间隔由 org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext#delayLevelWhenNextConsume 控制。-1 表示直接投递到 DLQ 死信队列不重新消费了，0 表示由 broker 控制重投间隔，大于 0 表示客户端控制重投间隔。默认为 0</li>
<li>ConsumeConcurrentlyContext 作为入参传递给 listener，业务方可以修改默认值控制消息的重投间隔</li>
<li>如果消息发回 broker 失败，会本地提交一个延时任务，5 秒后重新消费消息</li>
</ul>
</li>
<li>从处理队列 ProcessQueue 移除消费完的消息</li>
<li>从 processQueue 获取下一个待消费消息的 offset，更新到 offsetTable<ul>
<li>offsetTable 按 messageQueue 维度存储将要消费的下一条消息位点。集群模式下定时上报到 broker，目的是 consumerGroup 重新负载均衡后（例如 consumerGroup 集群重启），broker 能知道 consumerGroup 在 messageQueue 上需要从哪条消息开始继续消费</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">case RECONSUME_LATER:</span><br><span class="line">    ackIndex = -1;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">case CLUSTERING:</span><br><span class="line">    List &lt; MessageExt &gt; msgBackFailed = new ArrayList &lt; MessageExt &gt; (consumeRequest.getMsgs().size());</span><br><span class="line">    for (int i = ackIndex + 1; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">        MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">        // 集群模式，批量消息消费失败，重投递消息到broker的消费队列，指定下次延迟发送时间 ✨</span><br><span class="line">        boolean result = this.sendMessageBack(msg, context);</span><br><span class="line">        if (!result) &#123;</span><br><span class="line">            msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);</span><br><span class="line">            msgBackFailed.add(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">        consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line"></span><br><span class="line">        this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">// 消费完的消息，从处理队列（实际就是一个map，key=offset，value=消息）移除，返回移除后队列下一条待消费的消息offset</span><br><span class="line">long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">// 更新下一个待消费消息的offset到内存offsetTable</span><br><span class="line">if (offset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">    this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果业务方使用的 listener 是 MessageListenerOrderly，则表示顺序消费 mq 上的消息，consumer 实例创建的消费服务就是 ConsumeMessageOrderlyService</p>
<p>顺序消费基本流程和并发消费类似，只说区别</p>
<p>1、如果 mqClient 还没有给 messageQueue 加锁，或加锁过期了，则加锁后再延迟消费消息</p>
<ul>
<li>mqClient 通知 broker 给 mq 加锁的目的是为了严格保证 mq 与消费者实例唯一绑定，确保 mq 上的消息在集群模式下被顺序消费</li>
<li>只有当 mqClient 关闭时，才会 unLock 所有 messageQueue</li>
<li>ConsumeMessageOrderlyService 的 start 方法会开启一个定时任务，发送 mq 加锁请求给负载均衡分配的 mq 所在的 broker。加锁成功后会置 mq 对应的 processQueue 的 locked 字段为 true</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// processQueue的locked状态和messageQueue是一致的，通过本地processQueue的锁定状态和锁定时间判断messageQueue是否锁定或过期，如果过期，需要重新让consumer所在的mqClient锁定messageQueue</span><br><span class="line">// 锁定messageQueue的作用我认为应该是为了通知broker，messageQueue已被consumerGroup中的当前client占据，防止极端情况组内其他client也去messageQueue拉取消息，造成乱序消费</span><br><span class="line">// 只有当mqClient关闭时，才会unLock所有messageQueue</span><br><span class="line">if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">        || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean lock(final MessageQueue mq) &#123;</span><br><span class="line">    FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);</span><br><span class="line">    if (findBrokerResult != null) &#123;</span><br><span class="line">        LockBatchRequestBody requestBody = new LockBatchRequestBody();</span><br><span class="line">        requestBody.setConsumerGroup(this.consumerGroup);</span><br><span class="line">        requestBody.setClientId(this.mQClientFactory.getClientId());</span><br><span class="line">        requestBody.getMqSet().add(mq);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // ConsumerGroup中的当前mqClient锁住它对应broker中的messageQueue</span><br><span class="line">        // 所谓锁住，实际是在broker中标记messageQueue被consumerGroup的哪个mqClient占有</span><br><span class="line">        Set&lt;MessageQueue&gt; lockedMq =</span><br><span class="line">        this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);</span><br><span class="line">        for (MessageQueue mmqq : lockedMq) &#123;</span><br><span class="line">            ProcessQueue processQueue = this.processQueueTable.get(mmqq);</span><br><span class="line">            if (processQueue != null) &#123;</span><br><span class="line">                // 缓存队列locked，说明它对应的messageQueue已被当前ConsumerGroup的mqClient锁住</span><br><span class="line">                processQueue.setLocked(true);</span><br><span class="line">                processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (lockOK) &#123;</span><br><span class="line">    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, mq, 10);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, mq, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、从 processQueue 按位点顺序取不超过批量消费消息阈值数的消息进行消费</p>
<ul>
<li>并发消费时，直接切分收到的消息 list，每个切分后的子消息 list 创建一个线程消费</li>
<li>从 processQueue 取消息 &amp;&amp; 调用业务 Listener 顺序消费时，都加了互斥锁，确保 processQueue 的 msgs 不被并发访问消费，即保证了顺序性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 批量消费消息数阈值</span><br><span class="line">final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">// 从缓存队列批量顺序取待消费消息，不超过批量消费消息数阈值</span><br><span class="line">List&lt;MessageExt&gt; msgs = this.processQueue.takeMessages(consumeBatchSize);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 调用业务Listener顺序消费时加锁，防止在任务并发执行时，并发调用listener消费消息，产生消费乱序</span><br><span class="line">    this.processQueue.getLockConsume().lock();</span><br><span class="line">    // 批量消费消息</span><br><span class="line">    status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 解锁</span><br><span class="line">    this.processQueue.getLockConsume().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、顺序消费失败，如果超过最大重试次数，发送到死信队列，跳过消息。否则，将 msgs 重新放回 processQueue，延迟提交该 processQueue 上的顺序消费任务到线程池</p>
<ul>
<li>最大重试次数取 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#maxReconsumeTimes，默认-1，会转成 Integer.MAX_VALUE，表示会一直重试</li>
<li>本地延迟消费的延时时间默认 1s，取 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#suspendCurrentQueueTimeMillis。可以通过 org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext#suspendCurrentQueueTimeMillis 字段修改</li>
<li>并发消费失败的消息，重投递回 broker，不是提交延时任务本地重新消费</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">case SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">    this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">    if (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">        consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs);</span><br><span class="line">        this.submitConsumeRequestLater(</span><br><span class="line">            consumeRequest.getProcessQueue(),</span><br><span class="line">            consumeRequest.getMessageQueue(),</span><br><span class="line">            context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">        continueConsume = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<h5 id="拉取消息请求放回阻塞队列"><a href="#拉取消息请求放回阻塞队列" class="headerlink" title="拉取消息请求放回阻塞队列"></a>拉取消息请求放回阻塞队列</h5><p>提交消费任务后，消息拉取请求放到阻塞队列，由拉取线程从阻塞队列取出请求，再次向 broker 发起请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 消息拉取请求放到阻塞队列，由拉取线程轮询阻塞队列再次向broker发起请求</span><br><span class="line">if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动负载均衡线程"><a href="#启动负载均衡线程" class="headerlink" title="启动负载均衡线程"></a>启动负载均衡线程</h3><p>负载均衡线程默认每隔 20s 执行一次负载 mq 的负载均衡</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override public void run() &#123;</span><br><span class="line">    log.info(this.getServiceName() + &quot; service started&quot;);</span><br><span class="line"></span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        this.waitForRunning(waitInterval);</span><br><span class="line">        this.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按 consumer 实例订阅的 topic 所属 mq 维度执行负载均衡策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void doRebalance() &#123;</span><br><span class="line">    for (Map.Entry&lt;String, MQConsumerInner&gt; entry : this.consumerTable.entrySet()) &#123;</span><br><span class="line">        MQConsumerInner impl = entry.getValue();</span><br><span class="line">        if (impl != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;doRebalance exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void doRebalance(final boolean isOrder) &#123;</span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span><br><span class="line">    if (subTable != null) &#123;</span><br><span class="line">        for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            final String topic = entry.getKey();</span><br><span class="line">            try &#123;</span><br><span class="line">                this.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(&quot;rebalanceByTopic Exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取存储 topic 消息的所有 messageQueue</p>
<ul>
<li>topic 的路由信息是定时请求 ns 获取到的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// topicSubscribeInfoTable存储的是定时从ns拿到的topic路由信息，即存储topic消息的所有messageQueue</span><br><span class="line">Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic);</span><br></pre></td></tr></table></figure>

<p>随机请求存储 topic 消息的一台 broker，获取同 consumerGroup 下所有客户端的 clientId</p>
<ul>
<li>所有订阅该 topic 的 consumer 都会通过心跳消息向所有存储 topic 消息的 broker 上报 ConsumerGroup 信息，因此通过 broker 能拿到 ConsumerGroup 中的所有 clientId</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 随机取存储topic消息的一个broker，通过它获取当前consumer所在Group中所有consumer客户端的clientId</span><br><span class="line">List&lt;String&gt; cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br></pre></td></tr></table></figure>

<p>按 mqClient 均分的方式为 consumer 消费的 topic 分配 messageQueue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 均分算法，如果consumer数量超过messageQueue数量，超过部分的consumer实例不消费messageQueue</span><br><span class="line"> * 返回分配到的messageQueue</span><br><span class="line"> */</span><br><span class="line">int index = cidAll.indexOf(currentCID);</span><br><span class="line">int mod = mqAll.size() % cidAll.size();</span><br><span class="line">int averageSize = mqAll.size() &lt;= cidAll.size() ? 1 : (mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size());</span><br><span class="line">int startIndex = (mod &gt; 0 &amp;&amp; index &lt; mod) ? index * averageSize: index * averageSize + mod;</span><br><span class="line">int range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">for (int i = 0; i &lt; range; i++) &#123;</span><br><span class="line">    result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>

<p>如果负载均衡分配的 messageQueue 在 mqClient 上还没有 processQueue，创建与 messageQueue 映射的 processQueue，然后构建该 messageQueue 上的消息拉取请求，放入阻塞队列</p>
<ul>
<li>如果之前已经缓存了该 topic 的 messageQueue，会比对之前的 messageQueue 是否依然在该 topic 新分配的 messageQueue 里，如果不在，认为之前分配的 messageQueue 失效并 remove，同时 drop 对应的 processQueue</li>
<li>如果 consumerGroup 顺序消费 topic 消息，创建 ProcessQueue 前，一定要用 ConsumerGroup 中的当前 client 锁住 messageQueue，否则不能拉取消息。应该是担心万一 messageQueue 已被别的 consumerClient 占据，造成多个 consumer 同时消费一个 messageQueue 产生乱序消费</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.processQueueTable.entrySet().iterator();</span><br><span class="line">...</span><br><span class="line">// messageQueue的topic与consumer订阅的topic相同，说明是之前已经负载均衡后给consumer分配的messageQueue</span><br><span class="line">// 但messageQueue不在最新负载均衡分配的mqs里，说明broker上的messageQueue有调整，之前的messageQueue失效，需要remove，并drop对应的processQueue</span><br><span class="line">if (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">    if (!mqSet.contains(mq)) &#123;</span><br><span class="line">    pq.setDropped(true);</span><br><span class="line">    if (this.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// mqSet：负载均衡器给当前consumer实例分配的messageQueueSet</span><br><span class="line">for (MessageQueue mq : mqSet) &#123;</span><br><span class="line">    // 如果最新负载均衡分配的messageQueue在mqClient没有对应的processQueue，初始化processQueue，然后构建消息拉取请求，拉取messageQueue里的消息</span><br><span class="line">    if (!this.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">        ProcessQueue pq = new ProcessQueue();</span><br><span class="line">        // 获取从messageQueue拉取消息的起始位点</span><br><span class="line">        long nextOffset = this.computePullFromWhere(mq);</span><br><span class="line">        if (nextOffset &gt;= 0) &#123;</span><br><span class="line">            // 初始化缓存队列，映射分配的messageQueue</span><br><span class="line">            ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">            if (pre != null) &#123;</span><br><span class="line">                log.info(&quot;doRebalance, &#123;&#125;, mq already exists, &#123;&#125;&quot;, consumerGroup, mq);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 初始化后，构建消息拉取请求，拉取messageQueue里的消息</span><br><span class="line">                log.info(&quot;doRebalance, &#123;&#125;, add a new mq, &#123;&#125;&quot;, consumerGroup, mq);</span><br><span class="line">                PullRequest pullRequest = new PullRequest();</span><br><span class="line">                pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                pullRequest.setMessageQueue(mq);</span><br><span class="line">                pullRequest.setProcessQueue(pq);</span><br><span class="line">                pullRequestList.add(pullRequest);</span><br><span class="line">                changed = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 消息拉取请求放入阻塞队列</span><br><span class="line">this.dispatchPullRequest(pullRequestList);</span><br></pre></td></tr></table></figure>

<h3 id="更新-mqClient-的状态"><a href="#更新-mqClient-的状态" class="headerlink" title="更新 mqClient 的状态"></a>更新 mqClient 的状态</h3><p>producer 所属 mqClient 的 serviceState 变为 RUNNING，表示 producer 实例启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.serviceState = ServiceState.RUNNING;</span><br></pre></td></tr></table></figure>

<h1 id="启动-consumer-实例"><a href="#启动-consumer-实例" class="headerlink" title="启动 consumer 实例"></a>启动 consumer 实例</h1><p>启动 consumer 实例和启动 producer 实例基本类似。启动方法入口：org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#start</p>
<h2 id="构建-SubscriptionData"><a href="#构建-SubscriptionData" class="headerlink" title="构建 SubscriptionData"></a>构建 SubscriptionData</h2><p>构建 consumer 的订阅信息 SubscriptionData，放入它的负载均衡器 RebalanceImpl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void copySubscription() throws MQClientException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Map &lt; String,</span><br><span class="line">        String &gt; sub = this.defaultMQPushConsumer.getSubscription();</span><br><span class="line">        if (sub != null) &#123;</span><br><span class="line">            for (final Map.Entry &lt; String, String &gt; entry: sub.entrySet()) &#123;</span><br><span class="line">                final String topic = entry.getKey();</span><br><span class="line">                final String subString = entry.getValue();</span><br><span class="line">                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), topic, subString);</span><br><span class="line">                this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化-mqClient-1"><a href="#实例化-mqClient-1" class="headerlink" title="实例化 mqClient"></a>实例化 mqClient</h2><p>同 producer</p>
<h2 id="实例化-offsetStore"><a href="#实例化-offsetStore" class="headerlink" title="实例化 offsetStore"></a>实例化 offsetStore</h2><p>实例化 offsetStore，存储在 mq 上的下一条待消费消息的 offset。如果是广播模式，本地持久化 offset 即可，如果是集群模式，需要同步给 broker，目的是重新负载均衡新的消费者机器绑定 mq 后，broker 能知道该从哪个消息开始继续消费</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (this.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">case BROADCASTING:</span><br><span class="line">    this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    break;</span><br><span class="line">case CLUSTERING:</span><br><span class="line">    this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化消息消费服务"><a href="#实例化消息消费服务" class="headerlink" title="实例化消息消费服务"></a>实例化消息消费服务</h2><p>根据业务 listener 是并发消费类型还是顺序消费类型，创建对应的消息消费服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (this.getMessageListenerInner() instanceof MessageListenerOrderly) &#123;</span><br><span class="line">    this.consumeOrderly = true;</span><br><span class="line">    this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span><br><span class="line">&#125; else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) &#123;</span><br><span class="line">    this.consumeOrderly = false;</span><br><span class="line">    this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动消息消费服务的定时任务"><a href="#启动消息消费服务的定时任务" class="headerlink" title="启动消息消费服务的定时任务"></a>启动消息消费服务的定时任务</h2><p>针对消费服务，启动辅助的定时任务</p>
<h3 id="并发消费的定时任务"><a href="#并发消费的定时任务" class="headerlink" title="并发消费的定时任务"></a>并发消费的定时任务</h3><p>该定时任务延时 15 分钟后，每隔 15 分钟执行一次。该任务定时清理消费超时的消息，消费超时阈值默认 15 分钟，所以定时任务的周期如此设置</p>
<ul>
<li>消费超时的阈值由 org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#consumeTimeout 控制，默认 15 分钟</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override public void run() &#123;</span><br><span class="line">            cleanExpireMsg();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理消费超时消息的具体流程：<br>遍历 processQueue 里的消息，如果业务 listener 对消息的消费时间超过阈值，默认 15 分钟，将消息发回 broker 做延时投递重新消费，然后从 processQueue 里移除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) &#123;</span><br><span class="line">    if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int loop = msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16;</span><br><span class="line">    for (int i = 0; i &lt; loop; i++) &#123;</span><br><span class="line">        MessageExt msg = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.lockTreeMap.readLock().lockInterruptibly();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 如果业务listener消费消息的时间超过了阈值，将消息发回broker</span><br><span class="line">                if (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * 60 * 1000) &#123;</span><br><span class="line">                    msg = msgTreeMap.firstEntry().getValue();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                this.lockTreeMap.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            pushConsumer.sendMessageBack(msg, 3);</span><br><span class="line">            log.info(&quot;send expire msg back. topic=&#123;&#125;, msgId=&#123;&#125;, storeHost=&#123;&#125;, queueId=&#123;&#125;, queueOffset=&#123;&#125;&quot;, msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());</span><br><span class="line">            try &#123;</span><br><span class="line">                this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            removeMessage(Collections.singletonList(msg));</span><br><span class="line">                        &#125; catch(Exception e) &#123;</span><br><span class="line">                            log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    this.lockTreeMap.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(InterruptedException e) &#123;</span><br><span class="line">                log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序消费的定时任务"><a href="#顺序消费的定时任务" class="headerlink" title="顺序消费的定时任务"></a>顺序消费的定时任务</h3><p>默认 20s 执行一次，定时对 broker 上的 messageQueue 发起加锁请求，加锁成功的 mq 对应的 processQueue，置 locked 字段为 true。这么做是为了确保 mqClient 和 mq 的唯一绑定关系，确保 mq 上的消息在 consumerGroup 能被顺序消费</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    // 集群模式顺序消费时，client定时对broker上的messageQueue加锁，对加锁成功的mq对应的processQueue，置locked字段为true</span><br><span class="line">    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;@Override public void run() &#123;</span><br><span class="line">                ConsumeMessageOrderlyService.this.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void lockAll() &#123;</span><br><span class="line">    HashMap &lt; String,</span><br><span class="line">    Set &lt; MessageQueue &gt;&gt; brokerMqs = this.buildProcessQueueTableByBrokerName();</span><br><span class="line"></span><br><span class="line">    Iterator &lt; Entry &lt; String,</span><br><span class="line">    Set &lt; MessageQueue &gt;&gt;&gt; it = brokerMqs.entrySet().iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        Entry &lt; String,</span><br><span class="line">        Set &lt; MessageQueue &gt;&gt; entry = it.next();</span><br><span class="line">        final String brokerName = entry.getKey();</span><br><span class="line">        final Set &lt; MessageQueue &gt; mqs = entry.getValue();</span><br><span class="line"></span><br><span class="line">        if (mqs.isEmpty()) continue;</span><br><span class="line"></span><br><span class="line">        FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(brokerName, MixAll.MASTER_ID, true);</span><br><span class="line">        if (findBrokerResult != null) &#123;</span><br><span class="line">            LockBatchRequestBody requestBody = new LockBatchRequestBody();</span><br><span class="line">            requestBody.setConsumerGroup(this.consumerGroup);</span><br><span class="line">            requestBody.setClientId(this.mQClientFactory.getClientId());</span><br><span class="line">            requestBody.setMqSet(mqs);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Set &lt; MessageQueue &gt; lockOKMQSet = this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);</span><br><span class="line"></span><br><span class="line">                for (MessageQueue mq: lockOKMQSet) &#123;</span><br><span class="line">                    ProcessQueue processQueue = this.processQueueTable.get(mq);</span><br><span class="line">                    if (processQueue != null) &#123;</span><br><span class="line">                        if (!processQueue.isLocked()) &#123;</span><br><span class="line">                            log.info(&quot;the message queue locked OK, Group: &#123;&#125; &#123;&#125;&quot;, this.consumerGroup, mq);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        processQueue.setLocked(true);</span><br><span class="line">                        processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (MessageQueue mq: mqs) &#123;</span><br><span class="line">                    if (!lockOKMQSet.contains(mq)) &#123;</span><br><span class="line">                        ProcessQueue processQueue = this.processQueueTable.get(mq);</span><br><span class="line">                        if (processQueue != null) &#123;</span><br><span class="line">                            processQueue.setLocked(false);</span><br><span class="line">                            log.warn(&quot;the message queue locked Failed, Group: &#123;&#125; &#123;&#125;&quot;, this.consumerGroup, mq);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                log.error(&quot;lockBatchMQ exception, &quot; + mqs, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="consumer-注册到-mqClient"><a href="#consumer-注册到-mqClient" class="headerlink" title="consumer 注册到 mqClient"></a>consumer 注册到 mqClient</h2><p>同 producer</p>
<h2 id="启动-MQClientInstance-1"><a href="#启动-MQClientInstance-1" class="headerlink" title="启动 MQClientInstance"></a>启动 MQClientInstance</h2><p>同 producer</p>
<h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><h2 id="Broker-如何做消息持久化"><a href="#Broker-如何做消息持久化" class="headerlink" title="Broker 如何做消息持久化"></a>Broker 如何做消息持久化</h2><p>先说结论：</p>
<ul>
<li>消息持久化的流程是：先写内核缓冲区 PageCache–&gt;再把数据刷盘到文件</li>
<li>broker 将消息顺序写入 commitLog 文件。超过 1G 后自动创建新文件，文件名为当前偏移量 offset</li>
<li>写入 commitLog 后，broker 会把消息的索引信息放到 messageQueue 里。索引信息包括：commitLogOffset+msgSize+tagsHashCode，共 20 字节<ul>
<li>broker 处理 consumer 的消息拉取请求时，如果 messageQueue 里存在 request.nextOffset 偏移量后面的消息，且消息的 tagsHashCode 在 group 的订阅信息里，或者消息满足 consumer 端的 sql 表达式，则通过 commitLogOffset+msgSize 到 commitLog 里取出消息体，发送给 consumer</li>
<li>获取消息需要先读 messageQueue 再读 commitLog，但不会影响性能。因为 Linux 的 PageCache 技术，读写磁盘文件的数据都会缓存到 PageCache 缓存，且 messageQueue 只包含索引信息，占用的字节更少（每个消息 20 字节），所以 PageCache 可以缓存更多的 messageQueue，对它的读取接近直接从内存获取</li>
</ul>
</li>
</ul>
<p>消息持久化的入口：<br>org.apache.rocketmq.store.MappedFile#appendMessagesInner</p>
<h3 id="写入内核缓冲区"><a href="#写入内核缓冲区" class="headerlink" title="写入内核缓冲区"></a>写入内核缓冲区</h3><p>先将消息写入内核缓冲区 PageCache</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);</span><br></pre></td></tr></table></figure>

<p>这里需要说明的是，buteBuffer 使用了 java nio 里的 DirectByteBuffer，该对象是 java 程序对内核缓冲区的引用，通过它可以直接操作内核缓冲区，减少了用户空间（java 堆内存）到内核缓冲区的数据拷贝，提高了 io 读写性能。这也是我们常说的零拷贝技术。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">    for (int i = 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</span><br><span class="line"></span><br><span class="line">        final long address = ((DirectBuffer) byteBuffer).address();</span><br><span class="line">        Pointer pointer = new Pointer(address);</span><br><span class="line">        LibC.INSTANCE.mlock(pointer, new NativeLong(fileSize));</span><br><span class="line"></span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h3><p>刷盘即 PageCache 缓存的数据刷入磁盘文件。有两种实现方式：</p>
<ul>
<li>将 DirectByteBuffer 指向的 PageCache 的数据提交到 FileChannel。FileChannel 把数据给到操作系统进行文件修改</li>
<li>调用 java.nio.MappedByteBuffer#force，不通过 FileChannel 直接将 PageCache 的数据映射到文件，这种是针对超大文件的一种优化。还不太了解原理</li>
</ul>
<p>刷盘策略也分为同步刷盘和异步刷盘，他们的共同点都是唤醒异步刷盘线程执行刷盘操作，区别是同步刷盘阻塞等待刷盘线程的结果，异步刷盘只唤醒刷盘线程就结束了</p>
<ul>
<li>GroupCommitService：同步刷盘，基于 MappedByteBuffer<ul>
<li>同步刷盘的线程阻塞在 flushOkFuture.get 方法，等待刷盘结果再返回</li>
</ul>
</li>
<li>CommitRealTimeService：异步刷盘，基于 DirectByteBuffer<ul>
<li>异步刷盘只是 wakeUp 刷盘线程，底层 countDown 唤醒，开始刷盘</li>
</ul>
</li>
<li>FlushRealTimeService：异步刷盘，基于 MappedByteBuffer<ul>
<li>异步刷盘只是 wakeUp 刷盘线程，底层 countDown 唤醒，开始刷盘</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void handleDiskFlush(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt) &#123;</span><br><span class="line">    // Synchronization flush</span><br><span class="line">    if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;</span><br><span class="line">        if (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            GroupCommitRequest request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">            service.putRequest(request);</span><br><span class="line">            CompletableFuture&lt;PutMessageStatus&gt; flushOkFuture = request.future();</span><br><span class="line">            PutMessageStatus flushStatus = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                flushStatus = flushOkFuture.get(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(),</span><br><span class="line">                        TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">                //flushOK=false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                log.error(&quot;do groupcommit, wait for flush failed, topic: &quot; + messageExt.getTopic() + &quot; tags: &quot; + messageExt.getTags()</span><br><span class="line">                    + &quot; client address: &quot; + messageExt.getBornHostString());</span><br><span class="line">                putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            service.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Asynchronous flush</span><br><span class="line">    else &#123;</span><br><span class="line">        if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            // FlushRealTimeService</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // CommitRealTimeService</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是同步刷盘策略，会把一个组提交 GroupCommitRequest 请求放到 GroupCommitService 的写列表里。然后执行 countDown 方法唤醒同步刷盘线程</p>
<ul>
<li>GroupCommitRequest 指定了消息在 PageCache 的 offset，该 offset 之前的数据都可以刷到磁盘里</li>
<li>GroupCommitService 是一个守护线程，负责执行列表里的组提交刷盘请求</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private volatile List&lt;GroupCommitRequest&gt; requestsWrite = new ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line">private volatile List&lt;GroupCommitRequest&gt; requestsRead = new ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line"></span><br><span class="line">public synchronized void putRequest(final GroupCommitRequest request) &#123;</span><br><span class="line">    synchronized (this.requestsWrite) &#123;</span><br><span class="line">        this.requestsWrite.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    this.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void wakeup() &#123;</span><br><span class="line">    if (hasNotified.compareAndSet(false, true)) &#123;</span><br><span class="line">        waitPoint.countDown(); // notify</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒线程后，先交换 GroupCommitService 的读写列表。相当于清空了写列表，它可以继续添加新的组提交请求。刷盘遍历的是读列表里的组提交请求，然后执行底层的刷盘操作</p>
<ul>
<li>两个列表交替使用，读列表被加锁刷盘时，写列表可以继续用于添加请求。效率较高</li>
<li>刷盘结束条件：刷两次或者刷盘请求指定的 offset 位置已经刷到磁盘了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void swapRequests() &#123;</span><br><span class="line">    List&lt;GroupCommitRequest&gt; tmp = this.requestsWrite;</span><br><span class="line">    this.requestsWrite = this.requestsRead;</span><br><span class="line">    this.requestsRead = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doCommit() &#123;</span><br><span class="line">    synchronized (this.requestsRead) &#123;</span><br><span class="line">        if (!this.requestsRead.isEmpty()) &#123;</span><br><span class="line">            for (GroupCommitRequest req : this.requestsRead) &#123;</span><br><span class="line">                // There may be a message in the next file, so a maximum of</span><br><span class="line">                // two times the flush</span><br><span class="line">                boolean flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                for (int i = 0; i &lt; 2 &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">                    flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                req.wakeupCustomer(flushOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            if (storeTimestamp &gt; 0) &#123;</span><br><span class="line">                CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.requestsRead.clear();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Because of individual messages is set to not sync flush, it</span><br><span class="line">            // will come to this process</span><br><span class="line">            CommitLog.this.mappedFileQueue.flush(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int flush(final int flushLeastPages) &#123;</span><br><span class="line">    if (this.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        if (this.hold()) &#123;</span><br><span class="line">            int value = getReadPosition();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //We only append data to fileChannel or mappedByteBuffer, never both.</span><br><span class="line">                if (writeBuffer != null || this.fileChannel.position() != 0) &#123;</span><br><span class="line">                    this.fileChannel.force(false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;Error occurred when force data to disk.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.flushedPosition.set(value);</span><br><span class="line">            this.release();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.warn(&quot;in flush, hold failed, flush offset = &quot; + this.flushedPosition.get());</span><br><span class="line">            this.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mqFlush.png"></p>
<h2 id="Broker-处理-Consumer-拉取消息请求"><a href="#Broker-处理-Consumer-拉取消息请求" class="headerlink" title="Broker 处理 Consumer 拉取消息请求"></a>Broker 处理 Consumer 拉取消息请求</h2><p>入口：org.apache.rocketmq.broker.processor.PullMessageProcessor#processRequest(io.netty.channel.ChannelHandlerContext, org.apache.rocketmq.remoting.protocol.RemotingCommand)</p>
<h3 id="构建-MessageFilter"><a href="#构建-MessageFilter" class="headerlink" title="构建 MessageFilter"></a>构建 MessageFilter</h3><p>根据 request 里的 consumerGroup 订阅信息构建消息过滤 MessageFilter 对象。该对象主要包含 2 个用于消息过滤的成员变量：</p>
<ul>
<li>SubscriptionData，它包含了 tagsHashCodeSet，通过它完成基于 tag 的过滤</li>
<li>ConsumerFilterData，它使用布隆过滤器存储 consumerGroup+topic 映射的 bit 数组。通过它做基于 sql 表达式的过滤<ul>
<li>每条消息在 messageQueue 扩展队列里会存储所有通过 sql 校验的 consumerGroup 组成的布隆过滤器 bit 数组。这个大 bit 数组是在消息持久化过程中计算并存储到 messageQueue 的扩展队列<ul>
<li>如果当前 bit 数组不包含在这个大数组中，说明这条消息一定不能满足 sql 表达式</li>
<li>如果包含，说明这条消息可能满足 sql 表达式（因为布隆过滤器可能误判），再执行一次 sql 表达式来验证。通过布隆过滤器，能提升 consumer 消息拉取的性能，不用每条消息都执行一遍 sql 表达式来验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageFilter messageFilter;</span><br><span class="line">if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">    messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        this.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        this.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找到-MessageQueue"><a href="#找到-MessageQueue" class="headerlink" title="找到 MessageQueue"></a>找到 MessageQueue</h3><blockquote>
<p>实际要找的是：存储 MessageQueue 的所有文件在内存 PageCache 里的映射对象</p>
</blockquote>
<p>broker 为每个 topic 创建多个 messageQueue。每个 MessageQueue 对应一个包含 topic+messageQueueId 的路径，该路径下会创建多个文件，存储消息的索引和过滤信息</p>
<ul>
<li>每条消息在 messageQueue 上占 20 字节：commitLogOffset、msgSize、消息在 MessageQueue 扩展队列的地址</li>
<li>每个文件大小 mappedFileSize 默认为 20 字节*30W，即每个文件最多存储 30W 条消息</li>
<li>每条消息在扩展对列上存储：所有通过 sql 校验的 consumerGroup 组成的布隆过滤器 bit 数组、消息的 tagsHashCode</li>
</ul>
<p>按 topic+queueId 查内存，获取 MessageQueue。它主要封装了 MappedFileQueue，表示实际存储 MessageQueue 的路径下所有文件的 PageCache 缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ConsumeQueue &#123;</span><br><span class="line">    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    // messageQueue上的每条消息的大小，20字节=commitLogOffset+msgSize+tagsHashCode</span><br><span class="line">    public static final int CQ_STORE_UNIT_SIZE = 20;</span><br><span class="line"></span><br><span class="line">    private final MappedFileQueue mappedFileQueue;</span><br><span class="line">    private final String topic;</span><br><span class="line">    private final int queueId;</span><br><span class="line"></span><br><span class="line">    private final String storePath;</span><br><span class="line">    // 默认20字节*30W，即一个MessageQueue最多存储30W条消息</span><br><span class="line">    private final int mappedFileSize;</span><br><span class="line"></span><br><span class="line">    public ConsumeQueue(final String topic, final int queueId, final String storePath, final int mappedFileSize, final DefaultMessageStore defaultMessageStore) &#123;</span><br><span class="line">        this.storePath = storePath;</span><br><span class="line">        this.mappedFileSize = mappedFileSize;</span><br><span class="line">        this.defaultMessageStore = defaultMessageStore;</span><br><span class="line"></span><br><span class="line">        this.topic = topic;</span><br><span class="line">        this.queueId = queueId;</span><br><span class="line"></span><br><span class="line">        String queueDir = this.storePath + File.separator + topic + File.separator + queueId;</span><br><span class="line"></span><br><span class="line">        this.mappedFileQueue = new MappedFileQueue(queueDir, mappedFileSize, null);</span><br><span class="line"></span><br><span class="line">        this.byteBufferIndex = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">        if (defaultMessageStore.getMessageStoreConfig().isEnableConsumeQueueExt()) &#123;</span><br><span class="line">            this.consumeQueueExt = new ConsumeQueueExt(topic, queueId, StorePathConfigHelper.getStorePathConsumeQueueExt(defaultMessageStore.getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore.getMessageStoreConfig().getMappedFileSizeConsumeQueueExt(), defaultMessageStore.getMessageStoreConfig().getBitMapLengthConsumeQueueExt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ConsumeQueue findConsumeQueue(String topic, int queueId) &#123;</span><br><span class="line">    ConcurrentMap&lt;Integer, ConsumeQueue&gt; map = consumeQueueTable.get(topic);</span><br><span class="line">    if (null == map) &#123;</span><br><span class="line">        ConcurrentMap&lt;Integer, ConsumeQueue&gt; newMap = new ConcurrentHashMap&lt;Integer, ConsumeQueue&gt;(128);</span><br><span class="line">        ConcurrentMap&lt;Integer, ConsumeQueue&gt; oldMap = consumeQueueTable.putIfAbsent(topic, newMap);</span><br><span class="line">        if (oldMap != null) &#123;</span><br><span class="line">            map = oldMap;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumeQueue logic = map.get(queueId);</span><br><span class="line">    … …</span><br><span class="line">    return logic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位在-MessageQueue-的起始消费位置"><a href="#定位在-MessageQueue-的起始消费位置" class="headerlink" title="定位在 MessageQueue 的起始消费位置"></a>定位在 MessageQueue 的起始消费位置</h3><p>根据 request 传入的起始消息 offset，先定位具体存储该条消息的文件的 PageCache，再计算 offset 在该文件的起始字节位置，返回从该位置开始的 ByteBuffer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public SelectMappedBufferResult getIndexBuffer(final long startIndex) &#123;</span><br><span class="line">    int mappedFileSize = this.mappedFileSize;</span><br><span class="line">    long offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line">    if (offset &gt;= this.getMinLogicOffset()) &#123;</span><br><span class="line">        // 根据offset到MassageQueue的文件列表里拿到存储该条消息的文件，返回该文件映射的PageCache对象MappedFile</span><br><span class="line">        MappedFile mappedFile = this.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class="line">        if (mappedFile != null) &#123;</span><br><span class="line">            // offset % mappedFileSize 是该条消息在文件里的起始字节位置，返回从该位置开始的ByteBuffer</span><br><span class="line">            SelectMappedBufferResult result = mappedFile.selectMappedBuffer((int) (offset % mappedFileSize));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定位是哪个文件其实很简单，根据 offset 计算消息存储在哪个字节处（offset*20，20 为每条消息的存储空间），然后除每个文件的最大字节数（20 字节*30W）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line">... ...</span><br><span class="line">int index = (int) ((offset / this.mappedFileSize) - (firstMappedFile.getFileFromOffset() / this.mappedFileSize));</span><br></pre></td></tr></table></figure>

<p>定位在文件上的起始字节位置也同理，对单个文件最大字节数取余即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectMappedBufferResult result = mappedFile.selectMappedBuffer((int) (offset % mappedFileSize));</span><br></pre></td></tr></table></figure>

<h3 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h3><p>拿到起始位置的 ByteBuffer 后，每 20 字节开始读取消息在 ByteBuffer 上的索引和过滤信息</p>
<ul>
<li>注意，tagsCode 实际为消息在扩展队列的地址，tagsCode 和所有通过 sql 过滤的布隆过滤器 bit 数组都存储在扩展队列</li>
<li>最多读取消息数可以在 request 里指定，如果不指定默认为 16000&#x2F;20 &#x3D; 800。当然还没读到这些消息 messageQueue 就读完了也会退出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">... ...</span><br><span class="line">for (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">    long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">    int sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">    long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用此次消息拉取请求的消息过滤器 MessageFilter，判断消息是否满足过滤条件。实际调用方法为：org.apache.rocketmq.broker.filter.ExpressionMessageFilter#isMatchedByConsumeQueue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (messageFilter != null</span><br><span class="line">        // 消息是否满足tag过滤和sql过滤</span><br><span class="line">    &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) &#123;</span><br><span class="line">    if (getResult.getBufferTotalSize() == 0) &#123;</span><br><span class="line">        status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 tag 或者基于 sql 的消息过滤规则上面说过了，代码也很清晰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) &#123;</span><br><span class="line">    if (null == subscriptionData) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (subscriptionData.isClassFilterMode()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // by tags code.</span><br><span class="line">    if (ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line"></span><br><span class="line">        if (tagsCode == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return subscriptionData.getCodeSet().contains(tagsCode.intValue());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // no expression or no bloom</span><br><span class="line">        if (consumerFilterData == null || consumerFilterData.getExpression() == null</span><br><span class="line">            || consumerFilterData.getCompiledExpression() == null || consumerFilterData.getBloomFilterData() == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // message is before consumer</span><br><span class="line">        if (cqExtUnit == null || !consumerFilterData.isMsgInLive(cqExtUnit.getMsgStoreTime())) &#123;</span><br><span class="line">            log.debug(&quot;Pull matched because not in live: &#123;&#125;, &#123;&#125;&quot;, consumerFilterData, cqExtUnit);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] filterBitMap = cqExtUnit.getFilterBitMap();</span><br><span class="line">        BloomFilter bloomFilter = this.consumerFilterManager.getBloomFilter();</span><br><span class="line">        if (filterBitMap == null || !this.bloomDataValid</span><br><span class="line">            || filterBitMap.length * Byte.SIZE != consumerFilterData.getBloomFilterData().getBitNum()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BitsArray bitsArray = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bitsArray = BitsArray.create(filterBitMap);</span><br><span class="line">            // 如果consumerGroup的布隆过滤bit数组在所有满足sql的consumerGroup组成的布隆过滤bit数组中，则认为sql过滤通过</span><br><span class="line">            // （可能误判，还需要实际执行sql表达式来判断是否满足）</span><br><span class="line">            boolean ret = bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray);</span><br><span class="line">            log.debug(&quot;Pull &#123;&#125; by bit map:&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, ret, consumerFilterData, bitsArray, cqExtUnit);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.error(&quot;bloom filter error, sub=&quot; + subscriptionData</span><br><span class="line">                + &quot;, filter=&quot; + consumerFilterData + &quot;, bitMap=&quot; + bitsArray, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 MessageFilter 过滤通过了，从 commitLog 里取出实际的消息体内存映射 MappedByteBuffer。取的逻辑和上面 MessageQueue 一样，先根据 commitLogOffset 做除法定位文件，然后取余定位具体内存位置</p>
<ul>
<li>CommitLog 每个文件大小默认为 1G</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public SelectMappedBufferResult getMessage(final long offset, final int size) &#123;</span><br><span class="line">    int mappedFileSize = this.defaultMessageStore.getMessageStoreConfig().getMappedFileSizeCommitLog();</span><br><span class="line">    MappedFile mappedFile = this.mappedFileQueue.findMappedFileByOffset(offset, offset == 0);</span><br><span class="line">    if (mappedFile != null) &#123;</span><br><span class="line">        int pos = (int) (offset % mappedFileSize);</span><br><span class="line">        return mappedFile.selectMappedBuffer(pos, size);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到实际消息体后，如果按 sql 过滤，还要实际执行一遍 sql 表达式来确认是否满足，因为布隆过滤器可能误判</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map&lt;String, String&gt; properties) &#123;</span><br><span class="line">    if (subscriptionData == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (subscriptionData.isClassFilterMode()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumerFilterData realFilterData = this.consumerFilterData;</span><br><span class="line">    Map&lt;String, String&gt; tempProperties = properties;</span><br><span class="line"></span><br><span class="line">    // no expression</span><br><span class="line">    if (realFilterData == null || realFilterData.getExpression() == null</span><br><span class="line">        || realFilterData.getCompiledExpression() == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tempProperties == null &amp;&amp; msgBuffer != null) &#123;</span><br><span class="line">        tempProperties = MessageDecoder.decodeProperties(msgBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object ret = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        MessageEvaluationContext context = new MessageEvaluationContext(tempProperties);</span><br><span class="line">        // 执行sql表达式判断消息是否真的满足过滤条件，因为布隆过滤器可能误判</span><br><span class="line">        ret = realFilterData.getCompiledExpression().evaluate(context);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        log.error(&quot;Message Filter error, &quot; + realFilterData + &quot;, &quot; + tempProperties, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(&quot;Pull eval result: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, ret, realFilterData, tempProperties);</span><br><span class="line"></span><br><span class="line">    if (ret == null || !(ret instanceof Boolean)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (Boolean) ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置下次 consumer 拉取消息的起始 offset。i 为这次读到的内存位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 更新下次消息拉取的起始offset。for循环读取messageQueue消息时做了计数，所以下次拉取消息的offset就是这次的offset加上计数器的值</span><br><span class="line">nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br></pre></td></tr></table></figure>

<p>遍历完 MessageQueue 后，把满足条件的消息从 MappedByteBuffer 移到堆内存，然后转成字节数组赋值给 response</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 把消息在PageCache的缓存数据读取到堆内存，转成字节数组，放到响应的body里</span><br><span class="line">final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br></pre></td></tr></table></figure>

<h3 id="如果没拉取到消息"><a href="#如果没拉取到消息" class="headerlink" title="如果没拉取到消息"></a>如果没拉取到消息</h3><p>遍历完 MessageQueue 后如果没有符合过滤条件的消息，broker 会把请求挂起，这时不会发送响应给 consumer。<br>如果 broker 支持长轮训，挂起的时间为 consumer 发送请求时指定的时间。如果不支持长轮训，则使用短轮训，默认挂起 1s。</p>
<ul>
<li>所谓挂起，是把 consumerGroup 在该 messageQueue 上的消息拉取请求存到 map 里</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果没有满足条件的新消息，把consumer的请求缓存起来，然后返回null，此时不会给consumer发送响应</span><br><span class="line">this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) &#123;</span><br><span class="line">    String key = this.buildKey(topic, queueId);</span><br><span class="line">    ManyPullRequest mpr = this.pullRequestTable.get(key);</span><br><span class="line">    if (null == mpr) &#123;</span><br><span class="line">        mpr = new ManyPullRequest();</span><br><span class="line">        ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            mpr = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpr.addPullRequest(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>broker 会有一个守护线程 PullRequestHoldService，如果支持长轮训，5s 执行一次，处理所有挂起的请求，如果是短轮询，1s 执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    log.info(&quot;&#123;&#125; service started&quot;, this.getServiceName());</span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                this.waitForRunning(5 * 1000);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long beginLockTimestamp = this.systemClock.now();</span><br><span class="line">            this.checkHoldRequest();</span><br><span class="line">            long costTime = this.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            if (costTime &gt; 5 * 1000) &#123;</span><br><span class="line">                log.info(&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;&#123;&#125; service end&quot;, this.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理挂起请求的逻辑是：<br>如果 messageQueue 在 hold 开始后又有新消息，或者超过最大 hold 时长，发送消息拉取结果给 consumer，让它发送新的请求过来，从新的 beginOffset 开始继续拉取消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">    	… …</span><br><span class="line">        try &#123;</span><br><span class="line">            this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                request.getRequestCommand());</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.error(&quot;execute request when wakeup failed.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">            request.getRequestCommand());</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        log.error(&quot;execute request when wakeup failed.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>西米大人
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://dcbupt.github.io/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0rocketmq%E6%BA%90%E7%A0%81/" title="系统学习rocketmq源码">http://dcbupt.github.io/2020/05/26/blog_article/系统学习系列/系统学习rocketmq源码/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        

<blockquote class="blockquote-center" style="color: #f0ad4e">完 ♥ 结</blockquote>



        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/21/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0CQRS%E5%92%8CEventSourcing/" rel="prev" title="系统学习CQRS和EventSourcing">
      <i class="fa fa-chevron-left"></i> 系统学习CQRS和EventSourcing
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/26/blog_article/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Netty/" rel="next" title="系统学习Netty">
      系统学习Netty <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="nav-number">1.</span> <span class="nav-text">架构图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E5%86%8C-rocketmq-%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">客户端注册 rocketmq 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-producer"><span class="nav-number">2.1.</span> <span class="nav-text">注册 producer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-consumer"><span class="nav-number">2.2.</span> <span class="nav-text">注册 consumer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-RocketMQTemplate"><span class="nav-number">2.3.</span> <span class="nav-text">注册 RocketMQTemplate</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-producer-%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.</span> <span class="nav-text">启动 producer 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86-mqClient-%E5%AE%9E%E4%BE%8B%E5%90%8D"><span class="nav-number">3.1.</span> <span class="nav-text">处理 mqClient 实例名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-mqClient"><span class="nav-number">3.2.</span> <span class="nav-text">实例化 mqClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#producer-%E6%B3%A8%E5%86%8C%E5%88%B0-mqClient"><span class="nav-number">3.3.</span> <span class="nav-text">producer 注册到 mqClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-MQClientInstance"><span class="nav-number">3.4.</span> <span class="nav-text">启动 MQClientInstance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0-ns-%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.1.</span> <span class="nav-text">更新 ns 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-MQClientAPIImpl"><span class="nav-number">3.4.2.</span> <span class="nav-text">启动 MQClientAPIImpl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-netty-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">初始化 netty 客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E8%BF%87%E6%9C%9F%E7%9A%84-ResponseFuture"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">定时清理过期的 ResponseFuture</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.4.3.</span> <span class="nav-text">启动定时任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0-ns-%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">定时更新 ns 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0-topic-%E6%B6%88%E6%81%AF%E8%B7%AF%E7%94%B1"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">定时刷新 topic 消息路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%90%91-broker-%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">定时向 broker 发送心跳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81-consumer-%E7%9A%84%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">定时发送 consumer 的消费位点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.4.</span> <span class="nav-text">启动消息拉取线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-consumer-%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">获取 consumer 实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%8E%A7"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">流控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E6%8A%A5%E5%B7%B2%E6%B6%88%E8%B4%B9%E7%9A%84%E4%BD%8D%E7%82%B9"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">上报已消费的位点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-broker-%E5%9C%B0%E5%9D%80"><span class="nav-number">3.4.4.4.</span> <span class="nav-text">获取 broker 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-netty-%E5%93%8D%E5%BA%94%E7%9A%84%E5%9B%9E%E8%B0%83-callback"><span class="nav-number">3.4.4.5.</span> <span class="nav-text">定义 netty 响应的回调 callback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%92%8C-broker-%E7%9A%84-tcp-%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.4.4.6.</span> <span class="nav-text">建立和 broker 的 tcp 连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-netty-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-number">3.4.4.7.</span> <span class="nav-text">通过 netty 发送请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E5%90%8C%E6%AD%A5%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF"><span class="nav-number">3.4.4.8.</span> <span class="nav-text">如果是同步拉取消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E6%8B%89%E5%8F%96%E5%88%B0%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-number">3.4.4.9.</span> <span class="nav-text">消费拉取到的消息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%8B%E6%AC%A1%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%82%B9"><span class="nav-number">3.4.4.9.1.</span> <span class="nav-text">设置下次拉取消息的起始位点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%94%BE%E5%85%A5-processQueue"><span class="nav-number">3.4.4.9.2.</span> <span class="nav-text">消息放入 processQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="nav-number">3.4.4.9.3.</span> <span class="nav-text">异步消费消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%AF%B7%E6%B1%82%E6%94%BE%E5%9B%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">3.4.4.9.4.</span> <span class="nav-text">拉取消息请求放回阻塞队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.5.</span> <span class="nav-text">启动负载均衡线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0-mqClient-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">3.4.6.</span> <span class="nav-text">更新 mqClient 的状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-consumer-%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.</span> <span class="nav-text">启动 consumer 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-SubscriptionData"><span class="nav-number">4.1.</span> <span class="nav-text">构建 SubscriptionData</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-mqClient-1"><span class="nav-number">4.2.</span> <span class="nav-text">实例化 mqClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-offsetStore"><span class="nav-number">4.3.</span> <span class="nav-text">实例化 offsetStore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.4.</span> <span class="nav-text">实例化消息消费服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.5.</span> <span class="nav-text">启动消息消费服务的定时任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B6%88%E8%B4%B9%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.5.1.</span> <span class="nav-text">并发消费的定时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.5.2.</span> <span class="nav-text">顺序消费的定时任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#consumer-%E6%B3%A8%E5%86%8C%E5%88%B0-mqClient"><span class="nav-number">4.6.</span> <span class="nav-text">consumer 注册到 mqClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-MQClientInstance-1"><span class="nav-number">4.7.</span> <span class="nav-text">启动 MQClientInstance</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Broker"><span class="nav-number">5.</span> <span class="nav-text">Broker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker-%E5%A6%82%E4%BD%95%E5%81%9A%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.1.</span> <span class="nav-text">Broker 如何做消息持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">5.1.1.</span> <span class="nav-text">写入内核缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B7%E7%9B%98"><span class="nav-number">5.1.2.</span> <span class="nav-text">刷盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker-%E5%A4%84%E7%90%86-Consumer-%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%AF%B7%E6%B1%82"><span class="nav-number">5.2.</span> <span class="nav-text">Broker 处理 Consumer 拉取消息请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-MessageFilter"><span class="nav-number">5.2.1.</span> <span class="nav-text">构建 MessageFilter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%88%B0-MessageQueue"><span class="nav-number">5.2.2.</span> <span class="nav-text">找到 MessageQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E5%9C%A8-MessageQueue-%E7%9A%84%E8%B5%B7%E5%A7%8B%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%BD%AE"><span class="nav-number">5.2.3.</span> <span class="nav-text">定位在 MessageQueue 的起始消费位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%B6%88%E6%81%AF"><span class="nav-number">5.2.4.</span> <span class="nav-text">过滤消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%8B%89%E5%8F%96%E5%88%B0%E6%B6%88%E6%81%AF"><span class="nav-number">5.2.5.</span> <span class="nav-text">如果没拉取到消息</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="西米大人"
      src="/images/me.png">
  <p class="site-author-name" itemprop="name">西米大人</p>
  <div class="site-description" itemprop="description"><blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dcbupt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dcbupt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:byrddc@hotmail.com" title="E-Mail → mailto:byrddc@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">西米大人</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">339k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"OBdFsOOtfIDcNnWdzkGbICmj-gzGzoHsz","app_key":"89LmL4tP7hkyChAmEleq2MdO","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/love.js"></script>

<script src="/js/particle.js"></script>

  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.18/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'OBdFsOOtfIDcNnWdzkGbICmj-gzGzoHsz',
      appKey     : '89LmL4tP7hkyChAmEleq2MdO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
